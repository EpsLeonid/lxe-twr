Title "TA6 Module for LXeTower";
-- v2.0  : The project of digitizing module for LXe-calorimeter

INCLUDE "lpm_compare.inc" ;
INCLUDE "lpm_ff.inc";
INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "lpm_counter.inc" ;
INCLUDE	"lpm_add_sub.inc";
INCLUDE "lpm_divide.inc";

INCLUDE "EdgeSensing.inc";
INCLUDE "LevelSensing.inc" ;
INCLUDE "LightPulser.inc";
--INCLUDE "DelayLine.inc" ;
INCLUDE "PulseShaper.inc" ;
INCLUDE "PhaseSwitch.inc";
--INCLUDE "LVDS_Out.inc";

INCLUDE "PLL_TA6.inc";
INCLUDE "UpLink.inc";
INCLUDE "PROCESSOR.inc" ;
INCLUDE "Digitizer_TA6.inc";
INCLUDE "DDR.inc";
INCLUDE "RAMmain_TA6.inc" ;     -- general purpose RAM
INCLUDE "RAMcommd_TA6.inc" ;    -- CommandList RAM
INCLUDE "Fast_Link.inc";

--INCLUDE "TestRAM_main.inc";

--INCLUDE "RAMdigit_TA6.inc";     -- RAM of Digitizer, declared in Digitizer
--INCLUDE "RAMhist_TA6.inc";      -- RAM of Digitizer, declared in Digitizer
--INCLUDE "im_ram.inc";           -- RAM of Digitizer, declared in Digitizer

INCLUDE "Bunch_Crossing_adjust.inc";
INCLUDE "ErrorCounters.inc";

Constant MainRAM_Offset 		= H"0300";	-- main RAM block, 256words * 16bits
Constant MainRAM_Size			= 256;		-- #768..#1023
Constant ProgRAM_Offset 		= H"0400";	-- Program RAM block, 256words * 16bits
Constant ProgRAM_Size			= 256;		-- #1024..#1279
Constant CommdList_Offset		= H"0C00";	-- #3072  RAM block containing the Command Lists
Constant CommdList_Size			= 1024;		-- #3072..#4095
Constant BaseAddr_offset		= H"0802";	-- #2050  Base Address of Program to be started
Constant Link_IFace_Offset		= H"0820";	-- #2080 - Link's InData_Port
											-- #2081 - Link's Data_Port
Constant OpCode_offset			= H"0822";	-- #2082 - OpCode (read-only register)

Constant SelCommdList			= H"0BB8";	-- #3000 - Select the CommandList (read-only register)

Constant ADC_RAM_Offset 		= H"1000";	-- #4096 RAM of ADC1 #5120 RAM of ADC2 #6144 RAM of ADC3
											-- #7168 RAM of ADC4 #8192 RAM of ADC5 #9216 RAM of ADC6
Constant ADC_RAM_Size			= 1024;		-- Размер области под каждый канал
Constant WF_RAM_Offset			= H"6000";	-- 24576
Constant WF_RAM_Size				= 768;
Constant WF_RAM_SE_Ctrl			= H"6800";	-- 26624
Constant DDREqu_Offset 			= H"2900";	-- #10496
Constant DDREqu_Size 			= 1;
Constant DDRNEqu_Offset			= H"2910";	-- #10512
Constant DDRNEqu_Size			= 1;

Constant ErrorCounters_Offset	= H"3000" ;	-- 12288
Constant ErrorCounters_Size		= 16;

Constant Bunch_Crossing_12_5_T0_Offset	= H"3100";	-- 12544
Constant Bunch_Crossing_12_5_DS_Offset	= H"3108";	-- 12552
Constant Bunch_Crossing_12_5_FLS_Offset	= H"3110";	-- 12560

Constant TestRAM_Offset 		= H"7000";	-- 28672, Test RAM block
Constant TestRAM_Size			= 256;		-- 256words * 16bits

CONSTANT ADC_Bits				= 12;	-- количество входных бит с АЦП
CONSTANT NUM_CH					= 6;	-- количество каналов
CONSTANT TA_Bits				= 10;	-- количество бит в быстром линке

SUBDESIGN TA6
(
-- 1. Reference Clock's & Frequency Control I/O
FQuartz			: input;	-- 25MHz clock from Quartz oscillator       <- Pin46
-- In TA6 module Link's Clock is checked inside Altera but switched outside 
Sw_Quartz		: output;	-- connects Quartz to PLL ref.Input         -> Pin45
Sw_LinkClk		: output;	-- connects Link's Clock to PLL ref.Input   -> Pin49

PLL_in			: input;	-- Ref.clock for PLL (dedicated)            <- Pin31
PLL_ExtOut		: output;	-- Output of PLL.e0 to outside              -> Pin69

-- 1.1 PLL Installation

PLLinst_S0		: output;
PLLinst_S1		: output;
PLLinst_EN		: output;

-- Outputs for Indicators on LED's
LedR			: output;   -- drives the Red LED                       -> Pin63
LedG			: output;   -- drives the Green LED                     -> Pin64
LedB			: output;   -- drives the Blue(Yellow) LED              -> Pin65

-- 2. UpLink signals 
-- 2a. UpLink signals 
LinkClk			: input;    -- Clock from Link's ClockLine              <- Pin 
LinkData		: bidir;    -- Data <-> Link's DataLine                 <->Pin 
LinkTxRx		: output;   -- направление передачи в "DataLine"        -> Pin 

-- 2b. FastLink signals 
SerDataOut[9..0]			: output;  -- данные для передачи с помощью Serializer-а в ИПТ
NWordFLink[1..0]			: output;  -- номер слова в данных для передачи с помощью Serializer-а в ИПТ
RPWDN						: output;  -- вкл/выкл Serializer-а
TPWDN						: output;  -- вкл/выкл Deserializer part
REN							: output;  -- вкл/выкл Serializer-а
DEN							: output;  -- вкл/выкл Serializer-а
SerClk						: output;  -- тактовый сигнал Serializer-а
FLink_Sync					: input;  -- сигнал синхронизации Serializer-а/Deserializer-а
--DataOutLVDS_TA				: output;

-- 3. Digitizers  
ADC_In_Data[NUM_CH-1..0][ADC_Bits-1..0]	: input;    -- input of data from ADC Pin197..219, Pin110..123,...
ADC_OR[5..0]			: input;    -- "Out_of_Range" from ADC1             <- Pin

ExtReset			: input = GND;  -- external Reset (tied to GND --VCC)   <- Pin6

Test[10..1]			: OUTPUT;
)

VARIABLE
--============================================================================
--******** 1. Reference clock's & Frequency Control **************************
PLL				: Pll_TA6;  -- PLL:  Fin=25MHz, PLL.c0=(25MHz shift=0), PLL.c1=(100MHz shift=0)
Clk25			: node; -- This is Global Node 
Clk37_5			: node; -- This is Global Node 
Clk75			: node; -- This is Global Node
Clk100			: node; -- This is Global Node
Clk150			: node; -- This is Global Node

-- Automatic Clock Switch: if External_Clock frequency (kHz) is in specified 
--   range, PhaseSwitch transfers the External_Clock to PLL1's reference input, 
--   thus all PLL's output clocks are locked to the External_Clock. 
PhaseSw			: PhaseSwitch with (FmaxThresh=26000, FminThresh=23000, RefClock=25000);

Clk25del1,
Clk25del2			: node;
PhaseSet,					-- _/^^\_ pulse aligned to _/ front of StartBit
Phase12,
Synchro12,					-- 1-clock _/^\_ pulse aligned to _/ front of PHASE
Synchro25			: node; -- 1-clock _/^\_ pulse aligned to PHASE and half-PHASE
 
--******** Power-up self-Reset and self-Set pulses ***************************
PowerUp0,					--\   Circuit 
PowerUp1, PowerUp2,			-- \  which generates 
PowerUp3, PowerUp4,			--  \ a pulse 
PowerUp5, PowerUp6,			--  / for power-up Reset  \  many milliseconds apart 
PwrUpReset,					-- /  and then few pulses  > from each other
PwrUpSet1,PwrUpSet2			: node;	--/ for power-up Set    /  

--============================================================================
--******** 2. Timers for Indicators on LED's (Duration in ms, RefClock in kHz)
B_Flash				: LightPulser with (Duration = 20, RefClock = 100000); -- Blue
R_Flash				: LightPulser with (Duration = 20, RefClock = 100000); -- Red
LinkFlash			: LightPulser with (Duration = 50, RefClock = 100000); -- Green

--============================================================================
--******** 3a. Up_Link
Link_IFace			: UpLink with (RefClock = 100);

--============================================================================
--******** 3b. Fast_Link TA6/12->IPT

FLink_Data_BUS				: lpm_shiftreg with (lpm_width=12, lpm_direction="unused");
--FLink_cnt					: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- счетчик времени для синхронизации

ReadWFhist					: SRFF;
DataCount					: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- счетчик данных из памяти канала для передачи по линку в ИПТ
ChannelCount				: lpm_counter with (lpm_width = 3, lpm_direction="up"); -- счетчик каналов для передачи по линку в ИПТ
NWordCount					: lpm_counter with (lpm_width = 1, lpm_direction="up"); -- счетчик номера слова передаваемого по линку в ИПТ
%
OutData						: LVDS_Out;
--OutData[TA_Bits-1..0]		: node;
OutData_Reg					: lpm_shiftreg with (lpm_width=14, lpm_DIRECTION="unused"); -- 
%
TestLinkCt					: lpm_counter with (lpm_width = 20, lpm_direction="up"); -- тестовый счетчик для проверки передачи данных

FLink_Error					: node;

-- 4. общий СТОП
  -- LinkMessage_DFF               : DFF;

Event_ES_Beg				: EdgeSensing;
Event_ES_End				: EdgeSensing; 
Event_Trig					: SRFF;
LinkMsg_Trig				: DFF;

Event_ES_Beg_				: EdgeSensing;
Event_ES_End_				: EdgeSensing; 
Event_Trig_					: SRFF;
LinkMsg_Trig_				: DFF;

--============================================================================
--******** 4. Control Unit  
Start_Link		: PulseShaper with (DurationCode=4);--Start whatever by Link command

StartProc_Link	: node;
--StartProc       : node;         -- all sources of Start_Processor combined

StartADC_Link	: node;
--StartADC        : PulseShaper with (DurationCode=4);-- all sources of Start ADC combined

OpCode_load		: node; -- puts Reg_OpCode into "load" mode
--    InDataSave, InDataSaved : node; -- for TEST Only!!

LinkMsg_beg     : node;
SelCommdList_Reg: lpm_shiftreg with (lpm_width=16, lpm_direction="unused");
SelCommdList_Count: lpm_counter with (lpm_width = 1, lpm_direction="up");
SelCommdList_Trig:	SRFF;
SelCommdList_Trig2:	DFF;
SelCommdList_Trig3:	SRFF;
SelCommdList_cs	: node;

--PhSwErr_Ct      : lpm_counter with (lpm_width=16, lpm_direction="up") ; -- counts PhaseSwitch's flips
--LinkErr_Ct      : lpm_counter with (lpm_width=16, lpm_direction="up") ; -- counts Link's errors
--Servo_Mux[15..0]: node; -- additional "multiplexor" of DataBus among servo_objects

Busy			: node; -- flag: Action in progress (Digitizing, Link cycle, ...)
Error			: node;
RESET, 
Reset2			: node;

--============================================================================
--******** 5. Processor, RAM blocks and registers ****************************
CPU				: Processor ;
BaseAddr[7..0]	: node; -- address of the beginning of selected Program

--ADC_RAM belongs to "Digitizer_TA6" unit, and is defined there
MainRAM			: RAMmain_TA6;  -- RAM  256words * 16bits, 1-port
--ProgRAM belongs to "Processor" unit, and is defined there
CommandRAM		: RAMcommd_TA6; -- RAM 1024words * 16bits, 1-port

-- Register contains Base Address of Program to be started
Reg_BaseAddr	: LPM_SHIFTREG with (lpm_width=8, lpm_direction="left");
Reg_OpCode		: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
									 lpm_direction="unused"); -- not important

--============================================================================
--******** 6. Входные данные с АЦП ******************************************************
	TA6Channel[NUM_CH-1..0]      : Digitizer_TA6;
	DDRin[NUM_CH-1..0]			: DDR;
	DDRin_Reg[NUM_CH-1..0]		: lpm_shiftreg with (LPM_WIDTH = 12, LPM_DIRECTION="unused"); -- 
	DDRenEqu1[NUM_CH-1..0]		: node;
	DDRenNEqu1[NUM_CH-1..0]		: node;
	DDRenEqu2[NUM_CH-1..0]		: node;
	DDRenNEqu2[NUM_CH-1..0]		: node;
	DDRenEqu3[NUM_CH-1..0]		: node;
	DDRenNEqu3[NUM_CH-1..0]		: node;
	DDRCnt_Equ[NUM_CH-1..0]		: LPM_COUNTER with (lpm_width = 12, lpm_direction="up"); -- счетчик
	DDRCnt_NEqu[NUM_CH-1..0]		: LPM_COUNTER with (lpm_width = 12, lpm_direction="up"); -- счетчик
	DDRTrig_Equ[NUM_CH-1..0]		: DFFE;
	DDR_Reg_Equ[NUM_CH-1..0]		: lpm_shiftreg with (LPM_WIDTH = 12, LPM_DIRECTION="unused"); -- значение счетчика
	DDRTrig_NEqu[NUM_CH-1..0]	: DFFE;
	DDR_Reg_NEqu[NUM_CH-1..0]	: lpm_shiftreg with (LPM_WIDTH = 12, LPM_DIRECTION="unused"); -- значение счетчика
--Digitizer3      : Digitizer_TA6;
--Digitizer4      : Digitizer_TA6;
--Digitizer5      : Digitizer_TA6;
--Digitizer6      : Digitizer_TA6;
%
--	GATE duration 
GateDur_reg     : lpm_ff WITH (LPM_WIDTH = 10,  --GATE duration code, 1unit=10ns
                               LPM_AVALUE=600); --  default = 600 => 6.0мксек
--	GATE delay 
GateDel_reg     : lpm_ff WITH (LPM_WIDTH =  8,  --GATE delay code, 1unit=10ns
                               LPM_AVALUE=  4); --  default =  4 => 0.04мксек
%
--============================================================================
--******** 7. Internal Bus of Project; "Bus Handler";
--    Address recognition and devise selection
RW				: node; -- RW=1 - a (master)unit will output data 
AddrBus[15..0]	: NODE; -- 16 bit address
DataBus[15..0]	: NODE; -- 16 bit bidir Data Line
--Data[15..0]		: NODE; -- 16 bit bidir Data Line

--Bus_Arbiter     : Arbiter with (DeviceMaxNumber=2%,TimeOut=6%);
--  ^^^^ zdes' nafig ne nuzhen, "Bus Handler" circuit is used instead :
AcsRqDetect		: node; -- =new= "AccessReq" detected
AccessGrtd		: node; -- by 1clk after AccessReq, =1 during whole Operation
AddrSettled		: node; -- Flag: Address is (reliably) settled at AddrBus
--Target_Ready    : node; -- "OR" of all Addr.Comparators' registered outputs
BusOper1,
BusOper2,
BusOper3		: node; -- delay by 3 clocks
DataStrobe		: node; --Strobe: latch data into the destination object, and finish the Bus Oper-n

--  signals of Address Comparators
DevSel[29..1]   : DFF ; -- Registered Addr_Comparator outputs for Selection

MainRAM_cs		: node; -- select for Rd/Wr from/to MainRAM
ProgRAM_cs		: node; -- ProgRAM is declared in Processor module 
CommandRAM_cs	: node; -- select for Rd/Wr from/to CommandList

Link_cs			: node;
OpCode_cs		: node;
--EvtNum_cs       : node;
TA6Channel_cs[NUM_CH-1..0]   : node;
DDREqu_cs[NUM_CH-1..0]		: node;
DDRNEqu_cs[NUM_CH-1..0]		: node;
BaseAddr_cs		: node;

--GateDur_cs		: node;
--GateDel_cs		: node;

ZERO_cs         : node; 

-- 10. Error counter

ErrorCounters_IFace			: ErrorCounters with (Width = 8);
ErrorCounters_IFace_CS		: node;
Sync_ES						: EdgeSensing;
PLL_PS						: PulseShaper;

--============================================================================
--******** 8. Test circuitry
TestCt			: lpm_counter WITH (LPM_width=26,           --\ Test Counter,
									LPM_direction="up");    --/   Blinking counter
--    TestCt_rst1 : node; --\ Cirquit for generating a _/^^\_ ,
--   TestCt_rst2 : node; --/   duration >=(1/2)Tquartz

--TestRAM			: TestRAM_main;
TestRAM_cs		: node;
--============================================================================
BEGIN
DEFAULTS

PLLinst_S0	= VCC;
PLLinst_S1	= GND;
PLLinst_EN	= GND;

REN		= GND; -- включить/выключить выходы Deserializer  
DEN		= VCC; -- включить/выключить выходы Serializer
RPWDN	= GND; -- включить/выключить Deserializer  
TPWDN	= VCC; -- включить/выключить Serializer

StartProc_Link  = GND;  StartADC_Link   = GND;

FLink_Error = GND;

END DEFAULTS;

--============================================================================
--******** 1. Reference Clock & Frequency Control ****************************

--============================================================================
--******** 1a. POWER_UP self-Reset pulse *************************************
--PowerUp0= DFF (.d=!(camac_s1 & camac_s2) AND PLL1.locked, .clk=Clk25);
        --               ^^^^^^^^ substituted by (CAMAC_IFace.Reset & CAMAC_IFace.Aout[4])..
        --  .. to provide a possibility to emulate PowerUp situation
PowerUp0 = DFF (.d=PLL.locked, .clk=Clk25); --!ExtReset AND 

PowerUp1 = SRFF(.s=(PowerUp0 AND (TestCt.q25 & TestCt.q0)),--sets 1.0s after PLL1 has locked
				.r=ExtReset, .clk=Clk25);  -- .r never =1
PowerUp2 = SRFF(.s=(PowerUp1 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);  -- .r never =1
PwrUpReset  = PowerUp1 AND !PowerUp2;   -- ONE pulse ~1sec after powering up

--******** 1b. POWER_UP self-Set pulse ***************************************
PowerUp3 = SRFF(.s=(PowerUp2 AND (!TestCt.q20 & !TestCt.q19 &  TestCt.q18)), --sets 0.015s after PwrUpReset
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PowerUp4 = SRFF(.s=(PowerUp3 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PwrUpSet1   = PowerUp3 AND !PowerUp4;       -- ONE pulse ~0.06sec after PwrUpReset

--******** 1c. POWER_UP self-Set pulse ***************************************
PowerUp5 = SRFF(.s=(PowerUp4 AND ( TestCt.q20 & !TestCt.q19 & !TestCt.q18)), --sets 0.060s after PwrUpReset
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PowerUp6 = SRFF(.s=(PowerUp5 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PwrUpSet2 = PowerUp3 AND !PowerUp4;       -- ONE pulse ~0.06sec after PwrUpReset

--**************** Automatic Clock Switch for PLL reference ******************
PhaseSw.clock	= FQuartz ;         -- 25MHz from Quartz
PhaseSw.LinkClk	= LinkClk ;         -- 25MHz from Link
PhaseSw.Reset	= GND  ;
--    Phase25     = PhaseSw.Phase25 ; -- selected clock output to real pin
Sw_LinkClk		= !PhaseSw.LinkClk_selected; -- connects Link's Clock to PLL ref.Input
Sw_Quartz		= PhaseSw.LinkClk_selected; -- connects Quartz to PLL ref.Input

--**************** PLL section ***********************************************
PLL.inclk0	= PLL_in;           -- ~25MHz from Link -> Input of PLL
Clk25		= PLL.c0;           --  25MHz = (Fin x 1)    from PLL.c0
Clk100		= GLOBAL(PLL.c1);   -- 100MHz = (Fin x 4)    from PLL.c1
Clk150		= GLOBAL(PLL.c2);   -- 150MHz = (Fin x 6)    from PLL.c1
Clk75		= GLOBAL(PLL.c4);   -- 75MHz = (Fin x 3)    from PLL.c1
PLL_ExtOut	= PLL.c3;           --  25MHz -> outside of Altera
--PLL1.pfdena = VCC;--!Reset;
--        = PLL.locked;           -- connected below

--**************** Synchro-signals generation ********************************
--  25MHz Clock ^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^
-- 100MHz Clock _/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\__
--                           ^-this falling edge is selected
--    Clk25Del1 ^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^
--    Clk25Del2 ^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_________
--    Phase12   __________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____synchronized with actual _/ of StartBit
--    Synchro12 _____________/^^^^^^^\__________________________________aligned to actual _/ of StartBit
--    Synchro25 _____________/^^^^^^^\_______________________/^^^^^^^\__aligned to actual _/ of StartBit and to half-PHASE

Clk25Del1	= DFF(.d=Clk25,    .clk=!Clk100); 
Clk25Del2	= DFF(.d=Clk25Del1,.clk=!Clk100); 

PhaseSet	= EdgeSensing(.d=Link_IFace.LinkMessage, -- must be aligned: 
						.clk=Clk100, .reset=RESET); -- 8 or 16 "Clk100"clocks after actual _/ of StartBit
Phase12		= DFFE(.d=!Phase12,.clk=Clk100, .ena=(!Clk25Del1 & !Clk25Del2),
					.prn=!PhaseSet);            -- F = (2*Fphase)/2 , _/ aligned to Phase
                    -- ^^^^ excluded temporary !!

Synchro12	= DFF(.d=(!Clk25Del1 & Clk25Del2 & !Phase12), .clk=!Clk100 );
Synchro25	= DFF(.d=(!Clk25Del1 & Clk25Del2), .clk=!Clk100 );

--********************************** Общий стоп ***********************************	
Event_ES_Beg.(d,clk)  = (!LinkData%первый бит входной посылки, нужно исправить% AND !Event_Trig.q, CLK100); -- Ii?aaaeaiea noa?oiaiai aeoa
LinkMsg_Trig.(d,clk)  = (!Link_IFace.LinkMessage, CLK100);    
Event_ES_End.(d,clk)  = (LinkMsg_Trig.q, CLK100);
Event_Trig.(S,clk,R)  = (Event_ES_Beg.q, CLK100, Event_ES_End.q);

Event_ES_Beg_.(d,clk) = (!LinkData%первый бит входной посылки, нужно исправить% AND !Event_Trig_.q, CLK150); -- Ii?aaaeaiea noa?oiaiai aeoa
LinkMsg_Trig_.(d,clk) = (!Link_IFace.LinkMessage, CLK150);    
Event_ES_End_.(d,clk) = (LinkMsg_Trig_.q, CLK150);
Event_Trig_.(S,clk,R) = (Event_ES_Beg_.q, CLK150, Event_ES_End_.q);

--============================================================================
-- ******** 2. Indicators section ********************************************
--LedG = OPNDRN ( !( PLL.locked       --always "ON" => PLL locked to LinkClock
--    OR (!PLL.locked AND TestCt.q[25]) --blinks slowly => PLL locked to Quartz
--   %XOR LinkFlash.DirOut%) );       --short blinks by Link cycles
LedG = OPNDRN ( !(((PLL.locked AND  PhaseSw.LinkClk_Selected) --always "ON" => PLL locked to LinkClock
				OR (PLL.locked AND !PhaseSw.LinkClk_Selected AND TestCt.q[25])))); --blinks slowly => PLL locked to Quartz
--LedG = OPNDRN (!(TestCt.q[25]));
LinkFlash.(clock, event)= (CLK100, Link_IFace.LinkMessage);

LedB = OPNDRN( !(B_Flash.DirOut OR Busy));
--LedB = OPNDRN( !TestCt.q[21] ) ;    -- for TEST Only! - quick blink
B_Flash.(clock, event)  =(Clk100,Busy); -- Busy is defined in Control Unit section

LedR = R_Flash.LightOut;
--LedR = OPNDRN( TC.q[21] ) ;         -- for TEST Only! - quick blink
R_Flash.(clock, event)  =(Clk100,Error);-- Error is defined in Control Unit section
									
--============================================================================
--******** 3. LINK's Interface ***********************************************
--	Serial Port
LinkData    = TRI (!Link_IFace.LinkData_out, Link_IFace.TxRx);-- Output to Pin
Link_IFace.LinkData_in = !LinkData ;                          -- Input from Pin
LinkTxRx    =  ( Link_IFace.TxRx );     -- Tx/Rx control, High => Tx
	
-- Project Bus Port
Link_IFace.Clock	=	Clk100 ;

--    = Link_IFace.IORq ;               -- Connected at Processor section
--    = Link_IFace.RdWr_out;            -- Connected at Processor section
--    = Link_IFace.LinkMessage ;        -- connected at "Control Unit" section

Link_IFace.DataBus_in[] = DataBus[] ;
--    = Link_IFace.DataBus_out[] ;      -- connected at "Internal Bus ..." section
Link_IFace.Select       = DevSel[4].q %OR DevSel[5].q% ;
Link_IFace.RdWr_in      = RW ;
Link_IFace.DataStrobe   = DataStrobe ;

Link_IFace.Reset        = RESET ;

--**** For TEST ONLY !! - temporary :
--IF ((Link_IFace.LinkMessage == VCC) AND 
--    (OpCodeSaved == GND) AND
--    (Link_IFace.IORq AND Link_IFace.RdWr_out) )
--    Then  DataBus[7..0]     = Link_IFace.OpCode_out[7..0] ;
--End IF;

--============================================================================
--******** 4. Control Unit section *******************************************

--**************** LINK Cycle proceeding units *******************************
--LinkCycleBeg= EdgeSensing(.D= Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);
--LinkCycleEnd= EdgeSensing(.D=!Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);

-- OpCode is stored into OpCode_Reg by any LinkOperation :
OpCode_load = LevelSensing(.D=Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);

-- Start an Action by Link command  (4-clock pulse)
Start_Link.(D, clk, reset)  = (Link_IFace.LinkMessage, Clk100, RESET);

IF (Link_IFace.LinkMessage == VCC)  then -- If VALID command received, 
	CASE  Link_IFace.OpCode_out[(CommandSize+Pause-1)..0] is -- recognizing the particular Operation :
		--WHEN  Read1  => BaseAddr[] = 24;        -- Read  1 word from Object
		--                StartProc_Link  = Start_Link.q;
		--WHEN  Write1 => BaseAddr[] = 88;        -- Write 1 word  to Object
		--                StartProc_Link  = Start_Link.q;
		WHEN  Read		=> BaseAddr[]    = 80;   --#145-"Read" (=<8words) from Objects 
						StartProc_Link  = Start_Link.q; -- Start up the Program
		WHEN  Write		=> BaseAddr[]      =192; --#154-"Write"(=<4words) to Objects
						StartProc_Link  = Start_Link.q; -- Start up the Program
		WHEN  Read62   => BaseAddr[] =  2;-- #130-"Read":  Read 62 words from Object(s)
						StartProc_Link  = Start_Link.q;
		WHEN  Write8  => BaseAddr[] = 160;-- #137-"Write": Write 8 words  to Object(s)
						StartProc_Link  = Start_Link.q;

		WHEN  StartRegul       =>    -- #193-"START_Normal" (Чтение0)
						BaseAddr[] = 72;                -- Program: CommdList_Rd000 for test with new system
						StartProc_Link  = Start_Link.q; -- Start up the Program
						StartADC_Link   = SelCommdList_Trig.q;--Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr001 =>      -- #202-"Write by CommdLst001" (Запись0)
						BaseAddr[] =100;                -- Program: CommdList_Wr001
						StartProc_Link  = Start_Link.q; -- Start up the Program

		WHEN  StartAlter       =>    -- #210-"START_Alternative" (Чтение1)
						BaseAddr[]      = 28;           -- Program: CommdList_Rd010
						StartProc_Link  = Start_Link.q; -- Start up the Program
						StartADC_Link   = Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr011 =>      -- #217-"Write by CommdLst011" (Запись1)
						BaseAddr[] =106;                -- Program: CommdList_Wr011
						StartProc_Link  = Start_Link.q; -- Start up the Program

		WHEN  CommdLst_Rd100   =>    -- #226-"Read by CommdLst100" (Чтение2)
						BaseAddr[]      = 32;           -- Program: CommdList_Rd100
						StartProc_Link  = Start_Link.q; -- Start up the Program
						StartADC_Link   = Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr101 =>      -- #233-"Write by CommdLst101" (Запись2)
						BaseAddr[] =112;                -- Program: CommdList_Wr101
						StartProc_Link  = Start_Link.q; -- Start up the Program

		WHEN  CommdLst_Rd110   =>    -- #241-"Read  by CommdLst_selected_by_InData" (Чтение3)
						BaseAddr[]      = 36;           -- Program: CommdList_Rd_InData;
						StartProc_Link  = Start_Link.q; -- Start up the Program
						StartADC_Link   = Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr111 =>      -- #250-"Write by CommdLst111" (Запись3)
						BaseAddr[] =118;                -- Program: CommdList_Wr111
						StartProc_Link  = Start_Link.q; -- Start up the Program

		WHEN  Rd_SelCommdLst =>     -- #198-"Read  by CommdLst_selected_by_InData"
						BaseAddr[]        = 72;           --Program: Rd_SelCommdList
						StartProc_Link    = Start_Link.q;          --Start up the Program
						StartADC_Link   = SelCommdList_Trig.q;--SelCommdList_Count.q; -- Start up the Digitizing Cycle
		WHEN  Wr_SelCommdLst =>     -- #205-"Write by CommdLst_selected_by_InData"
						BaseAddr[]        =153;           --Program: Wr_SelCommdList
						StartProc_Link    = Start_Link.q;          --Start up the Program
						StartADC_Link   = SelCommdList_Trig.q;--SelCommdList_Count.q; -- Start up the Digitizing Cycle

		WHEN OTHERS		=> StartProc_Link = GND;
						   StartADC_Link  = GND;
    End CASE;
End IF ;

FOR i IN 0 TO (NUM_CH-1) GENERATE
	Busy    = Link_IFace.LinkMessage OR CPU.Working;
--			OR TA6Channel[i].Working %OR Loader.Working% ;
END GENERATE;

SelCommdList_Reg.(data[15..8],data[7],data[6..0]) = (B"00001100",SelCommdList_Trig3.q,B"0000000");
SelCommdList_Reg.(clock,load,enable) = (Clk100,VCC,VCC);

LinkMsg_beg = EdgeSensing(.D=Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);
SelCommdList_Trig.(S,R,clk,clrn) = (TA6Channel[3].test1 AND LinkMsg_beg AND !SelCommdList_Trig.q, 
									EdgeSensing(.D=!Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET) AND SelCommdList_Trig.q AND SelCommdList_Trig3.q, Clk100, !RESET);
SelCommdList_Trig2.(d,clk) = (SelCommdList_Trig.q, Clk100);
SelCommdList_Trig3.(S,R,clk,clrn) = (LinkMsg_beg AND SelCommdList_Trig2.q, 
									EdgeSensing(.D=!Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET) AND SelCommdList_Trig.q AND SelCommdList_Trig3.q, Clk100, !RESET);
%SelCommdList_Count.cnt_en = EdgeSensing(.D= SelCommdList_Trig.q, .clk=Clk100, .reset=RESET);
SelCommdList_Count.(clock,clk_en) = (Clk100, VCC);
%
Error   = Link_IFace.Error OR CPU.Error OR FLink_Error;

RESET   = PwrUpReset OR ExtReset ;

--============================================================================
--******** 5. Processor ******************************************************
CPU.Clock   = Clk100;   CPU.Sync    = Synchro25; 
CPU.ProgInit        = StartProc_Link ; 
CPU.BaseAddr[7..0]  = BaseAddr[7..0];
--CPU.Int[4..1]       = 
CPU.int1            = Link_IFace.IORq;
CPU.int4            = TestCt.q[25];

CPU.DataIn[]        = DataBus[];        -- Data Bus - input
--            = CPU.AddrOut[15..0]        -- \ connected in "Internal Bus"
--            = CPU.DataOut[15..0]        -- /                       section

--            = CPU.AccessReq ;           -- connected in "Internal Bus" section
--                    = CPU.RdWr;         -- connected in "Internal Bus" section
--CPU.AccessGranted   = AccessGtd;        -- connected in "Internal Bus" section
--CPU.DataStrobe      = DataStrobe;       -- connected in "Internal Bus" section

--            = CPU.Working;      -- connected below, in "Control Unit" section
--            = Error;            -- connected below, in "Control Unit" section
CPU.Reset   = RESET;            -- reset by MainRESET

-- Direct access to ProgRAM as to a part of common RAM
CPU.(ProgRAM_addr[ 7..0],ProgRAM_data[15..0]) = (AddrBus[7..0], DataBus[]);
CPU.ProgRAM_we  = DataStrobe & DevSel[2] & RW;
--            = CPU.ProgRAM_q[];  -- connected in "Internal Bus" section

--============================================================================
-- RAM blocks, Registers

MainRAM.(address[7..0], data[],    clock,    wren                     ) =
        (AddrBus[7..0], DataBus[], Clk100,(DataStrobe & DevSel[1] & RW)); 
--ProgRAM belongs to "Processor"unit, and is defined there
CommandRAM.(address[9..0], data[], clock,    wren                     ) =
        (AddrBus[9..0], DataBus[], Clk100,(DataStrobe & DevSel[3] & RW)); 

--************ Circuit which saves OpCode ************
Reg_OpCode.data[(CommandSize+Pause-1)..0]= Link_IFace.OpCode_out[(CommandSize+Pause-1)..0];
Reg_OpCode.(clock, enable, load)= (Clk100, OpCode_load, VCC); -- catch data when RxOpCodeReload=1 
Reg_OpCode.(aclr, sclr)         = (RESET, GND );

Reg_BaseAddr.data[7..0]     = DataBus[7..0];
Reg_BaseAddr.(clock,enable) =(Clk100, (DataStrobe & DevSel[14] & RW));
Reg_BaseAddr.(load, aclr)   = (VCC, RESET);

--============================================================================
--******** 6. Digitizers section *********************************************

--Only for test
--============================================================================
-- Im_ADC - a RAM which contains data substituted for the ADC data (Тестовая память для проверки алгоритма)
%	Im_ADC.data_a[] = GND;
	Im_ADC.(address_a[], clock_a, wren_a) = (Im_ADCCt.q[7..0], ADC_Clock, GND);
	
--	Im_ADC.(data_b[],address_b[], clock_b)= (DataBus_In[],Im_RAMAddrBus[7..0], Bus_clock);
	Im_ADC.(data_b[],address_b[], clock_b)= (DataBus_In[],AddrBus_In[7..0], Bus_clock);
	Im_ADC.wren_b = DataBusStrobe and  DirectIn AND Select AND Ram_SeL[0];
	
	Im_ADCCt.clock   = ADC_Clock;
	Im_ADCCt.sclr = !Working;
--	Im_ADCCt.clk_en  = VCC;
--	Im_ADCCt.cnt_en = GN;
--	Im_RAMAddrBus[7..0] = AddrBus_In[7..0] + Im_ADCCt.q[7..0]; -- выставление адреса в 0 для текущего набора FOR-ов
%
--============================================================================

FOR i IN 0 TO (NUM_CH-1) GENERATE

	TA6Channel[i].Bus_Clock			= Clk100; -- Clock 100MHz
	TA6Channel[i].ADC_Clock			= Clk100; -- Clock 100MHz
	TA6Channel[i].Flink_clock		= Clk75;

	TA6Channel[i].DigitInit			= StartADC_Link;--PwrUpSet1;-- initiates Cycle: Digitizing and store the results in ADC_RAM
	TA6Channel[i].RegInit			= PwrUpSet1;
	TA6Channel[i].Reset				= RESET; -- reset by MainRESET
	TA6Channel[i].ADCdata[]			= (!ADC_In_Data[i][11],ADC_In_Data[i][10..0]);
	TA6Channel[i].DataBus_In[15..0] = DataBus[15..0];
	TA6Channel[i].AddrBus_In[9..0]	= AddrBus[9..0] ;

	TA6Channel[i].DataBusStrobe	    = DataStrobe ;
	TA6Channel[i].DirectIn			= RW;
	TA6Channel[i].Select			= DevSel[5+i].q ;
	TA6Channel[i].Working1			= Link_IFace.LinkMessage;
	TA6Channel[i].WriteRAM			= SelCommdList_Trig.q;--SelCommdList_Count.q;
--END GENERATE;
--	Digitizer1.ADCdata[] = DDRin.dataout_h[9..0];  -- input of parallel data from ADC
%	FOR j IN 0 TO (ADC_Bits-1) GENERATE
		DDRin[i].(datain[], inclock, aclr) = (ADC_In_Data[i][], Clk100, Reset);
	END GENERATE;%
	DDRin[i].(datain[], inclock, aclr) = ((!ADC_In_Data[i][11],ADC_In_Data[i][10..0]), Clk100, Reset);
	DDRin_Reg[i].(data[], clock, enable, load) = (DDRin[i].dataout_h[11..0], Clk100, VCC, VCC);

	IF ((DDRin_Reg[i].q[0] XOR DDRin[i].dataout_h[0]) AND 
		(DDRin[i].dataout_h[0] == DDRin[i].dataout_l[0]))
			THEN DDRenEqu1[i] = VCC;
			ELSE DDRenEqu1[i] = GND;
	END IF;

	IF ((DDRin_Reg[i].q[0] XOR DDRin[i].dataout_h[0]) AND 
		(DDRin[i].dataout_h[0] != DDRin[i].dataout_l[0]))
			THEN DDRenNEqu1[i] = VCC;
			ELSE DDRenNEqu1[i] = GND;
	END IF;

	DDRCnt_Equ[i].(clock, sclr, clk_en, cnt_en) = (Clk100, !TA6Channel[i].Working, VCC, DDRTrig_Equ[i].q);
	DDRCnt_NEqu[i].(clock, sclr, clk_en, cnt_en) = (Clk100, !TA6Channel[i].Working, VCC, DDRTrig_NEqu[i].q);
	
	DDRTrig_Equ[i].(d, clk, clrn) = (DDRenEqu1[i], Clk100, TA6Channel[i].Working);	-- 1-clock   _/^^^\_
	DDR_Reg_Equ[i].(data[], clock, enable, load) = (DDRCnt_Equ[i].q[], Clk100, DDRTrig_Equ[i].q, VCC);
	DDRTrig_NEqu[i].(d, clk, clrn) = (DDRenNEqu1[i], Clk100, TA6Channel[i].Working);	-- 1-clock   _/^^^\_
	DDR_Reg_NEqu[i].(data[], clock, enable, load) = (DDRCnt_NEqu[i].q[], Clk100, DDRTrig_NEqu[i].q, VCC);

	IF ((DDRin_Reg[i].q[3] XOR DDRin[i].dataout_h[3]) AND 
		(DDRin[i].dataout_h[3] == DDRin[i].dataout_l[3]))
			THEN DDRenEqu2[i] = VCC;
			ELSE DDRenEqu2[i] = GND;
	END IF;

	IF ((DDRin_Reg[i].q[3] XOR DDRin[i].dataout_h[3]) AND 
		(DDRin[i].dataout_h[3] != DDRin[i].dataout_l[3]))
			THEN DDRenNEqu2[i] = VCC;
			ELSE DDRenNEqu2[i] = GND;
	END IF;

	IF ((DDRin_Reg[i].q[7] XOR DDRin[i].dataout_h[7]) AND 
		(DDRin[i].dataout_h[7] == DDRin[i].dataout_l[7]))
			THEN DDRenEqu3[i] = VCC;
			ELSE DDRenEqu3[i] = GND;
	END IF;

	IF ((DDRin_Reg[i].q[7] XOR DDRin[i].dataout_h[7]) AND 
		(DDRin[i].dataout_h[7] != DDRin[i].dataout_l[7]))
			THEN DDRenNEqu3[i] = VCC;
			ELSE DDRenNEqu3[i] = GND;
	END IF;
END GENERATE;
--Working,        -- connected in "Control Unit" section
--Error,          -- connected in "Control Unit" section

--============================================================================
--******** 7. Fust LINK's Interface *******************************************
--************************** Настройка передатчика ***************************** 

--FLink_Sync = TestCt.q[25];

--************************** Передача данных в IPT ***************************** 

Clk37_5 = DFF (.d = !Clk37_5, .clk = Clk75);
SerClk = Clk25;--Clk37_5;--
ReadWFhist.(s,r,clk) = (Link_IFace.LinkMessage, (DataCount.cout AND ChannelCount.q[0] AND ChannelCount.q[2]), Clk100);
FOR i IN 0 TO (NUM_CH-1) GENERATE
	TA6Channel[i].ReadWFhist = ReadWFhist.q;
END GENERATE;
DataCount.(clock, cnt_en, sclr) = (Clk25, ReadWFhist, !ReadWFhist);
ChannelCount.(clock, cnt_en, sclr) = (Clk25, DataCount.cout, !ReadWFhist);
NWordCount.(clock, cnt_en) = (Clk25, VCC);
FLink_Data_BUS.data[11..10] = (!NWordCount.q[], NWordCount.q[]);
FLink_Data_BUS.clock = Clk25;

IF Link_IFace.LinkMessage == GND Then
	FLink_Data_BUS.data[5..0]	= TA6Channel[5..0].EventFound;	-- Trigger efficiency check
	FLink_Data_BUS.data[9..6]	= (VCC,GND,VCC,GND);--TA6Channel[4..0].EventFound;
Else 
	CASE ChannelCount.q[] IS 
		 When b"000" => TA6Channel[0].DAQAddrBus_In[] = DataCount.q[];
						FLink_Data_BUS.data[9..0] = TA6Channel[0].DAQDataBusOut[];
		 When b"001" => TA6Channel[1].DAQAddrBus_In[] = DataCount.q[];
						FLink_Data_BUS.data[9..0] = TA6Channel[1].DAQDataBusOut[];
		 When b"010" => TA6Channel[2].DAQAddrBus_In[] = DataCount.q[];
						FLink_Data_BUS.data[9..0] = TA6Channel[2].DAQDataBusOut[];
		 When b"011" => TA6Channel[3].DAQAddrBus_In[] = DataCount.q[];
						FLink_Data_BUS.data[9..0] = TA6Channel[3].DAQDataBusOut[];
		 When b"100" => TA6Channel[4].DAQAddrBus_In[] = DataCount.q[];
						FLink_Data_BUS.data[9..0] = TA6Channel[4].DAQDataBusOut[];
		 When b"101" => TA6Channel[5].DAQAddrBus_In[] = DataCount.q[];
						FLink_Data_BUS.data[9..0] = TA6Channel[5].DAQDataBusOut[];
--		 WHEN OTHERS => FLink_Error = VCC;
	END CASE;
END IF;


FLink_Data_BUS.data[11..0] = (!ADC_In_Data[1][11],ADC_In_Data[1][10..0]);

SerDataOut[9..0] = FLink_Data_BUS.q[11..2]; --TestLinkCt.q[9..0];
NWordFLink[] = (GND,VCC);

TestLinkCt.(clock, clk_en)	= (Clk25, VCC); -- Test Counter, can be used to drive LED blinking
TestLinkCt.cnt_en			= PowerUp0;
TestLinkCt.aclr				= !PowerUp0;    -- even if NO clock - Reset does occur
----------For tests with Ser/Deser
%
IF (TestLinkCt.q[18] == VCC) 
	THEN SerDataOut[3..0] = VCC;--TestLinkCt.q[7];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[7..4] = VCC;--TestLinkCt.q[8];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[9..8] = GND;--TestLinkCt.q[9];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 NWordFLink[] = GND;--TestLinkCt.q[9];--(VCC,GND);--FLink_Data_BUS.q[11..10];
	ELSE SerDataOut[3..0] = GND;--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[7..4] = TestLinkCt.q[8];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[9..8] = TestLinkCt.q[9];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 NWordFLink[] = TestLinkCt.q[9];--(VCC,GND);--FLink_Data_BUS.q[11..10];
END IF;
%
%
OutData.(tx_in[], tx_inclock) = (FLink_Data_BUS.q[11..0], Clk25);
DataOutLVDS_TA = OutData.tx_out[];
%
--============================================================================
--******** 8. Error counter **************************************************

-- Project Bus Port, common
	ErrorCounters_IFace.clock 			=	CLK100;
	ErrorCounters_IFace.AddrBusIn[3..0]	=	AddrBus[3..0];
	ErrorCounters_IFace.DataBusStrobe	=	DataStrobe ;
-- Project Bus Port, Slave
	--ErrorCounters_IFace.DirectIn		= 	RW;
	ErrorCounters_IFace.Select			= 	DevSel[28].q;

	ErrorCounters_IFace.ErrorInputs[0]	=	CPU.Error;--Bus_Arbiter.ErrorLight;
	ErrorCounters_IFace.ErrorInputs[1]	=	Error;
	ErrorCounters_IFace.ErrorInputs[2]	=	Link_IFace.Error;
	ErrorCounters_IFace.ErrorInputs[3]	=	Link_IFace.Error;
	ErrorCounters_IFace.ErrorInputs[4]	=	FLink_Error;
	ErrorCounters_IFace.ErrorInputs[5]	=	FLink_Error;
	ErrorCounters_IFace.ErrorInputs[6]	=	Error;--Sync_ES.q;
	ErrorCounters_IFace.ErrorInputs[7]	=	(ADC_OR0 OR ADC_OR1 OR ADC_OR2 OR ADC_OR3 OR ADC_OR4 OR ADC_OR5);--(TA6Channel0.Error OR TA6Channel1.Error OR TA6Channel2.Error OR TA6Channel3.Error OR TA6Channel4.Error OR TA6Channel5.Error);
--	ErrorCounters_IFace.ErrorInputs[9]	=	(ADC_OR0 OR ADC_OR1 OR ADC_OR2 OR ADC_OR3 OR ADC_OR4 OR ADC_OR5);--PLL_PS.q;
%
	Sync_ES.(d,clk)  = (FLink_Lock, CLK100);

	PLL_PS.(d,clk,clr,Shaping_Time[]) = (PLL.locked,FLCLK,GND,B"11111010");
%
--============================================================================
-- 9. Internal Bus of Project & Data transfer control ************************

AddrBus[15..0]	= CPU.AddrOut[15..0];   -- CPU is the only Master, rules forever
RW				= CPU.RdWr ;            -- эряЁртыхэшх яхЁхфрўш
CPU.AccessGranted	= AccessGrtd;       -- 
CPU.DataStrobe		= DataStrobe;       -- connected in "Control Unit" section

-- Bus Handler : 
AcsRqDetect = EdgeSensing(.D=CPU.AccessReq, .clk=Clk100, .reset=RESET);
AccessGrtd	=SRFF(.S=AcsRqDetect,.clk=Clk100, .r=DataStrobe, .clrn=!RESET); --=1 during whole Operation
AddrSettled =SRFF(.S=(AccessGrtd & !AddrSettled),                           --flag; enables "DevSel[]" triggers
						.clk=Clk100, .r=DataStrobe, .clrn=!RESET); 
BusOper1	= DFF(.D=AddrSettled,.clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
BusOper2	= DFF(.D=BusOper1,   .clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
BusOper3	= DFF(.D=BusOper2,   .clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
DataStrobe	= DFF(.D=BusOper3,   .clk=Clk100,.clrn=!RESET); -- 1-clk pulse

-- When Address from Master is set on the Address Bus, ...
-- DEVICE SELECTION - the Slave-device is identified by its Address 

-- 1) Main RAM, Program RAM, CommandList RAM
IF ((AddrBus[15..0] >=  MainRAM_Offset ) AND 
	(AddrBus[15..0] <= (MainRAM_Offset + MainRAM_Size - 1))) 
	Then  MainRAM_cs    = VCC;          -- Address belongs to MainRAM
	Else  MainRAM_cs    = GND;
End IF;
IF ((AddrBus[15..0] >=  ProgRAM_Offset ) AND 
	(AddrBus[15..0] <= (ProgRAM_Offset + ProgRAM_Size - 1))) 
	Then  ProgRAM_cs    = VCC;          -- Address belongs to ProgRAM
	Else  ProgRAM_cs    = GND;
End IF;
IF ((AddrBus[15..0] >=  CommdList_Offset ) AND 
	(AddrBus[15..0] <= (CommdList_Offset + CommdList_Size - 1))) 
	then  CommandRAM_cs = VCC;          -- Address belongs to CommandRAM
	else  CommandRAM_cs = GND;
End IF;

-- 2) ADC Unit
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] >= (ADC_RAM_Offset + i*ADC_RAM_Size)) AND
		(AddrBus[15..0] <= (ADC_RAM_Offset + (i+1)*(ADC_RAM_Size - 1))) ) 
		THEN 	TA6Channel_cs[i]   = VCC;
		ELSE 	TA6Channel_cs[i]   = GND;
	END IF;
END GENERATE;
%IF ((AddrBus[15..0] >= ADC1RAM_Offset) AND 
    (AddrBus[15..0] <= (ADC1RAM_Offset + ADC_RAM_Size -1)) ) 
    Then TA6Channel_cs[0]  = VCC ;         -- Address belongs to ADC Unit
    Else TA6Channel_cs[0]  = GND ;
End IF ;%
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] == (DDREqu_Offset + i*DDREqu_Size)) AND
		(AddrBus[15..0] <= (DDREqu_Offset + (i+1)*DDREqu_Size)) )
		Then DDREqu_cs[i]  = VCC ;         -- Address belongs to ADC Unit
		Else DDREqu_cs[i]  = GND ;
	End IF ;
END GENERATE;
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] == (DDRNEqu_Offset + i*DDRNEqu_Size)) AND
		(AddrBus[15..0] <= (DDRNEqu_Offset + (i+1)*DDRNEqu_Size)) )
		Then DDRNEqu_cs[i]  = VCC ;         -- Address belongs to ADC Unit
		Else DDRNEqu_cs[i]  = GND ;
	End IF ;
END GENERATE;
%
IF (AddrBus[15..0] == GateDur_Offset) 
	Then GateDur_CS = VCC;
	Else GateDur_CS = GND ;
End IF ;
IF (AddrBus[15..0] == GateDel_Offset) 
	Then GateDel_CS = VCC;
	Else GateDel_CS = GND ;
End IF ;
%
-- 4) Link: InData, DataBus_in / DataBus_out
--IF ( AddrBus[15..0] == Link_IFace_Offset ) 
--    Then Link_InData_cs = VCC ;         -- Address of Link's InData register
--    Else Link_InData_cs = GND ;
--End IF ;
IF ( (AddrBus[15..0] == Link_IFace_Offset)          --Addr of Link's InData Reg
	OR (AddrBus[15..0] == (Link_IFace_Offset +1)) ) --Addr of Link's I/O port
	Then Link_cs = VCC ;
	Else Link_cs = GND ;
End IF ;
IF ( AddrBus[15..0] == SelCommdList)          --Addr of Link's InData Reg
	Then SelCommdList_cs = VCC ;
	Else SelCommdList_cs = GND ;
End IF ;

-- 5) Registers and similar objects
IF (AddrBus[15..0] == OpCode_Offset) 
	Then OpCode_cs = VCC;
	Else OpCode_cs = GND ;
End IF ;
IF (AddrBus[15..0] == BaseAddr_Offset) 
	Then BaseAddr_cs = VCC;
	Else BaseAddr_cs = GND ;
End IF ;

-- 6) Error counter
IF ((AddrBus[15..0] >= ErrorCounters_Offset) AND ((ErrorCounters_Offset + ErrorCounters_Size) > AddrBus[15..0]) ) 
	THEN ErrorCounters_IFace_CS = VCC ; 
	ELSE ErrorCounters_IFace_CS = GND ; 
END IF ;
-- 7) Test
IF ((AddrBus[15..0] >=  TestRAM_Offset ) AND 
	(AddrBus[15..0] <= (TestRAM_Offset + TestRAM_Size - 1))) 
	Then TestRAM_cs = VCC;          -- Address belongs to MainRAM
	Else TestRAM_cs = GND;
End IF;

-- 8) ZERO: fictive object, always replies B"0000000000000000" word
IF ( AddrBus[15..0] == B"1111111111111111" ) 
	Then ZERO_cs = VCC ;         -- Address of ZERO word
	Else ZERO_cs = GND ;
End IF ;

DevSel[ 1].d	= MainRAM_cs ;
DevSel[ 2].d	= ProgRAM_cs ;
DevSel[ 3].d	= CommandRAM_cs;
DevSel[ 4].d	= Link_cs ;             -- Link's I/O port or InData_out
FOR i IN 0 TO (NUM_CH-1) GENERATE
	DevSel[5+i].d  = TA6Channel_cs[i]; -- ADC channel data
END GENERATE;
DevSel[11].d	= SelCommdList_cs;--GateDur_cs ;          -- Reg_OpCode
DevSel[12].d	= GND;--GateDel_cs ;          -- Reg_OpCode
DevSel[13].d	= OpCode_cs ;           -- Reg_OpCode
DevSel[14].d	= BaseAddr_cs ;         -- Reg_BaseAddr
DevSel[15].d	= ZERO_cs ;             -- ZERO word
FOR i IN 0 TO (NUM_CH-1) GENERATE
	DevSel[16+2*i].d	= DDREqu_cs[i];
	DevSel[17+2*i].d	= DDRNEqu_cs[i] ;             -- ZERO word
END GENERATE;

DevSel[28].d	= ErrorCounters_IFace_CS ; -- Error Counters
DevSel[29].d	= TestRAM_cs; --

FOR i in 1 to 29 % with ErCount must be 28 % GENERATE
	DevSel[i].clrn = AddrSettled;-- DevSel[] are enabled while Addr. is settled
	DevSel[i].clk  = Clk100;
END GENERATE; 

-- Multiplexer of Data Bus sources (Enables Data drivers )
IF (RW == VCC) Then		-- Master will write to
	DataBus[] = CPU.DataOut[] ;
Else					-- Master will read from
	CASE DevSel[].q IS     -- Data_Line MUX for Target drivers
		--WHEN  b"1000000000" => DataBus[] = something.q[]
		WHEN  b"00000000000000000000000000001" => DataBus[]			= MainRAM.q[];
		WHEN  b"00000000000000000000000000010" => DataBus[]			= CPU.ProgRAM_q[];
		WHEN  b"00000000000000000000000000100" => DataBus[]			= CommandRAM.q[];
		WHEN  b"00000000000000000000000001000" => CASE  AddrBus[1..0] is
			When  0 => DataBus[]= Link_IFace.InData_out[];
			When  1 => DataBus[]= Link_IFace.DataBus_out[];
			--When  2 => DataBus[7..0]= Link_IFace.OpCode_out[];
		End CASE;
		WHEN  b"00000000000000000000000010000" => DataBus[]			= TA6Channel[0].DataBusOut[] ;
		WHEN  b"00000000000000000000000100000" => DataBus[]			= TA6Channel[1].DataBusOut[] ;
		WHEN  b"00000000000000000000001000000" => DataBus[]			= TA6Channel[2].DataBusOut[] ;
		WHEN  b"00000000000000000000010000000" => DataBus[]			= TA6Channel[3].DataBusOut[] ;
		WHEN  b"00000000000000000000100000000" => DataBus[]			= TA6Channel[4].DataBusOut[] ;
		WHEN  b"00000000000000000001000000000" => DataBus[]			= TA6Channel[5].DataBusOut[] ;
		WHEN  b"00000000000000000010000000000" => DataBus[]			= SelCommdList_Reg.q[];--GateDur_reg.q[9..0];
		WHEN  b"00000000000000000100000000000" => DataBus[7..0]		= 0;--GateDel_reg.q[7..0];
		WHEN  b"00000000000000001000000000000" => DataBus[7..0]		= Reg_OpCode.q[7..0];
		WHEN  b"00000000000000010000000000000" => DataBus[7..0]		= Reg_BaseAddr.q[7..0];
		WHEN  b"00000000000000100000000000000" => DataBus[]			= 0 ;
		WHEN  b"00000000000001000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[0].q[];
		WHEN  b"00000000000010000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[0].q[];
		WHEN  b"00000000000100000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[1].q[];
		WHEN  b"00000000001000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[1].q[];
		WHEN  b"00000000010000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[2].q[];
		WHEN  b"00000000100000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[2].q[];
		WHEN  b"00000001000000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[3].q[];
		WHEN  b"00000010000000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[3].q[];
		WHEN  b"00000100000000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[4].q[];
		WHEN  b"00001000000000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[4].q[];
		WHEN  b"00010000000000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[5].q[];
		WHEN  b"00100000000000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[5].q[];
		WHEN  b"01000000000000000000000000000" => DataBus[8..0]		= ErrorCounters_IFace.DataBusOut[8..0];
		WHEN  b"10000000000000000000000000000" => DataBus[]			= 0;--TestRAM.q[]; --AddrMux[]  = 2;
		WHEN OTHERS => DataBus[] = 0;
	End CASE;
End IF;

--============================================================================
-- 10. Testing circuitry ******************************************************
%TestCt.(clock, clk_en)  = (FQuartz, VCC); -- Test Counter, can be used to drive LED blinking
--TestCt.(clock, clk_en)  = (LinkClk, VCC); -- Test Counter, can be used to drive LED blinking
TestCt.cnt_en           = VCC;
TestCt.aclr             = PowerUp0 & !TestCt_rst2;  --\Reset for making proper PwrUp timing diagram
    TestCt_rst1 = DFF(.D=PowerUp0,   .clk= FQuartz);-- > _/^^\_ ,
    TestCt_rst2 = DFF(.D=TestCt_rst1,.clk=!FQuartz);--/   duration >=(1/2)Tquartz
%
TestCt.(clock, clk_en)	= (FQuartz, VCC); -- Test Counter, can be used to drive LED blinking
TestCt.cnt_en			= PowerUp0;
TestCt.aclr				= !PowerUp0;    -- even if NO clock - Reset does occur
%
TestRAM.(address[7..0], data[],    clock,    wren                     ) =
        (AddrBus[7..0], DataBus[], Clk100,(DataStrobe & DevSel[32] & RW)); 
%
Test1	= Link_IFace.LinkMessage;--PhaseSw.LinkClk_selected; --DDRin.dataout_h[0];			--Link_IFace.LinkMessage;		-- pin 68
Test2	= LinkMsg_beg;--!Phase12;                    --Link_IFace.IORq;	-- pin 73
Test3	= PLL.locked;--DDRenNequ1;                   --Start_Link.q;			-- pin 76
Test4	= SelCommdList_Trig.q;--PowerUp0;--StartProc_Link;           	--StartADC_Link;		-- pin 80

--IF((AddrBus[12] == VCC) and (AddrBus[9] == VCC) ) Then Test5 = VCC; Else Test5 = GND; End IF;
Test5   = TestLinkCt.q[18];--SelCommdList_Trig3.q;--DDRenEqu2;                    --CPU.test4;            --DDRenEqu2;            -- pin 81
Test6	= TA6Channel[3].test5;--TestCt.q[5];--PowerUp1;--CPU.AccessReq;                --CPU.AccessReq;        --DDRenNEqu2;           -- pin 137
Test7	= TA6Channel[3].test1;--!Link_IFace.LinkMessage;					--AddrSettled;			--Digitizer1.Test3;		-- pin 139
Test8	= TA6Channel[3].test1;				--DevSel[6] # DevSel[7];--Digitizer1.Test2;		-- pin 146
Test9	= TA6Channel[3].test2;				--DataStrobe;			--Digitizer1.Test1;		-- pin 147
Test10	= TA6Channel[3].test3;			--DataBus[0];			--Digitizer1.Working;	-- pin 148

END;