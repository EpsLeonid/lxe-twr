TITLE  "Processor" ;    -- Multifunctional Processor Unit

******************************************************************************
<<<<_____ PROCESSOR module - A  LOOK  INSIDE ____>>>              ---┐   -T-        
                                                                  │  │ +--+--+ 
SEE  FUNCTIONAL  SCHEMATIC !                               L---   -+-  
==============================================================================

VERSION: 4   - is under development !!
------------        ВременнЫе диаграммы составлены для проектируемой версии !!

ПРОЦЕССОР
----------
    ПРОЦЕССОР включает в себя : 
- ОЗУ ProgRAM, в котором записаны программы
- основной счетчик адреса ProgCt
- счетчик проходов по циклу PassCt
- Таблицу LUT_ProgCtrl, вырабатывающую сигналы управления Микропрогр.автоматом 
- "Регистр" из триггеров, названных именами сигналов - для фиксации сигналов 
  управления основными узлами Процессора
- локальную шину данных, с мультиплексором на входе - мультиплексор позволяет 
  выбрать источник данных

    Процессор обеспечивает загрузку 8-битных и 16-битных констант из собствен-
ного ОЗУ программ, чтение и запись 16-битных данных из/в объекты, доступные в 
адресном пространстве основного проекта, и простые действия с данными (пока 
только инкрементация, но хочется ещё и сложение).  СИСТЕМА КОМАНД Процессора 
включает в себя собственно команды работы с данными и команды управления вы-
полнением программы (в том числе команды условного и безусловного перехода, 
команду цикла, команду ожидания). 
    Список команд Процессора и значения битов программных слов приведены в 
нижеследующей Таблице: 
--============================================================================
--************ Command Word bits' meaning: ***********************************
--     [ 16 15 14 13|12 11 10  9  8  7  6  5  4  3  2  1 ]
-- Halt   0  0  0  0|                                   |
-- NOP    0  0  0  1|                                   |
-- Incr   0  0  1  0| Destn  |                          |
-- Decr   0  0  1  1| Destn  |                          |
--JumpUnc 0  1  0  0|           | Address of Program    |Jump_Unconditional
--JumpCnd 0  1  0  1| Condition | Address of Program    |Jump_Conditional
--EndLoop 0  1  1  0|           | Address of Program    |End_of_Loop
-- Wait   0  1  1  1| Condition |                       |
-- Load   1  0  0  0| Destn  |  | 8-bit word to load    |Load 8-bit word from ProgRAM
-- Load16 1  0  0  1| Destn  |                          |Load 16-bit word from ProgRAM
---- Move   0  1  1  0| Destn  | Source |                 |
-- Read   1  1  0  0|Data_Dst|Addr_Src|                 |Read from Extern.Object
-- Write  1  1  0  1|Data_Src|Addr_Src|                 |Write to Extern.Object
-- END    1  1  1  1|                                   |End_of_Prog 
==============================================================================
Видно, что 4 старших бита программного слова составляют Код_Операции, а зна-
чение остальных битов зависит от смысла Операции. 

    Запуск программы производится следующим образом.  Сразу после поступления
сигнала ProgInit (по фронту 1-го Клока) с-л ProgStart становится =1, и стоит 
в сост-и "1" до момента, когда триггер ProgInit1 установится в "1" (за 1Клок 
до фронта 25МГц-Клока).  Когда ProgInit1=1, на входы данных счетчика ProgCt 
подается НАЧАЛЬНЫЙ адрес запускаемой программы.  Через 1Клок после того, как 
ProgInit1 стал =1, триггер ProgInit2 тоже переключается в "1", и находится 
в сост-и "1" в течение 1/2Клока.  Импульсом ProgInit2 производится асинхронная 
загрузка начального адреса.  После этого управление работой Процессора произ-
водится согласно программным словам, вычитываемым из ОЗУ; таким образом, на-
чинается выполнение программы.

 Взаимодействие функциональных узлов при выполнении Операций
-------------------------------------------------------------
    ProgCt перещелкивается именно по тому _/ 100МГц-Клока, который совпадает 
с _/ или \_ 25МГц-Клока.  Момент перещелкивания ProgCt будем считать НАЧАЛОМ 
выполнения Операции.  Новый адрес защелкивается в регистр адреса ProgRAM по \_ 
(через 5нс после Начала Оп-ции), а выходные данные защелкиваются в выходном 
регистре ProgRAM по следующему _/ (через 20нс после Начала Оп-ции).  По этому 
же фронту ProgCt перещёлкивается ещё раз => Оп-ция, записанная по адресу #aa, 
НЕ УСПЕЕТ изменить режимы ProgCt до того, как он перещёлкнется на адрес #aa+1
(например, перевести ProgCt в "Load" для выполнения команд перехода).  Поэтому 
для реализации команд перехода, а также других команд, выполнение которых 
длится дольше 2Tclk=20ns, применён специальный механизм фиксирования Кода_Опе-
рации (выполняемой в данный момент) на произвольное время;  этот же механизм 
используется при выполнении команды "Load16", во время которой по смыслу опе-
рации необходимо вычитать из ОЗУ следующее (за программным словом) слово. 
    Фиксирование Кода_Операции производится следующим образом. Четыре старших 
бита ProgRAM.q[15..12] (Код_Операции) поступают на Таблицу LUT_ProgCtrl, выра-
батывающую сигналы управления Микропрограммным Автоматом, через лэтчи.  Это 
обеспечивает возможность зафиксировать Код_Оп-ции, и в то же время получается 
минимальная задержка прохождения сигналов от выходного регистра ОЗУ до Таблицы. 
    На рисунке приведены хронограммы сигналов, происходящих при обработке 
начальных команд программы.  Первая команда "Load" выполняется за 2Tclk => при 
её выполнении сигнал OpCode_lock не вырабатывается.  Вторая команда выполня-
ется за 4Tclk, поэтому при её выполнении вырабатывается OpCode_lock => триггер 
OpCode_en переключается (при t=12) в =0 => на выходах лэтчей OpCode[16..13] 
зафиксирован OpCode02, и будет стоять там до t=14+.  Поэтому, несмотря на то, 
что ProgCt успел перещёлкнуться (t=10) в =03, и на выходах ОЗУ уже при t=14 
появится OpCode03, Оп-ция "OpCode02" спокойно выполняется до появления сигнала 
LastStage (последняя стадия операции).  Во время этой Оп-ции (хотя и после 
перещёлкивания в =03) счёт в ProgCt, ессессно, притормаживается. 
--============================================================================
--************ Control Sequence Generation ***********************************
    Time--------0---1---2---3---4---5---6---7---8---9--10--11--12--13--14--15--16--17--18--
 25MHz Clock  __________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^\__
100MHz Clock  __/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\__
  ProgCt_Cen  ___/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^
  ProgCt.q[]  ___________X=======01======X=======02======X=======03======================X====04=======
ProgRAM's addr_reg ______________X=======01======X=======02======X=======03======================X==04=
ProgRAM.q[]   ___________________________X=OpCode01:Load=X====OpCode02==X====OpCode03===============
 OpCode_lock  _______________________________________________//^^^^^^^^^^^^^^\\______________//^^^^^^
   OpCode_en  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_______________??______/^^^^^^^\_________
 OpCode[16..13] ___________________________/=OpCode01:Load=X=====OpCode02==================X==OpCode03=
  LastStage   ___________________________________________________________/^^^^^^^^^^^^^^^\_________________


 Команды  NOP,  INCR, LOAD
---------------------------
    Выполнение простых команд ("NOP", "Incr", "Load") производится следующим 
образом.  Пусть по фронту "0" (фронт, подстробированный триггером ClkTrig0) 
на выходах счётчика ProgCt установился адрес, по которому записана команда 
("Load" Ddst #nnnnnnnn ).  Слово этой команды появится на выходах выходного 
регистра ОЗУ после фронта t=4.  

      Time--------------0---1---2---3---4---5---6---7---8---9--10--11--12--13--14-
 25MHz Clock  __________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^
100MHz Clock  __/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\__
ProgCt_count  ___/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_____
ProgCt_load   _________________________________________________________________
  ProgCt.q[]  ___________X==Addr_of_Load=X==Addr_of_NOP==X===nextAddr====X=====
ProgRAM.q[]   ___________________________X=====Load======X=====NOP=======X=====

  Data_Src[]  ___________________________/==Dsrc=========\_____________________
DataMUX_addr  ___________________________________X=============================
 for selected Ddst: Reg*_load____________________/^^^^^^^\_____________
Data at the Ddst        ==========previous_data==========X==new_data====

Для выполнения команды Load не требуется задерживать счёт ProgCt или фикси-
ровать Код_Оп-ции, поэтому сигнал ProgCt_count остаётся =1, а OpCode_lock 
остаётся =0; Код_Оп-ции в любом случае сменится не ранее фронта t=7.  Соот-
ветственно смыслу команды "Load" данные должны быть взяты из 8-ми младших 
бит этого же командного слова, поэтому с помощью жёстко заданной логики 
при опознании команды "Load" ( OpCode[15..12]=B"1000 ) вырабатывается адрес 
"источника_данных"  Data_Src[3..1]=B"110", по которому мультиплексор шины 
данных подключит её к выходам ProgRAM.q[7..0].  Адрес "приёмника_данных" 
содержится в (12-м..10-м) битах Кода_Оп-ции ( OpCode[11..9]=Ddst ); по этим 
битам с помощью жёстко заданной логики вырабатывается сигнал загрузки для 
cоответствующего регистра (Rg1_ld..Rg4_ld, PassCt_load).  По фронту t=4 ад-
рес Data_Src[] защелкивается в триггеры DataMUX_addr[] и поступает на ад-
ресные входы мультиплексора шины данных; таким образом, шина данных подклю-
чается к ProgRAM.q[7..0].  И после этого по фронту "0" данные защёлкиваются 
в выбранный "приёмник_данных" (для которого установлен сигнал загрузки). 


 Команда  LOAD16
-----------------
  При выполнении команды Load16 нужно вЫчитать из ОЗУ следующее за Кодом_Опе-
рации слово; если пытаться выполнить эту команду за 2 такта, как обычную, 
то для вычитывания доп.слова нужно "ускорять" чтение, так, чтобы уже во 2-й 
половине Операции "Load16" на выходах ProgRAM появлялось слово Datа, относя-
щееся к выполняемой Операции, а в момент начала следующей Операции на выходах 
ProgRAM должен появиться следующий OpCode.  Для этого нужно при выполнении 
"Load16" давать дополнительный импульс ProgCt_count (либо, наоборот, убирать 
один импульс ProgCt_count при обычных командах и =не_убирать= его при Load16).  
  Я занимался разборками с командой Load16, находясь в Lecce.  Потратив 
полтора полных дня (без отвлечений!) на эти разборки, я выяснил следующее.  
Задержка между моментом, когда адрес некоторой конкретной команды появится 
на ProgCt.q[], и моментом, когда (после появления этой команды на выходах 
ProgRAM.q[]) по Коду_Оп-ции этой команды будет выработан управляющий сигнал, 
составляет 3 такта.  Если по Коду_Оп-ции управлять только режимом ProgCt, то 
управление слишком запаздывает; обеспечить чтение доп.слова можно только при 
наличии буфера (в который оно было всосано из ProgRAM ещё раньше!).  А из-за 
запаздывания "ускоряющего" или "тормозящего" воздействия количество слов в 
буфере будет меняться, поэтому буфер должен быть FIFO (!!).
Короче, это =реализуемо=, но =очень= громоздко.  Однако, на следующее утро,
когда я ещё лежал в кровати, меня осенило: а ведь можно управлять не только 
режимом ProgCt, но и защёлкиванием адресного регистра ProgRAM !!  Тогда всё 
получается просто и красиво ! 

    Для понимания общей ситуации, рассмотрим работу схемы от момента ЗАГРУЗКИ 
счётчика ProgCt (загрузка в начале программы или при переходе к началу Цикла).
Для понимания достаточно рассмотреть выполнение двух "простых" команд и 
команды Load16. 

      Time--------------0---1---2---3---4---5---6---7---8---9--10--11--12--13--14--15--16--17--18--
 25MHz Clock  __________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^
100MHz Clock  __/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\__
ProgCt_load   ___/^^^^^^^\_____________________________________________________________________
ProgCt_count  ___________/^^^^^^^^^^^^^^^^^^^\\______//^^^^^^\\______//^^^^^^^^^^^^^^^^^^^^^^??   depends on A+4:OpCode
  ProgCt.q[]  ___________X===A===X==A+1==X====A+2========X====A+3========X==A+4==X==A+5==X==A+6== depends on A+4:OpCode
ProgRAM.enable_a ________/^^^^^^^^^^^^^^^^^^^\\______//^^^^^^\\______//^^^^^^^^^^^^^^^^^^^^^^??   depends on A+4:OpCode
ProgRAM's_AddrReg _______________X===A===X======A+1======X======A+2======X==A+3==X==A+4==X==A+5== depends on A+4:OpCode
ProgRAM.q[]   ___________________________X=====A:NOP=====X===A+1:Load====X==Ld16=X==Data=X==A+4:OpCode
 OpCode[16..13] __________________________X=====A:NOP=====X===A+1:Load====X===A+2:Load16==X==A+4:OpCode

  Delay       _______________________________//^^^^^^\\______//^^^^^^\\______//^^^^^^\\______?? depends on A+4:OpCode
  LastStage   ___________________________________/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\___?? depends on A+4:OpCode

Data_Src[]    _______________________________________________//==Dsrc=======X==Dsrc==========?? depends on A+4:OpCode
DataMUX_addr  ___________________________________________________X===============X=============
 for selected Ddst: Reg*_load____________________________________/^^^^^^^\_______/^^^^^^^\_____
Data at the Ddst'input  ==========????=========______________________X=Data=XX_______X=Data=XX_

    Пусть по фронту "0" (фронт, подстробированный триггером ClkTrig0) в счёт-
чик ProgCt загрузился адрес =#A;  после этого управляющая логика переключает 
ProgCt в режим счёта.  При t=4+  ProgCt=#(A+2), в адресном регистре ProgRAM 
защёлкнуто #(A+1), а на выходах PrpgRAM появилась команда "NOP".  Сразу же 
по появлению этого OpCode логика останавливает счёт в ProgCt и дисэйблирует 
защёлкивание адресного и выходного регистров ProgRAM.  Таким образом, до 
окончания текущей Оперции (до t=8) сохранятся состояния  ProgCt=#(A+2), 
ProgRAM's_AddrReg=#(A+1), ProgRAM.q[]= @#A ="NOP".  
    Выполнение второй Оп-ции происходит аналогично.  
    В начале выполнения третьей Оп-ции ("Load16") (при t=12+), на выходах 
ProgRAM.q[] стоит команда ("Load16",Ddst, ...), в ProgRAM's_AddrReg защёлк-
нут адрес следующего слова (для данной команды это её слово Data), а в 
ProgCt стоит адрес после-следующего слова, то есть, следующей команды. 
Увидев команду "Load16", логика =не останавливает= счёт в ProgCt и защёл-
кивание адресного и выходного регистров ProgRAM, поэтому по фронту "14" 
на ProgRAM.q[] появляется слово Data, относящееся к выполняемой команде, 
в ProgRAM's_AddrReg защёлкивается #(A+3), а ProgCt становится =#(A+4).
В конце Операции "Load16" (по фронту "16") слово Data защёлкивается в 
соответствующий Регистр. 
    Обратим внимание, что во второй половине любой (простой или "Load16") 
Операции в ProgRAM's_AddrReg уже защёлкнут адрес следующей команды, а 
в ProgCt защёлкнут адрес слова, следующего за следующей командой.  Таким 
образом после любой Операции схема единообразно подготовлена к выполнению 
следующей Операции. 


 Выполнение  ЦИКЛОВ
--------------------
    Выполнение программных циклов организуется следующим образом.  Перед 
началом цикла (в слове, предшествующем первому слову цикла, или немного 
раньше) должна быть записана команда ("Load",Ddst=PassCt,#nnnnnnnn), 
где "nnnnnnnn"=(требуемое_число_циклов).  По этой команде число "nnnnnnnn" 
записывается в PassCt.  После загрузки PassCt Процессор, последовательно 
выполняя дальнейшие команды, входит в область цикла, проходит по циклу 
первый раз и доходит до последней команды цикла.  В последнем слове цикла 
должна быть записана команда ("EndLoop",..,#aaaaaaaa), где "aaaaaaaa" - 
адрес первой команды цикла. 
По команде "EndLoop": 
-   если содержимое PassCt > 1, то: 1) в основной счетчик адреса ProgCt 
  загружается число "aaaaaaaa" => следующей будет выполняться команда, 
  являющаяся первой в цикле, 2) счетчик циклов PassCt декрементируется.
-   если содержимое PassCt = 1 (во время последнего прохода), то: 
  1) ProgCt инкрементируется => Процессор выходит из цикла и начинает 
  выполнять дальнейшую программу, 2) PassCt так же декрементируется (чтобы 
  выход PassCt.eq1 стал =0 и не держал сигнал Condition в =1). 

  Рассмотрены два варианта реализации управляющей схемы :  1) подобный тому, 
который реализован в Processor_v2, и 2) "продвинутый", он описан после 
"варианта 1". 

ВАРИАНТ  1.
------------
--******** Control Sequence при не_последнем проходе Цикла ********
      Time--------------0---1---2---3---4---5---6---7---8---9--10--11--12--13--14--15--16--17--18--
 25MHz Clock  __________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^
100MHz Clock  __/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^
ProgCt_count  ___/^^^^^^^\_______/^^^^^^^\___________//^^\_______/^^^^^^^\___???? depends on OpC_BoLoop
ProgCt_load   _______________________________//^^^^^^\\_______________________________________
ProgCt.q[]    ==A-1======X======A========X==A+1==X=BegL==X===BegLoop+1===X===BegLoop+2===X====
ProgRAM's addr_reg =====A-1======X=======A=======X==A+1==X=BegL==X===BegLoop+1===X==BegLoop+2=
ProgRAM.q[]   ==????=====X====A-1:Incr===X===A:EndLoop===X=A+1:?=X=B:OpC=X==BegLoop+1:??=X====
ProgReg.q[]   ==????=====X=====????======X======Incr=====X====EndLoop====X==BegLoop:OpC==X====
PassCt_Cen    ___/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\____
PassCt_count  _______________________________________________//^^^^^^^^^^^^^^\\_______________
PassCt_load   ______________________________________________________________________________________________
  Delay       _______________________________//^^^^^^\\______________________???? depends on OpC_BoLoop
  LastStage   ___________________________________/^^^^^^^\___________________???? depends on OpC_BoLoop

  Логическая схема, которая формирует сигналы, управляющие ProgCt, PassCt (и, 
может быть, ProgReg) должна учитывать состояние 11-ти сигналов:  
ProgRAM.q[15..12], ProgReg.q[15..12], PassCt.eq1, Condition, и LastStage. 
[ Может быть, PassCt.eq1 останется "объединённым" с Condition; может быть, опти-
[ мально будет сделать отдельную логику для управления ProgCt, и отдельную логику 
[ для управления PassCt (и, если нужно, ProgReg). 

**При не_последнем проходе Цикла:
  Когда на выходах ProgRAM.q[15..12] появляется OpCode="EndLoop" (t=8+), логика 
переключает ProgCt в режим "load" и вырабатывает дополнительный ProgCt_Cen, 
так чтобы при t=10 ProgCt загрузил в себя адрес первой команды Цикла.  После 
этого логика снова переключает ProgCt в режим "count".  По следующему _/ клока 
(t=12) адрес 1-й команды цикла (Addr = BegOfLoop) защёлкнется в регистр адреса 
ProgRAM, а ProgCt инкрементируется в состояние ProgCt=(BegOfLoop+1).  Таким 
образом обеспечивается, что на выходах ProgReg нормально в течение 2 тактов 
присутствует OpCode="EndLoop" (t=[12+...16+]),а потом сразу появляется OpCode 
первой команды Цикла и стоит тоже нормально, в течение 2 (или сколько нужно) 
тактов. 
**При последнем проходе Цикла:
  Всё ваще просто.  Ничего не надо дополнительно поддёргивать.  Когда на 
выходах ProgRAM.q[15..12] появляется OpCode="EndLoop" (t=8+),  ProgCt уже 
перещёлкнулся на адрес 1-й_после_Цикла команды.  Поэтому на выходах ProgReg 
нормально в течение 2 тактов присутствует OpCode="EndLoop" (t=[12+...16+]), 
а потом сразу появляется OpCode 1-й_после_Цикла команды и стоит тоже нор-
мально, в течение 2 (или сколько нужно) тактов.

ВАРИАНТ  2.
------------
  Возможен "продвинутый" вариант, при котором обеспечивается, что OpCode 
1-й_после_Цикла команды появляется =на выходах ProgRAM= сразу же после того, 
как на выходах ProgRAM отстоял положенных 2 такта OpCode="EndLoop".  Для 
этого необходимо включить на адресных входах ProgRAM "мультиплексор 2->1", 
одно направление мультиплексора подключено, ессессно, к ProgCt.q[], а второе - 
к ProgRAM.q[7..0].  

--******** Control Sequence при не_последнем проходе Цикла ********
      Time--------------0---1---2---3---4---5---6---7---8---9--10--11--12--13--14--15--16--17--18--
 25MHz Clock  __________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^
100MHz Clock  __/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^
ProgCt_load   _______________________________//^^^^^^\\_____________________________________ 
ProgCt_count  ___/^^^^^^^\_______/^^^^^^^\___________//^^\_______/^^^^^^^\_______/^^^^^^^\__
ProgCt.q[]    =A-1=======X======A========X==A+1==X=BegL==X===BegLoop+1===X===BegLoop+2===X==
ProgRAM's addr_reg =====A-1======X======A========X==BegL=X=BegL==X===BegLoop+1===X==BegLoop+2
ProgRAM.q[]   ==????=====X====A-1:Incr===X===A:EndLoop===X===BegL:NOP====X=BegLoop+1:??==X==
PassCt_Cen    ___/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\__
PassCt_count  _______________________________//^^^^^^^^^^^^^^\\_____________________________
PassCt_load   ______________________________________________________________________________
  Delay       _______________________________//^^^^^^\\______________________???? depends on OpC_BoLoop
  LastStage   ___________________________________/^^^^^^^\__________________________________

**При не_последнем проходе Цикла:
Когда на выходах ProgRAM.q[15..12] появляется "EndLoop", логика сразу же 
переключает мультиплексор адреса на выходы ProgRAM.q[7..0], а также 
переключает ProgCt в режим "load".  Тогда при t=10 адрес 1-й команды цикла 
(Addr = BegOfLoop) защёлкнется в ProgCt (как и положено по команде EndLoop), 
а также (во кайф!) этот же адрес защёлкнется сразу же в адресный регистр 
ProgRAM.  После этого, во второй половине Операции "EndLoop" (когда 
LastStage=1), мультиплексор адреса переключается на нормальное направление 
(к выходам ProgCt), а управление режимом ProgCt оставляется равным 
DFF(.D=(ClkTrig2 #ClkTrig6), .clk=clock).  Тогда при t=12 на выходах 
ProgRAM.q[15..12] появится OpCode 1-й команды цикла, а ProgCt инкрементируется 
на следующий адрес (Addr = BegOfLoop+1). 
**При последнем проходе Цикла:
  Всё ваще просто.  Ничего не надо дополнительно поддёргивать.  Когда на 
выходах ProgRAM.q[15..12] появляется OpCode="EndLoop" (t=8+),  ProgCt уже 
перещёлкнулся на адрес 1-й_после_Цикла команды.  Поэтому на выходах ProgReg 
нормально в течение 2 тактов присутствует OpCode="EndLoop" (t=[12+...16+]), 
а потом сразу появляется OpCode 1-й_после_Цикла команды и стоит тоже нор-
мально, в течение 2 (или сколько нужно) тактов.

    
 Завершение программы - Команда  EndProg
-----------------------------------------
    В конце программы, который обозначается командой End_of_Prog 
(R_ROM_q[16..13]=B"1111"), счетчик ProgCt устанавливается в сост-е #255. 
В 255-й ячейке ПЗУ записана команда "Halt", по которой сигнал ProgCt_count 
обнуляется, и микропрограммный автомат остается в этом состоянии.  


