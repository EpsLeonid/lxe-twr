TITLE "Basic Trigger";

INCLUDE "lpm_shiftreg.inc";
INCLUDE "Delay_Line.inc";


PARAMETERS
(
	NUM_CH     = 8
);

SUBDESIGN Basic_Trig
(
  DataIn[NUM_CH-1..0]       	  : input; 
  Sample_Enable             	  : input;  -- частота принятия решений 
  Clock                			  : input;  -- входная частота 

  Result                          : output; -- решение триггера

--
  DataBus_In[15..0]			      : input;  -- полученные с шины проекта данные
  DataBusOut[15..0]     	  	  : output; -- отправляемые  на шину проекта данные
  
  DataBusStrobe 			 	  : input;  -- строб приема/передачи данных наружу (высокий уровень, защелкиваем по заднему фронту)
  Select					 	  : input;  -- Выбор Модуля для работы с памятью Командного Листа в режиме Slave (с КАМАК-ом)
  DirectIn					  	  : input;  -- направление передачи данных, Если =GND, то данный Модуль читается, если =VCC, то пишется.
  AddrBus_In[8..0]			 	  : input;  -- адрес при операциях доступа чтения/записи Командного Листа с КАМАК-а


)

VARIABLE

  Data_Reg                     : lpm_shiftreg with (LPM_WIDTH = NUM_CH, LPM_DIRECTION="unused"); -- регистр данных
  OR_SHEME[NUM_CH..0]          : node; -- ИЛИ всех входов
  AND_MASK_CH[NUM_CH-1..0]     : node; -- маскирование каналов для схемы И
  AND_SHEME[NUM_CH..0]         : node; -- И всех входов
  MASK_CH[NUM_CH-1..0]         : node; -- маскирование каналов, какие входы учавствуют в схеме совпадения
  SHEME_MASK[1..0]             : node; -- маскирование схем совпадения, для выбора результирующей схемы
  Result_Out                   : node; -- выход результата
  Pulse_Shaper                 : Delay_Line with (SHAPING_TIME = 16);

  Mask_Reg                     : lpm_shiftreg with (LPM_WIDTH = NUM_CH+1, LPM_DIRECTION="unused"); -- регистр данных
  SaveMaskReg                  : node;

BEGIN

-- защелкиваем входные данные
Data_Reg.data[NUM_CH-1..0] = DataIn[NUM_CH-1..0];
Data_Reg.clock             = Clock;   -- по такту защелкиваем состояние входов
Data_Reg.load              = VCC;     -- регистр всегда в параллельной загрузке
Data_Reg.enable            = Sample_Enable;  -- разрешаем защелкнуть состояние 
-- поиск совпадений по ИЛИ всех входов
FOR i in 0 to (NUM_CH-1) GENERATE
  MASK_CH[i]  = Mask_Reg.q[i] AND Data_Reg.q[i];
    OR_SHEME[i+1]  = OR_SHEME[i] OR MASK_CH[i]; 
       AND_MASK_CH[i] = !Mask_Reg.q[i] OR MASK_CH[i];
         AND_SHEME[i+1]  = AND_SHEME[i] AND AND_MASK_CH[i];
           END GENERATE;
             OR_SHEME[0] = GND;
                AND_SHEME[0] = VCC;
                  SHEME_MASK[0] = OR_SHEME[NUM_CH] AND !Mask_Reg.q[NUM_CH]; -- 9-й бит в регистре маски управляет выбором схемы совпадения (GND-схема ИЛИ, VCC-схема И)
                    SHEME_MASK[1] = AND_SHEME[NUM_CH] AND Mask_Reg.q[NUM_CH];
                      Result_Out = SHEME_MASK[0] OR SHEME_MASK[1];   

-- поиск совпадений по И всех входов

Pulse_Shaper.(Clock, DelayTime[], DurationTime[]) = (Clock, b"0000" , b"1110");
Pulse_Shaper.InputPulse = Result_Out;
Result = Pulse_Shaper.DelayedPulse;


Mask_Reg.(data[], clock, enable, load) = (DataBus_In[NUM_CH..0], Clock, SaveMaskReg , VCC);
-- 0 адрес регистра маски каналов 
IF(AddrBus_In[] == 0)  THEN SaveMaskReg              = DataBusStrobe and  DirectIn AND Select;
                            DataBusOut[NUM_CH..0]    = Mask_Reg.q[]; 
                            DataBusOut[15..NUM_CH+1] = GND;
                       ELSE SaveMaskReg              = GND;
END IF;

END; -- End design