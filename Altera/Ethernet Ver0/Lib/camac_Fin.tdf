TITLE "CAMAC_150209" ;
-- Файл содержит описание работы модуля, связывающего шину крейта КАМАК 
-- с внутренней шиной проектов триггера КМД 3. 
-- Козырев, Рубан.
%
Так как Шина КАМАК является синхронной шиной и довольно-таки медленной, необходимо согласование
по времени. Так как небольшая, всего 4-х битная шина субадреса не позволяет произвести 
прозрачный доступ к ресурсам наших проектов, требуется другой способ адресного доступа.
 
Данный модуль предназначен для установления стандарта "де-факто" на способы доступа к ресурсам
 проектов, разрабатываемых под TRIGGER&DAQ детектора КМД-3 ИЯФ СО РАН. Данный Модуль устанавливает
 и описывает правила доступа КАМАК-командами NAF к внутренним ресурсам проектов, включающим:
1. адресуемое пространство памяти, 
2. адресуемое пространство регистров, статусные биты и 
3. асинхронные запуски. 
Используя данный модуль в проектах, предполагается достичь единообразия стиля и свободы
распределения ресурсов, что, в свою  очередь, должно облегчить написание тестового и 
пользовательского программного обеспечения.

Предлагается принять за "стандарт" следующее распределение команд/данных

Основные команды (КАМАК - функции)
F[0]A[0..15] - чтение данных из пространства регистров самого КАМАК-интерфейса (Модуля)
(номер регистра указывается в субадресе), в т.ч. регистра статуса, дескриптора, 
промежуточных регистров, сообщающихся с шиной пользователя (назначеие субадресов см ниже).
F[1]A[0..1] - чтение из адресуемого пространства проекта пользователя, из ячейки, адрес которой 
был ранее прописан в регистре адреса Модуля. Субадрес определяет, из пространства регистров (А=0)
 или пространства памяти (А=1) идет чтение
F[2]A[0..1] - чтение из адресуемого пространства проекта пользователя, с автоинкриментом регистра адреса

F[16]A[0..15] - запись данных в регистры (номер регистра указывается в субадресе)самого КАМАК-интерфейса (Модуля)
F[17]A[0..1] - запись памяти, в ячейку, адрес которой был ранее прописан в регистре адреса
F[18]A[0..1] - запись в адресуемое пространство проекта пользователя, с автоинкриментом регистра адреса
...
F[8] - проверка LAM по Q
F[24] - блокировка LAM
F[26] - разблокировка LAM

F[25] - команда "Пуск". Так как в "Пуске" могут нуждаться несколько устройств, напр. оцифровка, прописывание
порогов, линк и т.д., предлагается для определения устройства использовать содержимое регистра адреса. 
Т.е. перед выполнением F25 следует загрузить в Регистр Адреса номер устройства, которое надо толкнуть.
Хотя, конечно, можно и просто по субадресу...
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Использование команды F25 в дальнейшем считается противоречащим духу проекта КМД-3 и НЕ ДОПУСКАЕТСЯ! 
Рекомендуется запуск осуществлять прописыванием 1 в младший разряд специального регистра, т.к. такой способ
обеспечивает: 
во-первых, единообразный стиль работы с любым Интерфейсом - от Линка до RS-232,
Во-вторых, простейшую схему сопряжения для пересечения границ доменов тактовых частот
в-третьих, прямую проверку команд изменения статуса
%

%
Распределение субадресов для регистровых операций (F0/F16) внутри Модуля
А0..А1 -- четырех байтный Регистр-Дескриптрор, содержит ASCII коды названия модуля и номера
версии прошивки (только чтение)
А2..А3 -- четырех байтный Регистр Статуса , содержит флаги текущих операций, состояний.
А4..А5 -- четырех байтный Регистр Адреса, используется для адресации доступа 
в области памяти/регистров проекта пользователя
А8     -- регистр промежуточного хранения данных, принятых от шины проекта пользователя и предназначенных
для передачи на КАМАК-шину "R", тестовая фича
A9     -- регистр промежуточного хранения данных, принятых от КАМАК-шины "W" и предназначенных
для передачи на шину пользователя, тестовая фича


Распределение битового пространства читаемой части Регистра Статуса
В[0] -- Флаг захвата входящей частоты Линка местным PLL
В[1] -- Флаг активности Линка
В[2] -- Флаг ошибки Линка 
B[3] -- Флаг текущей оцифровки
В[4] -- Флаг мертвого времени  
В[5] -- Флаг копирования порогов/коэффициентов
B[6] -- Ошибка по КАМАК-у
В[7] -- Флаг LAM
В[8] -- Флаг клапанирования LAM 
Остальные биты пользователь назначает по своему усмотрению
Распределение битового пространства загружаемой части Регистра Статуса
В[0] -- Разрешение захвата входящей частоты Линка местным PLL
В[1] -- Разрешение ответов в Линк
В[2] -- Сброс флага ошибки Линка 
B[3] -- Разрешить оцифровку по асинхронному старту 
В[4] -- Разрешить формирование мертвого времени  
В[5] -- --Флаг копирования порогов/коэффициентов
B[6] -- --Ошибка по КАМАК-у
В[7] -- --Флаг LAM
В[8] -- --Флаг клапанирования LAM 
%

%
 Общий смысл сопряжения интерфейсов таков, что по каждому обращению от КАМАКа 
модуль предпринимет следующие действия.
Передача от шины КАМАК в проект пользователя:
 1. Выдает запрос "Bus Access ReQuiest" на доступ к шине. (предний фронт привязан к тактам модуля), 
 2. После появления сигнала "Bus Access GranteD" предоставления доступа 
(т.к. доступ предоставляет арбитр шины пользователя, то сигнал привязан к тактам пользователя)
немедленно (асинхронно) выдает на шину адрес (куда хочет попасть), слово данных и устанавливает сигнал 
направления передачи.
		Арбитр шины дожидается, когда ответит (распознает свой адрес) хотя бы одно устройство, и генерирует 
		сигнал "DataStrobe". По этому сигналу данные записываются.
 3. Дождавшись строба, по его концу сбрасывает сигнал запроса немедленно (асинхронно).
Куда именно будет записано слово, определяет пользователь.

Передача из проекта пользователя на шину КАМАК :
 1. Выдает запрос "Bus Access ReQuiest" на доступ к шине. (предний фронт привязан к тактам модуля), 
 2. После появления сигнала "Bus Access GranteD" предоставления доступа 
(т.к. доступ предоставляет арбитр шины пользователя, то сигнал привязан к тактам пользователя)
немедленно (асинхронно) выдает на шину адрес (куда хочет попасть).
		Арбитр шины дожидается, когда ответит (распознает свой адрес) хотя бы одно устройство, и генерирует 
		сигнал "DataStrobe". 
 3. Дождавшись строба, по концу строба защелкивает данные в модуль и выдает их на шину R.
 Откуда именно будет предоставлено слово, определяет Пользователь.

От Пользователя требуется только обеспечить реакцию на запрос модуля,
не превышающую 200нс (без предварительной выборки)-7 мкс(с предварительной выборкой).
%



INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "lpm_counter.inc"  ;
INCLUDE "Edge_Sensing.inc" ;
INCLUDE "Level_Sensing.inc";

PARAMETERS
(
  RefClock=100  -- Пользователь здесь указывает частоту в МГц-ах (целых), которую он подал
-- на вход "Clock" 
);
ASSERT (RefClock>20 AND RefClock<126)
REPORT "You enter RefClock (%) which is not suitable for CAMAC function" RefClock
SEVERITY ERROR;
CONSTANT HALFCYCLE = FLOOR(RefClock div 2);
-------------------------------------------------------------------------------------------
-- Константы - параметры, определяемые Пользователем данного модуля
-------------------------------------------------------------------------------------------
CONSTANT DescriptorWord0 = H"3254"; -- код-дескриптор модуля T2Q_01
CONSTANT DescriptorWord1 = H"0551";

--CONSTANT DescriptorWord0 = H"FFFF"; -- Определяемый пользователем код-дескриптор модуля
--CONSTANT DescriptorWord1 = H"FFFF";

CONSTANT F0 = B"00000";
CONSTANT F1 = B"00001";
CONSTANT F2 = B"00010";

CONSTANT F16 = B"10000";
CONSTANT F17 = B"10001";
CONSTANT F18 = B"10010";

CONSTANT F8  = B"01000";
CONSTANT F24 = B"11000";
CONSTANT F26 = B"11010";

CONSTANT F25 = B"11001";

CONSTANT WORD_WIDTH       = 16; -- размер слова данных


SUBDESIGN CAMAC_Fin
(
-- Выводы (пины) на шину КАМАК
  W[16..1]						: input;
  R[16..1]						: output;
  R_OE							: output; -- сообщает пользователю о необходимости открыть драйверы R-шины    
  B								: input;  -- 
  N,A[4..1],F[4..0],S1,S2		: input;
  nQ,nX1						: output;  -- Active LOW output !!!
  LAM							: output;								

-- Интерфейс на шину проекта пользователя
  Clock							: input ;  -- частота работы модуля (25..125МГц)
  Reset							: input = GND ;  -- Common FPGA Reset
  AccessRequest					: output; -- запрос на доступ к шине для чтения/записи данных Пользователя 
  AccessGranted					: input;  -- Разрешение Арбитра выставить Адрес, направление 
  DataBusStrobe					: input;  -- строб приема/передачи данных наружу (высокий уровень, защелкиваем по заднему фронту)
  DirectOut						: output; -- направление передачи данных (на шину КАМАК или с нее, по умолчания всегда передача на шину КАМАК)
  AddrBusOut[WORD_WIDTH-1..0]	: output; -- шина адреса для доступа в пространства памяти/регистров
  Addr_MemnReg					: output; -- признак обращения в пространство памяти или пространство
                                        -- регистров проекта пользователя 
  DataBus_In[WORD_WIDTH-1..0]	: input;  -- отправляемые пользователем в КАМАК данные
  DataBusOut[WORD_WIDTH-1..0]	: output; -- получаемые пользователем из КАМАКа данные

  --Start                       : output; -- "толкает" какую-либо функцию в проекте пользователя
  CAMAC_Active				:output; -- output for LightPulser  
  LAM_Requiest				: input ;			

-- "Стандартные" (обязательные) флаги проекта пользователя, доступные через Регистр Статуса
  LinkClockCaptured           : input; --входит в регистр из проекта пользователя
  LinkActive                  : input;
  Link_Error                  : input; 
  Busy_on_Digitizing          : input = GND;
  Busy_on_Copy                : input = GND;
  DeadTime                    : input = GND;
  
  
  
  Error			  			  : output ;

  test1,test2,test3           : output;  
)
VARIABLE
  F_Reg                      : LPM_SHIFTREG with (lpm_width=5 );  -- регистр функции
  A_Reg                      : LPM_SHIFTREG with (lpm_width=4 );  -- регистр субадреса, стробов

-- регистр промежуточного хранения данных, принятых от КАМАК-шины "W" и предназначенных
-- для передачи на шину пользователя 
  W_Reg							: LPM_SHIFTREG with (lpm_width=16 ); 
-- регистр промежуточного хранения данных, принятых от шины пользователя и предназначенных
-- для передачи на КАМАК-шину "R"
  R_Reg							: LPM_SHIFTREG with (lpm_width=16 );
  Out_Buffer					: LPM_SHIFTREG with (lpm_width=16 );
  R_[15..0]						: node ;	
-- счетчик-указатель адреса 
  Addr_Reg						: LPM_COUNTER with ( lpm_width=16, lpm_direction="up" ); 
  Address_Increment_Request		: Edge_Sensing; -- сигнал запроса инкрементации Addr_Reg  по F2, F18
	Address_Increment_Wait		: SRFF ;  -- Разрешает инкрементацию ПОСЛЕ DataStrobe.

  StatusIn_Reg					: LPM_SHIFTREG with (lpm_width=16, lpm_direction="UNUSED"); -- регистр статуса содержит информацию для "User Interface" 
  StatusOut_Reg					: LPM_SHIFTREG with (lpm_width=16, lpm_direction="UNUSED"); -- регистр статуса содержит информацию от  "User Interface"

		IntQ_					: node;	--Active HIGH, for implisit OR operation
-- Флаги команд
 -- CAMACRead                  : node;   -- Combinatorial node, Use Carefully !!!!!
 -- CAMACWrite                 : node;
 -- MemOrReg                   : node;


  CAMACCycleBegin            : Edge_Sensing;    -- Сигнал запроса с шины КАМАКа
  CAMACCycleEnd              : Edge_Sensing;    -- Сигнал окончания обмена с крейт-контроллером КАМАК
  CAMACCycleActive           : SRFF;             -- Флаг активности обмена с крейт-контроллером КАМАК
  AccessRequest              : SRFF; 

		LAM_Flag						:SRFF ;
		LAM_Enable						:SRFFE ;
		LAM_Requiest_Edge				: Edge_Sensing ; -- sampling user requiest
		LAM_Occuired_at_Current_Cycle	:SRFF ;

 -- StatusRegWE                : node; 
 -- AddresRegWE                : node; 
 -- WRegWE                     : node; 

  
--  R_OE                       : node; -- сообщает пользователю о необходимости открыть драйверы R-шины
  W_WE                       : node; -- строб записи с КАМАК-а, демультиплексором раздается по регистрам
Data_is_Internal             : node; 
  TimeOutCnt                 : LPM_COUNTER with ( lpm_width=(FLOOR(LOG2(RefClock)))+1, lpm_direction="up" ); 
  TimeOut                    : node;   -- Сигнал аварийного завершения КАМАК-цикла
  S1Flag                     : SRFF;

CAMAC_Read_Edge				: Edge_Sensing ;
CAMAC_Write_Edge			: Edge_Sensing ;


--**********************************************************************************************
BEGIN
DEFAULTS

--MemOrReg     = GND;
--CAMACRead    = GND;
--CAMACWrite   = GND;
IntQ_        = GND;
--Address_Increment_Request.d    = GND;
TimeOut   = GND;

END DEFAULTS;
-------------------------------------------------------
-- Section "Начало и конец КАМАК-цикла" begin 
CAMACCycleBegin.(d, clk, clr)  = ((N AND B), Clock, GND);  -- Ждем установления сигналов N и B, чтобы начать цикл
CAMACCycleEnd.(d,clk,clr)       = ((S2 OR TimeOut),Clock, GND);  -- Конец цикла, по стробу S2 или по таймауту
CAMACCycleActive.(S,R,clk) = (CAMACCycleBegin.q,CAMACCycleEnd.q,Clock); -- Флаг, Имеем "1" во время КАМАК-цикла

CAMAC_Active	=	CAMACCycleActive.q;

		-- Контроль работы КАМАКа
		TimeOutCnt.(clock,sclr) = (Clock, !CAMACCycleActive.q); -- счетчик времени КАМАК-цикла 

		-- Проверка: завершен ли КАМАК-цикл вовремя, т.е. пришел ли стороб S2 ?
			if(TimeOutCnt.q[] == (RefClock-1)) THEN TimeOut = VCC; -- если за 1 мкс не возникает сигнал CAMACCycleEnd.q
			ELSE TimeOut = GND;                                  -- то сбрасывает флаг CAMACCycleActive и сообщаем об ошибке
			END IF;

		-- Проверка:  пришел ли стороб S1 в первой половине цикла ?
		S1Flag.(S,R,clk) = (S1,CAMACCycleEnd.q,Clock); -- Флаг наличия строба S1 в данном КАМАК-цикле
			if( (TimeOutCnt.q[] == (HALFCYCLE-1)) AND !S1Flag.q ) 
			THEN TimeOut = VCC; ELSE TimeOut = GND; END IF;

		Error	=	DFF(.d=TimeOut, .clk=Clock); -- Вывод аварийного завершения цикла на лампочку и синхронизацию осциллографа

-- ioaaou ia oeio EAIAE 
nX1 = !CAMACCycleActive.q; 			-- Ioaao X anaaaa   
nQ  = !DFF(.d=(IntQ_ AND CAMACCycleActive.q), .clk=Clock);    -- Ioaao Q 

-- Section "Начало и конец КАМАК-цикла" end 


		-- Защелкиваем функцию и субадрес в регистр одновременно с CAMACCycleActive
		F_Reg.(data[],clock,enable,load) = (F[],Clock,CAMACCycleBegin.q,VCC);
		A_Reg.(data[],clock,enable,load) = (A[],Clock,CAMACCycleBegin.q,VCC);

--R_OE = CAMACCycleActive.q AND CAMACRead;   -- GATE Signal to OpenDrane 
W_WE = DFF(.d=(CAMACCycleActive.q AND S1), .clk=Clock);        -- сигнал защелкивания данных в регисты адреса, статуса или данных ???????????
R_OE	=	SRFF(.S=	((DataBusStrobe AND AccessGranted AND !Data_is_Internal) OR (Data_is_Internal AND CAMACCycleActive.q)  ), 
				 .R=	CAMACCycleEnd.q, .clk=Clock);

test1 = Addr_MemnReg;
test2 = W_WE;
test3 = DirectOut;
-------------------------------------------------------
-- Section "Таблица команд" begin
%
IF (CAMACCycleActive.q == VCC) THEN
   CASE F_Reg.q[] IS
      WHEN F0  =>  --CASE A_Reg.q[] IS    -- чтение из пространства регистров КАМАК-интерфейса
                   --   WHEN 0 => R[] = DescriptorWord0; -- 
                   --   WHEN 1 => R[] = DescriptorWord1; -- 
                   --   WHEN 2 => R[] = StatusOut_Reg.q[];    -- данные поступают из статусного регистра от "Users Interface"
                    --  WHEN 4 => R[] = Addr_Reg.q[];         -- Контроль данных из регистра адреса 
                    --  WHEN 8 => R[] = R_Reg.q[];            -- Данные, предоставленные пользователем
                    --  WHEN 9 => R[] = W_Reg.q[];            -- Контроль данных, отданных пользователю
                   --END CASE;
                --   IntQ = CAMACCycleActive.q;
      WHEN F1  => --CASE A_Reg.q[] IS -- чтение из пространства регистров/памяти проекта пользователя        
                  --   WHEN 0 => MemOrReg = GND; -- чтение из пространства регистров проекта пользователя
                  --   WHEN 1 => MemOrReg = VCC; -- чтение из пространства памяти проекта пользователя
                  --   WHEN OTHERS => MemOrReg = GND; -- по умолчанию попадаем в пространство регистров проекта пользователя
                  --END CASE;
                --  R[] = R_Reg.q[]; 
                  -- CAMACRead = VCC;  -- сигнал разрешения генерации запроса на защелкивание данных для проекта пользователя
                  IntQ = CAMACCycleActive.q; 
      WHEN F2  =>  --CASE A_Reg.q[] IS -- чтение из пространства регистров/памяти проекта пользователя, автоикр.
                   --  WHEN 0 => MemOrReg = GND; -- чтение из пространства регистров проекта пользователя
                   --  WHEN 1 => MemOrReg = VCC; -- чтение из пространства памяти проекта пользователя
                   --  WHEN OTHERS => MemOrReg = GND; -- по умолчанию попадаем в пространство регистров проекта пользователя
                  --END CASE;                
				--  R[] = R_Reg.q[];
--                  Address_Increment_Request.d = VCC; 
                  -- CAMACRead = VCC; 
                --  IntQ = CAMACCycleActive.q;


      WHEN F16 => --CASE A_Reg.q[] IS  -- запись в пространство регистров КАМАК-интерфейса
--                      	WHEN 2 => StatusRegWE = W_WE;  
--                      	WHEN 4 => AddresRegWE = W_WE;
--                      	WHEN 9 => WRegWE      = W_WE;
--                      	WHEN OTHERS =>
--                                StatusRegWE = GND;  
--                                AddresRegWE = GND;
--                                WRegWE      = GND;
--                  END CASE;
--                  MemOrReg = GND;
                 --IntQ = CAMACCycleActive.q;
      WHEN F17 => --CASE A_Reg.q[] IS  -- запись в пространство регистров/памяти проекта пользователя
                  --    WHEN 0 => MemOrReg = GND;  --  в пространство регистров проекта пользователя
                  --    WHEN 1 => MemOrReg = VCC;  --  в пространство памяти проекта пользователя
                  --    WHEN OTHERS => MemOrReg = GND;
                  --END CASE;
                  -- WRegWE     = W_WE; 
                  -- CAMACWrite = VCC;
                 -- IntQ = CAMACCycleActive.q;
      WHEN F18 => --CASE A_Reg.q[] IS  -- запись в пространство регистров/памяти проекта пользователя, автоинкремент
--                      WHEN 0 => MemOrReg = GND;  --  в пространство регистров проекта пользователя
--                      WHEN 1 => MemOrReg = VCC;  --  в пространство памяти проекта пользователя
--                      WHEN OTHERS => MemOrReg = GND;
--                  END CASE;
--                  Address_Increment_Request.d  = VCC;
                  -- WRegWE     = W_WE; 
                  -- CAMACWrite = VCC;
                 -- IntQ = CAMACCycleActive.q;
                  
--      WHEN F25 => Start = CAMACCycleActive.q;	--Removed totally
--                  IntQ = CAMACCycleActive.q;

--	  WHEN F8  => IntQ = LAM_Trigg.q ;						-- Moved to LAM section
--	  WHEN F24 => EnableLAM_Trigg.S = CAMACCycleActive.q;
--                  IntQ = CAMACCycleActive.q;
--	  WHEN F26 => EnableLAM_Trigg.R = CAMACCycleActive.q;
--                  IntQ = CAMACCycleActive.q;

      WHEN OTHERS => --MemOrReg     = GND;
                     --CAMACRead    = GND;
                     --CAMACWrite   = GND;
                   --  IntQ_        = GND;
                     --WRegWE       = GND;
--                     Start        = GND;
   END CASE;
END IF; 

-- Section "Таблица команд" end
%
IntQ_	=	(F_Reg.q[] == F0) OR (F_Reg.q[] == F1) OR (F_Reg.q[] == F2) OR (F_Reg.q[] == F16) OR (F_Reg.q[] == F17) OR (F_Reg.q[] == F18);

--------------------------------------------------------------------------------------------
-- Section "Bus Connections" Begin
-- Здесь описана структура соединений шин данных, не вошедших в описание мультиплексоров 
-- по "Таблица команд",  IF, CASE и пр.

-- данные для "Users Interface"
DataBusOut[] = W_Reg.q[];
AddrBusOut[] = Addr_Reg.q[];
Addr_Reg.(data[],clock, sload ) 		= ( W[], Clock, DFF(.d=((F_Reg.q[] == F16) and (A_Reg.q[]==4)), .clk=Clock) AND W_WE);
-- прогружаемая часть статусного регистра
StatusIn_Reg.(data[],clock, load, enable) 	= ( W[], Clock, VCC, DFF(.d=((F_Reg.q[] == F16) and (A_Reg.q[]==2)), .clk=Clock) AND W_WE);

W_Reg.(  data[], clock, load, enable)		= ( W[], Clock, VCC, DFF(.d=(	((F_Reg.q[] == F16) and (A_Reg.q[]==9)) OR
																		(F_Reg.q[] == F17)							OR
																		(F_Reg.q[] == F18)						), 	.clk=Clock) AND W_WE);


R_Reg.(data[],clock,enable,load) 		= (DataBus_In[],Clock,(DataBusStrobe AND AccessGranted),VCC);


   CASE F_Reg.q[] IS
      WHEN F0  =>  CASE A_Reg.q[] IS    -- ?oaiea ec i?ino?ainoaa ?aaeno?ia EAIAE-eioa?oaena
						WHEN 0 => R_[] = DescriptorWord0; 	Data_is_Internal=VCC;-- 
						WHEN 1 => R_[] = DescriptorWord1; 	Data_is_Internal=VCC;-- 
						WHEN 2 => R_[] = StatusOut_Reg.q[];	Data_is_Internal=VCC;    -- aaiiua iinooia?o ec noaooniiai ?aaeno?a io "Users Interface"
						WHEN 4 => R_[] = Addr_Reg.q[];		Data_is_Internal=VCC;   -- Eiio?ieu aaiiuo ec ?aaeno?a aa?ana 
						WHEN 8 => R_[] = R_Reg.q[];			Data_is_Internal=GND;   -- Aaiiua, i?aainoaaeaiiua iieuciaaoaeai
						WHEN 9 => R_[] = W_Reg.q[];			Data_is_Internal=VCC;   -- Eiio?ieu aaiiuo, ioaaiiuo iieuciaaoae?
						WHEN OTHERS  =>	R_[] = R_Reg.q[];	Data_is_Internal=GND;
                   END CASE;
      WHEN OTHERS  => 					R_[] = R_Reg.q[];	Data_is_Internal=GND;
   END CASE;
R[]	=	Out_Buffer.q[]; Out_Buffer.clock=Clock; Out_Buffer.data[] = R_[]; Out_Buffer.sclr	=	!R_OE;

-- Section "Bus Connections" End





-- Autoincrement at END of bus access
Addr_Reg.cnt_en				=	DataBusStrobe AND DFF(.d=(Address_Increment_Wait.q AND AccessGranted), .clk=clock) ; -- Enable increment at end of bus access
Address_Increment_Request.(clk, clr, d) = (Clock, GND, ((F_Reg.q[] == F2) OR (F_Reg.q[] == F18)));
Address_Increment_Wait.(S, clk, R)	=	( Address_Increment_Request.q, Clock, (DataBusStrobe AND AccessGranted));
 -- Set waiting for end of bus access -- Reset exactly at end of access
--------------------------------------------------------------------------------------------

-- "Стандартное" заполнение битового пространства Регистра Статуса (читаемая часть)
StatusOut_Reg.(clock,enable,load) = (Clock,!CAMACCycleActive.q,VCC); -- фиксируем по запросу КАМАК-а   
StatusOut_Reg.data[0]	= LinkClockCaptured;	-- Есть захват входной частоты
StatusOut_Reg.data[1]	= LinkActive;			-- Идет обмен по Линку
StatusOut_Reg.data[2]	= Link_Error;			-- Есть проблемы
StatusOut_Reg.data[3]	= Busy_on_Digitizing;	-- Идет оцифровка
StatusOut_Reg.data[4]	= DeadTime;			-- Отрабатывается мертвое время
StatusOut_Reg.data[5]	= Busy_on_Copy;		-- Флаг копирования порогов/коэффициентов
StatusOut_Reg.data[6]	= Error;		-- Есть проблемы
StatusOut_Reg.data[7]	= LAM_Flag.q ;		-- Есть LAM
StatusOut_Reg.data[8]	= LAM_Enable.q ;		-- Разрешен(VCC)/Запрещен  LAM
StatusOut_Reg.data[WORD_WIDTH-1..9]	= GND ;


-- LAM section begin
	LAM_Requiest_Edge.(d, clk, clr)  			=	(LAM_Requiest, Clock, Reset ) ;
	LAM_Occuired_at_Current_Cycle.(S, Clk, R)	=	((LAM_Requiest_Edge.q AND CAMACCycleActive.q), Clock, CAMACCycleEnd.q);-- Active HIGH
	--If LAM occuired during cycle is active, only next CAMAC cycle will reset LAM
	LAM_Flag.(S,clk,R)	=	(LAM_Requiest_Edge.q, Clock, (!LAM_Occuired_at_Current_Cycle.q AND CAMACCycleEnd.q));-- Active HIGH

	LAM 	=  ! ( LAM_Flag.q AND LAM_Enable.q ) ;					-- Active LOW
			IntQ_	=	LAM_Flag.q AND (F_Reg.q[]== F8) ;			-- Active HIGH
			IntQ_	=	(F_Reg.q[] == F24) OR (F_Reg.q[] == F26);	-- Active HIGH
			LAM_Enable.(S, clk, R, ena)	=	((F_Reg.q[] == F24), Clock, (F_Reg.q[] == F26), W_WE) ;-- chandge status at S1
-- LAM section end




----------------------------------------------------------------------
-- Section "User Interface Control" Begin
      -- генерация запроса на предоставление/получение данных от/к юзер интерфейсу
-- По чтению доступ запрашивается ДО строба S1, вырубка короткого импульса
--CAMAC_Read_Edge.( d, clk, clr ) = (CAMACRead, Clock , GND ) ;
CAMAC_Read_Edge.(clk, clr, d ) = (Clock, GND, ((F_Reg.q[] == F1) OR (F_Reg.q[] == F2))) ;

-- По записи доступ запрашивается ПОСЛЕ начала S1 , вырубка короткого импульса
--CAMAC_Write_Edge.( d, clk, clr ) = (!(CAMACWrite AND W_WE), Clock , GND ) ;
CAMAC_Write_Edge.(clk, clr, d ) = (Clock, GND, !(W_WE and DFF(.clk=Clock, .d=((F_Reg.q[] == F17) OR (F_Reg.q[] == F18))))  ) ;

AccessRequest.S  =  CAMAC_Read_Edge.q  OR CAMAC_Write_Edge.q  ;
AccessRequest.clk = Clock ;
AccessRequest.R  = (DataBusStrobe AND AccessGranted) ;
 
  -- SubSection "Direction control" Begin
DirectOut = SRFF(.S=( CAMAC_Write_Edge.q), .clk=Clock,.R=(DataBusStrobe AND AccessGranted)); -- Выдача данных высоким уровнем в регистры или в память
  -- SubSection "Direction control" End
  -- SubSection "Region control" Begin
Addr_MemnReg = A_Reg.q[0]; --MemOrReg; -- признак обращения в пространство памяти (VCC) или пространство
                         -- регистров (GND - по умолчанию) проекта пользователя
  -- SubSection "Region control" End 

  -- Section "User Interface Control" End
-- Warning!!! Assertion of these signals on Bus Lines provided by external MUX. This is due to restrictions
-- on Tri-state interchange between modulus in Quartus software.
----------------------------------------------------------------------

END;
