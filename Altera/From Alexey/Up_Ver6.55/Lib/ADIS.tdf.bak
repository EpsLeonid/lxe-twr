TITLE " kanal ADIS " ;

INCLUDE "lpm_counter.inc" ;
INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "Edge_Sensing.inc"; 
INCLUDE "Sum_x_4.inc"; 
INCLUDE "FORs_RAM.inc";


Constant TimeStampDelay	 = 19;
Constant TrigTimeOut   	 = 35;--32;


Constant MinSignalThr    = 40;
Constant FirtsSignalThr  = 58;
Constant SecondSignalThr = 84;
Constant ThirdSignalThr  = 128;
Constant FourthSignalThr = 247;
Constant FiveSignalThr   = 500;


PARAMETERS
(
	ADC_Bits        = 10,  -- разрядность АЦП
    NumInReg        = 4,  -- число входных регистров (число слов)
    MaxTimeWaitHT   = 15  -- максимальное число тактов для ожидания верхнего порога
);

SUBDESIGN ADIS
(
  Clock                           : input; -- внешняя частота

  In_Data[ADC_Bits-1..0]          : input; -- входные данные
  Reset                           : input = GND; -- внешний сброс модуля
  Event                           : input; -- такт конвейера /Sample Enable/
  LinkMsg                         : input; -- сигнал о работе линка (общий стоп)

  Start                           : output; -- сигнал превышения нижнего порога с задержкой
  Amp[ADC_Bits-1..0]              : output; -- величина амплитуды сигнала
  Resolution_Time                 : output; -- сформированный сигнал для схемы совпадения

-- 
  DataBus_In[15..0]			      : input;  -- отправляемые с Внутренней Шины в Модуль данные
  DataBusOut[15..0]     	  	  : output; -- выдаваемые на Внутреннюю Шину из Модуля данные (младшие 16бит шины R)
  
  DataBusStrobe 			 	  : input;  -- строб приема/передачи данных наружу (высокий уровень, защелкиваем по заднему фронту)
  Select					 	  : input;  -- Выбор Модуля для работы с памятью Командного Листа в режиме Slave (с КАМАК-ом)
  DirectIn					  	  : input;  -- направление передачи данных, Если =GND, то данный Модуль читается, если =VCC, то пишется.
  AddrBus_In[8..0]			 	  : input;  -- адрес при операциях доступа чтения/записи Командного Листа с КАМАК-а

  SyncPulse                       : input; 

  test1,test2                     : output;
)

-- VARIABLE section ____________________________________________________
VARIABLE
-- управление КИХ фильтром
 FIR_Control_Reg                  : lpm_shiftreg with (LPM_WIDTH = 16, LPM_DIRECTION="unused"); 
 FIR_Control_Reg_CS               : node;
 In_Data_Buff[11..0]              : node;
 
 Running_Window 				  : node;
 Integrator      				  : node;
 MaxSpeed      					  : node;
-- Конвеер КИХ фильтра
 InData_Reg[NumInReg-1..0]        : lpm_shiftreg with (LPM_WIDTH = ADC_Bits, LPM_DIRECTION="unused"); -- регистр оцифрованных значений (сэмплов)
 Average_Reg                      : lpm_shiftreg with (LPM_WIDTH = ADC_Bits, LPM_DIRECTION="unused"); -- регистр усредненных значений
 Summator                         : Sum_x_4; -- сумматор на 4
 Divide_x_4[ADC_Bits-1..0]        : node; 
 Delay_Aver_Reg                   : lpm_shiftreg with (LPM_WIDTH = ADC_Bits, LPM_DIRECTION="unused"); -- регистр данных
 
 Integrator_Reg                   : lpm_shiftreg with (LPM_WIDTH = ADC_Bits+2, LPM_DIRECTION="unused"); -- 
 
  
 LT_Trig                          : SRFF; -- флаг определения нижнего порога
 Comp_of_LT                       : node;
 HT_Trig                          : SRFF; -- флаг определения верхнего порога
 Max_Trig                         : SRFF; -- флаг определения максимума
 Value_Up_LT                      : node; -- сигнал о превышении нижнего порога (стоит пока нижний порог превышен)
 Value_Down_LT                    : node; -- нижний порог подлежит сбросу
 Value_Up_HT                      : node; -- сигнал о превышении верхнего порога (стоит пока верхний порог превышен)
 Value_Max_Done                   : node; -- сигнал об обнаружении изменения знака разницы между предыдущими и текущими сэмплами

 NWord_Cnt              	      : LPM_COUNTER with ( lpm_width=8, lpm_direction="up" ); -- счетчик 
 Max_Reg                          : lpm_shiftreg with (LPM_WIDTH = ADC_Bits, LPM_DIRECTION="unused"); -- амплитуда сигнала

 AllReset                         : node;
 Int_Rst                          : node;
 Internal_Reset, External_Reset   : node;
 End_of_LinkMsg					  : Edge_Sensing;
 NoHT                             : node;
 NoHT_Trig                        : SRFF;
 Timeout                          : node;
 Max_Cnt_State                    : node;


 EvtPulse                         : DFF;

 TimeStamp                        : node;
 StartPulse                       : DFF;

 Sample_Enable                    : node; 

 -- Память истории
 RAM   						      : FORs_RAM;
 RAMAddrBus[7..0]                 : node;
 SaveRAM                          : node;
 
 S_Enable                         : node; 
 Piedistal_Reg                    : lpm_shiftreg with (LPM_WIDTH=ADC_Bits,LPM_DIRECTION="unused"); -- пъедистал
 SavePReg                         : node; 
 LThresholdReg                    : lpm_shiftreg with (LPM_WIDTH=ADC_Bits,LPM_DIRECTION="unused"); -- нижний порог
 SaveLTReg                        : node; 
 HThresholdReg                    : lpm_shiftreg with (LPM_WIDTH=ADC_Bits,LPM_DIRECTION="unused"); -- верхний порог
 SaveHTReg                        : node; 
 TimeStampDelayReg                : lpm_shiftreg with (LPM_WIDTH=8,LPM_DIRECTION="unused"); -- задержка временной отметки
 SaveTSDReg                       : node; 

-- Формирование данных для медленного линка
 Time_Counter                     : LPM_COUNTER  with (LPM_WIDTH=11, LPM_DIRECTION="up" ); -- счетчик времени
 LT_Time_Reg                      : lpm_shiftreg with (LPM_WIDTH=11, LPM_DIRECTION="unused");
 LT_Done                          : Edge_Sensing;
 HT_Time_Reg                      : lpm_shiftreg with (LPM_WIDTH=11, LPM_DIRECTION="unused");
 HT_Done 						  : Edge_Sensing;
 GStop_Time_Reg                   : lpm_shiftreg with (LPM_WIDTH=13, LPM_DIRECTION="unused"); -- регистр времени прихода общего стопа и состояния порогов
 GStop_Done 					  : Edge_Sensing;
 Ampl_Reg                         : lpm_shiftreg with (LPM_WIDTH = ADC_Bits, LPM_DIRECTION="unused"); -- амплитуда сигнала

-- Выдача данных наружу из модуля
 --DataBusMux                       : BUS_Mux;
 --AddrMux[3..0]                    : node;

-- LOGIC section _______________________________________________________
BEGIN

DEFAULTS
    Value_Up_LT        = GND;
    Value_Down_LT      = GND;
    Value_Up_HT        = GND;
    Value_Max_Done     = GND;
    NoHT               = GND;
    TimeStamp          = GND;

    SaveRAM            = GND;
    SavePReg           = GND;
    SaveLTReg          = GND;
    SaveHTReg          = GND;
    
    DataBusOut[]       = GND;
  --  SaveDlTReg         = GND;
  --  SaveDrTReg         = GND;
END DEFAULTS;


-- Такт конвеера
 EvtPulse.(d,clk) = (Event, Clock);  
 Sample_Enable    = EvtPulse.q;
 
Integrator     = FIR_Control_Reg.q[0];
Running_Window = FIR_Control_Reg.q[1];
MaxSpeed       = FIR_Control_Reg.q[2]; -- флаг скорости для бегущего среднего

-- *************** Конвеер КИХ фильтра бегущее среднее *********************
-- соединяем все регистры последовательно
InData_Reg[0].(data[],clock,enable,load) = (In_Data[9..0],Clock, Sample_Enable OR MaxSpeed,VCC);
FOR i IN 0 TO (NumInReg-2) GENERATE
   InData_Reg[i+1].data[] = InData_Reg[i].q[];
   InData_Reg[i+1].(clock,enable,load) = (Clock,Sample_Enable,VCC);
END GENERATE;

-- Находим среднее по 4 отсчетам
Summator.clock = Clock;
Summator.(data0x[],data1x[],data2x[],data3x[]) = (InData_Reg[0].q[],InData_Reg[1].q[],InData_Reg[2].q[],InData_Reg[3].q[]);
Divide_x_4[ADC_Bits-1..0] = Summator.result[ADC_Bits+1..2]; -- делим на 4 (сдвигаем на 2 разряда)



-- *************** Конвеер КИХ фильтра  интегратор*********************
-- Strobed Integrator
  In_Data_Buff[9..0] = InData_Reg[0].q[];
  In_Data_Buff[11..10] = GND;
  
  Integrator_Reg.data[11..0]	=	Integrator_Reg.q[11..0] + In_Data_Buff[11..0];
  Integrator_Reg.(Clock, load, sclr)	=	(Clock, VCC, Sample_Enable);
  
-- ****************** Установки для КИХ фильтров ********************** 
FIR_Control_Reg.(data[], clock, enable, load) = (DataBus_In[], Clock, FIR_Control_Reg_CS, VCC);  
-- Input select
  CASE (Running_Window, Integrator) IS
		WHEN B"10"   =>	Average_Reg.data[]		= Divide_x_4[];
		WHEN B"01"   =>	Average_Reg.data[]		= Integrator_Reg.q[11..2];
		WHEN OTHERs  =>	Average_Reg.data[]   	= In_Data_Buff[9..0];
  END CASE;

  Average_Reg.(clock,enable,load)  = (Clock, VCC,VCC);

-- *************** Двухпороговый дискриминатор ********************
-- проверяем на превышение порогов
-- нижний порог
IF((Average_Reg.q[] > LThresholdReg.q[]) AND (LT_Trig.q == GND) ) THEN  Value_Up_LT = VCC; -- превышен нижний порог
                                                                  ELSE  Value_Up_LT = GND;
END IF; 

IF((Average_Reg.q[] < LThresholdReg.q[]) AND (LT_Trig.q == VCC) )
                THEN Value_Down_LT = VCC; -- нижний порог подлежит сбросу
                ELSE Value_Down_LT = GND; -- если сигнал упал ниже нижнего порога
END IF;  

LT_Trig.(S,clk,R) = (Value_Up_LT, Clock, AllReset);
IF((Average_Reg.q[] > HThresholdReg.q[]) AND (LT_Trig.q == VCC) AND (HT_Trig.q == GND) AND (NoHT_Trig.q == GND)) THEN  Value_Up_HT = VCC; -- превышен верхний порог
                                                                                                                 ELSE  Value_Up_HT = GND;
END IF;

Comp_of_LT	=	DFF(.d=(Average_Reg.q[] > LThresholdReg.q[]), .clk=Clock);

-- верхний порог
HT_Trig.(S,clk,R) = (Value_Up_HT, Clock, AllReset); -- флаг превышения верхнего порога
-- определяем максимум
Delay_Aver_Reg.(data[],clock,enable,load) = (Average_Reg.q[],Clock,Sample_Enable,VCC);
IF((Average_Reg.q[] < Delay_Aver_Reg.q[]) AND (HT_Trig.q == VCC) AND (Max_Trig.q == GND)) THEN  Value_Max_Done = VCC;
                                                                                          ELSE  Value_Max_Done = GND;
END IF; 
Max_Trig.(S,clk,R) = (Value_Max_Done, Clock, AllReset); -- флаг определения максимума
Max_Reg.(data[],clock,enable,load,aclr) = (Delay_Aver_Reg.q[],Clock,Value_Max_Done,VCC,AllReset);


-- счетчик слов (запускается от нижнего порога)
NWord_Cnt.(clock,clk_en,sclr,cnt_en) = (Clock,VCC, AllReset, Sample_Enable AND LT_Trig.q AND Max_Cnt_State);-- AND !NoHT_Trig.q);
-- Общий сброс
-- если через 640 нс после пересечения нижнего порога нет срабатывания верхнего сбрасываем модуль
IF( (NWord_Cnt.q[] == MaxTimeWaitHT) AND (HT_Trig.q == GND) ) THEN NoHT = VCC; 
                                                              ELSE NoHT = GND; 
END IF;
NoHT_Trig.(S,clk,R) = (NoHT,Clock,AllReset);

IF(NWord_Cnt.q[] == TrigTimeOut) THEN TimeOut = VCC;
                                 ELSE TimeOut = GND;
END IF;

IF(NWord_Cnt.q[] == 254) THEN Max_Cnt_State = GND;
                         ELSE Max_Cnt_State = VCC;
END IF;


--Формируем сигнал временной отметки
IF((LT_Trig.q == VCC) AND (HT_Trig.q == VCC) AND (NWord_Cnt.q[] >= TimeStampDelayReg.q[])) THEN TimeStamp = VCC;
                                                                                           ELSE TimeStamp = GND;
END IF;
StartPulse.(d,clk) = (TimeStamp,Clock);

-- Формируем сигнал окончания цикла измерений
 Int_Rst    = Internal_Reset and !LinkMsg;
 AllReset	= DFF(.d=Int_Rst OR External_Reset, .clk=Clock);
 
 IF((LT_Trig.q == VCC) AND (HT_Trig.q == VCC)) 
		THEN Internal_Reset = TimeOut;
		ELSE Internal_Reset = Value_Down_LT;
 END IF;

 IF(Comp_of_LT == VCC)  
		THEN External_Reset = GND;
		ELSE External_Reset = Reset OR End_of_LinkMsg.q;
 END IF;    
 End_of_LinkMsg.(d,clk) = (!LinkMsg, Clock);


Start      = StartPulse.q; -- сигнал
Amp[]      = Max_Reg.q[];

test1 = LT_Trig.q;
test2 = HT_Trig.q;
--test3 = AllReset;
--test4 = !TimeOutTrig.q; 
--tsCnt[] = NWord_Cnt.q[]; 

--******************************* Память истории ***********************************
RAM.data_a[9..0]   = In_Data_Buff[9..0];  -- амплитуда сигнала
RAM.data_a[10]     = LT_Trig.q;    -- сигнал о срабатывании нижнего порога
RAM.data_a[11]     = HT_Trig.q;    -- сигнал о срабатывании верхнего порога
RAM.data_a[12]     = Max_Trig.q;
RAM.data_a[14..13] = GND;--Correction.q[2..0]; -- поправка в задержку временной отметки на амплитуду сигнала
RAM.data_a[15]     = SyncPulse;
RAM.(address_a[7..0]     , clock_a, wren_a       ) =
    (Time_Counter.q[7..0], Clock  , !LinkMsg AND Sample_Enable); 

RAMAddrBus[7..0] = Time_Counter.q[7..0] - AddrBus_In[7..0]-1; -- выставление адреса в 0 для текущего набора FOR-ов
RAM.(address_b[7..0] , clock_b, data_b[15..0], wren_b) =
    (RAMAddrBus[7..0], Clock  , DataBus_In[] , SaveRAM); 

Piedistal_Reg.(data[], clock, enable, load)     = (DataBus_In[ADC_Bits-1..0], Clock, SavePReg  , VCC);
LThresholdReg.(data[], clock, enable, load)     = (DataBus_In[ADC_Bits-1..0], Clock, SaveLTReg , VCC);
HThresholdReg.(data[], clock, enable, load)     = (DataBus_In[ADC_Bits-1..0], Clock, SaveHTReg , VCC);
TimeStampDelayReg.(data[], clock, enable, load) = (DataBus_In[7..0]         , Clock, SaveTSDReg, VCC);

-- *********************** Формирование данных для медленного линка ******************************
-- во время чтения по медленному линку занчения времени срабатывания прогов в регистрах не фиксируется
Time_Counter.(clock,cnt_en,clk_en) = (Clock, !LinkMsg, Sample_Enable);

LT_Time_Reg.(data[],clock,enable,load,aclr) = (Time_Counter.q[], Clock, LT_Done.q AND !LinkMsg, VCC, AllReset);
LT_Done.(d,clk) = (Value_Up_LT,Clock);
HT_Time_Reg.(data[],clock,enable,load,aclr) = (Time_Counter.q[], Clock, HT_Done.q AND !LinkMsg, VCC, AllReset);
HT_Done.(d,clk) = (Value_Up_HT,Clock);
GStop_Time_Reg.data[10..0] = Time_Counter.q[]; -- фиксируем время прихода общего стопа, время нижнего порога (GStop_Time_Reg.q[]-LT_Time_Reg.q[]). Верхнего аналогично
GStop_Time_Reg.data[11] = LT_Trig.q; -- фиксируем состояние порогов,
GStop_Time_Reg.data[12] = HT_Trig.q; -- являются ли пороги сработавшими 
GStop_Time_Reg.(clock,enable,load) = (Clock, GStop_Done.q,VCC);
GStop_Done.(d,clk) = (LinkMsg,Clock); -- защелкиваем состояние Time_Counter по переднему фронту LinkMessage
-- фиксируем амплитуду сигнала
Ampl_Reg.(data[],clock,enable,load,aclr) = (Delay_Aver_Reg.q[],Clock,Value_Max_Done AND !LinkMsg,VCC,AllReset);

Resolution_Time = TimeStamp;

--********************************* 
S_Enable = DataBusStrobe and  DirectIn AND Select;
-- с 0..255 адрес пишем в память
IF ( (AddrBus_In[] >= 0) AND (AddrBus_In[] <= 255) ) 
         THEN DataBusOut[]               = RAM.q_b[];  
              SaveRAM                    = S_Enable;  -- AND !AddrBus_In[8];
         ELSE SaveRAM = GND;
END IF;
-- 256 адрес регистра пъедистала
IF (AddrBus_In[] == 256) 
         THEN DataBusOut[ADC_Bits-1..0]  = Piedistal_Reg.q[];
              DataBusOut[15..ADC_Bits]   = GND;
              SavePReg                   = S_Enable;
         ELSE SavePReg = GND;
END IF;
-- 257 адрес регистра нижнего порога
IF (AddrBus_In[] == 257) 
         THEN DataBusOut[ADC_Bits-1..0]  = LThresholdReg.q[];
              DataBusOut[15..ADC_Bits]   = GND;
              SaveLTReg                  = S_Enable;
         ELSE SaveLTReg = GND;
END IF;
-- 258 адрес регистра верхнего порога			
IF (AddrBus_In[] == 258) 
         THEN DataBusOut[ADC_Bits-1..0]  = HThresholdReg.q[];
              DataBusOut[15..ADC_Bits]   = GND;
              SaveHTReg                  = S_Enable;
         ELSE SaveHTReg = GND;
END IF;
-- 259 адрес регистра задержки временной отметки
IF (AddrBus_In[] == 259) 
         THEN DataBusOut[7..0]  = TimeStampDelayReg.q[];
              SaveTSDReg        = S_Enable;
              DataBusOut[15..8] = GND;
END IF;

-- 261 адрес регистра времени срабатывания нижнего порога (только чтение) 
IF (AddrBus_In[] == 261) 
         THEN DataBusOut[ADC_Bits..0]    = LT_Time_Reg.q[]; 
              DataBusOut[15..ADC_Bits+1] = GND;
END IF;
-- 262 адрес регистра времени срабатывания верхнего порога (только чтение) 
IF (AddrBus_In[] == 262) 
         THEN DataBusOut[ADC_Bits..0]    = HT_Time_Reg.q[]; 
              DataBusOut[15..ADC_Bits+1] = GND;
END IF;
-- 263 адрес регистра времени прихода общего стопа (только чтение) 
IF (AddrBus_In[] == 263) 
         THEN DataBusOut[12..0]          = GStop_Time_Reg.q[];
              DataBusOut[15..13]         = GND;
END IF;
-- 264 адрес регистра амплитуды сигнала (только чтение)
IF (AddrBus_In[] == 264) 
         THEN DataBusOut[ADC_Bits-1..0]  = Ampl_Reg.q[];
              DataBusOut[15..ADC_Bits]   = GND;
END IF;
-- 265 адрес регистра амплитуды сигнала 
IF (AddrBus_In[] == 265) 
         THEN DataBusOut[]  = FIR_Control_Reg.q[];
              FIR_Control_Reg_CS = S_Enable;
         ELSE FIR_Control_Reg_CS = GND;
END IF;


END; -- End design