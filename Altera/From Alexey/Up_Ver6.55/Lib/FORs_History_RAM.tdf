TITLE "FORs";

INCLUDE "lpm_counter.inc" ;
INCLUDE "lpm_shiftreg.inc";
INCLUDE "Edge_Sensing.inc";
INCLUDE "lpm_mux.inc" ;
INCLUDE "Dual_Port_RAM_256x16.inc";

CONSTANT WORD_WIDTH       = 16; -- размер слова данных
CONSTANT PrescalerModule6  = 6;  -- делим входную частоту в 6 раз
CONSTANT PrescalerModule3  = 3;  -- делим входную частоту в 3 раза


SUBDESIGN FORs_History_RAM
(
--
  LinkMessage                 : input;
  Clock           			  : input;  -- входная частота 150 МГц, частота работы модуля
  FOR_Sample_Enable           : input;  -- частота оборота пучка, привязанная к общему стопу 
    
-- Module specific signals
  Data_To_Ser[23..0]  	      : input; 
 
  DataBus_In[15..0]			  : input;  -- отправляемые с Внутренней Шины в Линк данные
  DataBusOut[15..0]     	  : output; -- выдаваемые на Внутреннюю Шину из Модуля данные (младшие 16бит шины R)
  
  Bus_Clock                   : input;  -- частота шины проекта 100 МГц
 -- DataBusStrobe 			  : input;  -- строб приема/передачи данных наружу (высокий уровень, защелкиваем по заднему фронту)
 -- Select					  : input;  -- Выбор Модуля для работы с памятью Командного Листа в режиме Slave (с КАМАК-ом)
 -- DirectIn				  : input;  -- направление передачи данных, Если =GND, то данный Модуль читается, если =VCC, то пишется.
  AddrBus_In[9..0]			  : input;  -- адрес при операциях доступа чтения/записи Командного Листа с КАМАК-а
 
)

VARIABLE

  RAM[1..0]					  : Dual_Port_RAM_256x16;
  RAM_Addr_Cnt_a   	          : LPM_COUNTER with ( lpm_width=8, lpm_direction="down" );  
  RAMAddrBus[7..0]            : node;
  RAM_Addr_Cnt_Reg            : lpm_shiftreg with (LPM_WIDTH = 8);
  
BEGIN

DEFAULTS
	DataBusOut[] = GND;
END DEFAULTS;


--*************** Память истории ***************************
RAM[0].(address_a[7..0]       , clock_a, data_a[15..0]      , wren_a) =
       (RAM_Addr_Cnt_a.q[7..0], Clock  , Data_To_Ser[15..0] , FOR_Sample_Enable); 
RAM[1].(address_a[7..0]       , clock_a, data_a[7..0]       , data_a[15..8], wren_a) =
       (RAM_Addr_Cnt_a.q[7..0], Clock  , Data_To_Ser[23..16], B"00000000"  , FOR_Sample_Enable); 

RAM_Addr_Cnt_a.clock   = Clock;
RAM_Addr_Cnt_a.clk_en  = !LinkMessage AND FOR_Sample_Enable;

-- с 0..511 адрес пишем в память
IF(AddrBus_In[] >= 0   AND AddrBus_In[] <= 255) THEN DataBusOut[] = RAM[0].q_b[15..0];
END IF;
IF(AddrBus_In[] >= 256 AND AddrBus_In[] <= 511) THEN DataBusOut[] = RAM[1].q_b[7..0]; DataBusOut[15..8] = GND;
END IF;

RAM_Addr_Cnt_Reg.(data[], clock, enable, load) = (RAM_Addr_Cnt_a.q[7..0], Bus_Clock, VCC, VCC);

RAMAddrBus[7..0] = AddrBus_In[7..0] + RAM_Addr_Cnt_Reg.q[7..0]; -- выставление адреса в 0 для текущего набора FOR-ов
RAM[0].(address_b[7..0] , clock_b  , data_b[15..0]    , wren_b) =
       (RAMAddrBus[7..0], Bus_Clock, DataBus_In[15..0], GND); 
RAM[1].(address_b[7..0] , clock_b  , data_b[15..0]    , wren_b) =
       (RAMAddrBus[7..0], Bus_Clock, DataBus_In[15..0],  GND); 


END; -- End design
