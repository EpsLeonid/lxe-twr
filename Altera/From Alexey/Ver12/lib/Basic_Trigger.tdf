TITLE "Trigger";

INCLUDE "lpm_shiftreg.inc";
INCLUDE "Edge_Sensing.inc";
INCLUDE "Pulse_Shaper.inc";
INCLUDE "FOR_Sum.inc";
INCLUDE "6_AND.inc";



CONSTANT Bus_W_FORs       = 24; -- число FOR-ов на шине W
CONSTANT Bus_R_FORs       = 24; -- число FOR-ов на шине R
CONSTANT FORs_NUMBER      = Bus_W_FORs + Bus_R_FORs; -- общее число FOR-ов

PARAMETERS
(
  TIME_OUT         = 75 -- число тактов мертвого времени
);

SUBDESIGN Basic_Trigger
(
  DataIn_R[Bus_R_FORs-1..0]	  : input; 
  DataIn_W[Bus_W_FORs-1..0]   : input;
  InputShapingTime[7..0]      : input;

  Clock           			  : input;  -- входная частота 

  Enable        	   		  : input;  -- сигнал разрешения/запрещения работы модуля 
  Reset                       : input;  -- сигнал подготавливает модуль к запуску (устанавливает в начальное состояние)

  Result[5..0]                : output; -- решение триггера

  TIME_OUT_IN[15..0]          : input;
  
   
  FOR_Shaped[47..0]           : output;
  DeadTime[5..0]              : output;
  resultTrig[5..0]            : output;
  

  test1,test2,test3           : output; -- тестовые выходы

)

VARIABLE

  Data_Reg                        : lpm_shiftreg with (LPM_WIDTH = FORs_NUMBER, LPM_DIRECTION="unused"); -- регистр данных

  InputShaper[47..0]              : Pulse_Shaper; -- Формирователь длительности входного импульса (~70нс) от фронта FOR-а
  DeadTimeShaper[5..0]            : Pulse_Shaper;  -- Формирователь длительности мертвого времени (1мкс)

  OT_Result[FORs_NUMBER-1..0]     : node;  -- найденные Опорные Точки  
  OT_AND[FORs_NUMBER-1..0]        : 6_AND;
  OT_Trg[FORs_NUMBER-1..0]        : DFF;
--  OT_Reg                          : lpm_shiftreg with (LPM_WIDTH = FORs_NUMBER, LPM_DIRECTION="unused"); -- регистр данных

  ResultBus1_En[Bus_W_FORs-1..0]  : node;
  ResultBus1[Bus_W_FORs..0]       : node;  -- шина результатов комбинации 1 (по 2 ОТ коллениарным)
  --ResultBus3[2..0]                : node;  -- шина результатов комбинации 3 (по 2 ОТ горизонтальной области) 
  ResultBus4                      : node;  -- шина результатов комбинации 4 (внутреннего и внешнего слоя )
  ResultBus5                      : node;  -- шина результатов комбинации 5 (любой FOR)
  
  Summator                        : FOR_Sum;
  Coinsidence_Out[5..0]           : node;  -- выход схемы совпадения
  Coinsidence_Out_Trig[5..0]      : DFF;   -- прорезанный выход схемы совпадения

  OddFOR[24..0]                   : node;  -- сигнал совпадения четных FOR-ов
  EvenFOR[24..0]                  : node;  -- сигнал совпадения нечетных FOR-ов

  OR_FOR[FORs_NUMBER..0]          : node; -- ИЛИ всех FORs

  ExtUpFORs[Bus_W_FORs+1..0]      : node; -- сопадение верхнего внешнего слоя 
  ExtBottomFORs[Bus_W_FORs+1..0]  : node; -- сопадение нижнего внешнего слоя 
  IntUpFORs[Bus_W_FORs+1..0]      : node; -- сопадение верхнего внутреннего слоя 
  IntBottomFORs[Bus_W_FORs+1..0]  : node; -- сопадение нижнего внутреннего слоя 

  OT_ANDx2[FORs_NUMBER-1..0]      : node; -- И двух соседних четного и нечетного FOR-ов (упрощенная ОТ)
  OT_ORx2[FORs_NUMBER..0]         : node; -- ИЛИ упрощенных ОТ
  
  
BEGIN

-- по фронту каждого FOR-а формируем ~65нс импульс, который в дальнейшем будет учавствовать в схеме совпадения
FOR i IN 0 TO (Bus_R_FORs-1) GENERATE
   InputShaper[i].(d,clk,clr) = (DataIn_R[i],Clock,!Enable);
   InputShaper[i+24].(d,clk,clr) = (DataIn_W[i],Clock,!Enable);
END GENERATE;
FOR i IN 0 TO (FORs_NUMBER-1) GENERATE
     Data_Reg.data[i] = InputShaper[i].q;
     InputShaper[i].Shaping_Time[7..0] = InputShapingTime[7..0];
END GENERATE;

-- данные в регистр защелкиваем на каждый такт Clock-а 
Data_Reg.(clock,enable,load,sclr) = (Clock,Enable,VCC,Reset);

-- поиск совпаденияй для формирования сигнала Result
   -- поиск любой ОТ - опорной точки (совпадений по соседним FOR-ам другой сосед на антисовпадение)
        FOR i in 3 to (FORs_NUMBER-3) GENERATE
            OT_AND[i].data0 = !Data_Reg.q[i-3];
            OT_AND[i].data1 = !Data_Reg.q[i-2];
            OT_AND[i].data2 = Data_Reg.q[i-1];
            OT_AND[i].data3 = Data_Reg.q[i];
            OT_AND[i].data4 = !Data_Reg.q[i+1];
            OT_AND[i].data5 = !Data_Reg.q[i+2];
            OT_Result[i] = OT_AND[i].Result;
       END GENERATE;
            OT_AND[2].data0 = !Data_Reg.q[47];
            OT_AND[2].data1 = !Data_Reg.q[0];
            OT_AND[2].data2 = Data_Reg.q[1];
            OT_AND[2].data3 = Data_Reg.q[2];
            OT_AND[2].data4 = !Data_Reg.q[3];
            OT_AND[2].data5 = !Data_Reg.q[4];
            OT_Result[2] = OT_AND[2].Result;

            OT_AND[1].data0 = !Data_Reg.q[46];
            OT_AND[1].data1 = !Data_Reg.q[47];
            OT_AND[1].data2 = Data_Reg.q[0];
            OT_AND[1].data3 = Data_Reg.q[1];
            OT_AND[1].data4 = !Data_Reg.q[2];
            OT_AND[1].data5 = !Data_Reg.q[3];
            OT_Result[1] = OT_AND[1].Result;

            OT_AND[0].data0 = !Data_Reg.q[45];
            OT_AND[0].data1 = !Data_Reg.q[46];
            OT_AND[0].data2 = Data_Reg.q[47];
            OT_AND[0].data3 = Data_Reg.q[0];
            OT_AND[0].data4 = !Data_Reg.q[1];
            OT_AND[0].data5 = !Data_Reg.q[2];
            OT_Result[0] = OT_AND[0].Result;

            OT_AND[47].data0 = !Data_Reg.q[44];
            OT_AND[47].data1 = !Data_Reg.q[45];
            OT_AND[47].data2 = Data_Reg.q[46];
            OT_AND[47].data3 = Data_Reg.q[47];
            OT_AND[47].data4 = !Data_Reg.q[0];
            OT_AND[47].data5 = !Data_Reg.q[1];
            OT_Result[47] = OT_AND[47].Result;

            OT_AND[46].data0 = !Data_Reg.q[43];
            OT_AND[46].data1 = !Data_Reg.q[44];
            OT_AND[46].data2 = Data_Reg.q[45];
            OT_AND[46].data3 = Data_Reg.q[46];
            OT_AND[46].data4 = !Data_Reg.q[47];
            OT_AND[46].data5 = !Data_Reg.q[0];
            OT_Result[46] = OT_AND[46].Result;
            FOR i in 0 to FORs_NUMBER-1 GENERATE  
               OT_Trg[i].(d,clk) = (OT_Result[i],Clock);
             END GENERATE;
   -- 1. поиск совпадений по 2 ОТ напротив (коллениарным)     
    FOR i in 0 to Bus_W_FORs-1 GENERATE  
         ResultBus1_En[i] = OT_Trg[i].q AND OT_Trg[Bus_W_FORs+i].q;
            ResultBus1[i+1] = ResultBus1[i] OR ResultBus1_En[i];
      END GENERATE;
        ResultBus1[0] = GND;
           Coinsidence_Out[0] = ResultBus1[Bus_W_FORs];
   -- 2. поиск совпадений по 2 ОТ любым
    Summator.clock     = Clock;
    Summator.data0x[]  = OT_Trg[0].q;
    Summator.data1x[]  = OT_Trg[1].q;
    Summator.data2x[]  = OT_Trg[2].q;
    Summator.data3x[]  = OT_Trg[3].q;
	Summator.data4x[]  = OT_Trg[4].q;
	Summator.data5x[]  = OT_Trg[5].q;
	Summator.data6x[]  = OT_Trg[6].q;
	Summator.data7x[]  = OT_Trg[7].q;
	Summator.data8x[]  = OT_Trg[8].q;
	Summator.data9x[]  = OT_Trg[9].q;
	Summator.data10x[] = OT_Trg[10].q;
	Summator.data11x[] = OT_Trg[11].q;
	Summator.data12x[] = OT_Trg[12].q;
	Summator.data13x[] = OT_Trg[13].q;
	Summator.data14x[] = OT_Trg[14].q;
	Summator.data15x[] = OT_Trg[15].q;
	Summator.data16x[] = OT_Trg[16].q;
	Summator.data17x[] = OT_Trg[17].q;
	Summator.data18x[] = OT_Trg[18].q;
	Summator.data19x[] = OT_Trg[19].q;
	Summator.data20x[] = OT_Trg[20].q;
	Summator.data21x[] = OT_Trg[21].q;
	Summator.data22x[] = OT_Trg[22].q;
	Summator.data23x[] = OT_Trg[23].q;
	Summator.data24x[] = OT_Trg[24].q;
	Summator.data25x[] = OT_Trg[25].q;
	Summator.data26x[] = OT_Trg[26].q;
	Summator.data27x[] = OT_Trg[27].q;
	Summator.data28x[] = OT_Trg[28].q;
	Summator.data29x[] = OT_Trg[29].q;
	Summator.data30x[] = OT_Trg[30].q;
	Summator.data31x[] = OT_Trg[31].q;
	Summator.data32x[] = OT_Trg[32].q;
	Summator.data33x[] = OT_Trg[33].q;
	Summator.data34x[] = OT_Trg[34].q;
	Summator.data35x[] = OT_Trg[35].q;
	Summator.data36x[] = OT_Trg[36].q;
	Summator.data37x[] = OT_Trg[37].q;
	Summator.data38x[] = OT_Trg[38].q;
	Summator.data39x[] = OT_Trg[39].q;
	Summator.data40x[] = OT_Trg[40].q;
	Summator.data41x[] = OT_Trg[41].q;
	Summator.data42x[] = OT_Trg[42].q;
	Summator.data43x[] = OT_Trg[43].q;
	Summator.data44x[] = OT_Trg[44].q;
	Summator.data45x[] = OT_Trg[45].q;
	Summator.data46x[] = OT_Trg[46].q;
    Summator.data47x[] = OT_Trg[47].q;
	IF(Summator.result[5..0] >= 2) 
    	        THEN Coinsidence_Out[1] = VCC;
        	    ELSE Coinsidence_Out[1] = GND;
	END IF;
   -- 3. поиск совпадений по любому четному и нечетному FOR-у рядом сработавшим 
        FOR i in 0 to (FORs_NUMBER-2) GENERATE
            OT_ANDx2[i] = Data_Reg.q[i] AND Data_Reg.q[i+1];
           END GENERATE;
             OT_ANDx2[FORs_NUMBER-1] = Data_Reg.q[47] AND Data_Reg.q[0];
               OT_ORx2[0] = GND;
                 FOR i in 0 to (FORs_NUMBER-1) GENERATE
                      OT_ORx2[i+1] = OT_ORx2[i] OR OT_ANDx2[i];
                    END GENERATE;
                      Coinsidence_Out[2] = OT_ORx2[FORs_NUMBER];
   -- 4. поиск совпадений верхней и нижней половинками (внутреннего и внешнего слоя)
   FOR i IN 0 TO 11 GENERATE
       ExtUpFORs[i+1] = ExtUpFORs[i] OR Data_Reg.q[2*i];
          ExtBottomFORs[i+1]  = ExtBottomFORs[i] OR Data_Reg.q[Bus_W_FORs+2*i]; 
             IntUpFORs[i+1] = IntUpFORs[i] OR Data_Reg.q[((2*i)+1)];
                IntBottomFORs[i+1]  = IntBottomFORs[i] OR Data_Reg.q[Bus_W_FORs+((2*i)+1)]; 
     END GENERATE;
       ExtUpFORs[0]      = GND;
         ExtBottomFORs[0]  = GND;
            IntUpFORs[0]     = GND;
              IntBottomFORs[0] = GND;
           ResultBus4 = ExtUpFORs[12] AND ExtBottomFORs[12] AND IntUpFORs[12] AND IntBottomFORs[12];
             Coinsidence_Out[3] = ResultBus4;
   -- 5. поиск совпадений между набором четных и нечетных FOR-ов
   FOR i IN 0 TO 23 GENERATE
       EvenFOR[i+1] = EvenFOR[i] OR Data_Reg.q[2*i];
          OddFOR[i+1]  = OddFOR[i] OR Data_Reg.q[((2*i)+1)]; 
     END GENERATE;
       EvenFOR[0] = GND;
         OddFOR[0]  = GND;
           ResultBus5 = EvenFOR[24] AND OddFOR[24];
             Coinsidence_Out[4] = ResultBus5;
   -- 6. поиск совпадений по любому FOR-у
    FOR i in 0 to (FORs_NUMBER-1) GENERATE
       OR_FOR[i+1] = OR_FOR[i] OR Data_Reg.q[i]; 
          END GENERATE;
             OR_FOR[0] = GND;
                 Coinsidence_Out[5] = OR_FOR[FORs_NUMBER];

   %  FOR i in 0 to (FORs_NUMBER-1) GENERATE
       OR_FOR[i+1] = OR_FOR[i] OR OT_Trg[i].q; 
          END GENERATE;
             OR_FOR[0] = GND;
                 Coinsidence_Out[5] = OR_FOR[FORs_NUMBER];  % 
 

-- Формируем мертвое время и выход 
FOR i in 0 to 5 GENERATE
  Coinsidence_Out_Trig[i].(d,clk) = (Coinsidence_Out[i],Clock);
  DeadTimeShaper[i].(d,clk,clr) = (Coinsidence_Out_Trig[i].q,Clock,GND);
  DeadTimeShaper[i].Shaping_Time[] = TIME_OUT_IN[7..0];
  Result[i] = DFF(.d=Coinsidence_Out_Trig[i].q AND !DeadTimeShaper[i].q, .clk = Clock);
END GENERATE;

test1 = OT_Result[1];
test2 = DeadTimeShaper[0].q;
test3 = Coinsidence_Out[0];


FOR_Shaped[] = Data_Reg.q[];
DeadTime[] = DeadTimeShaper[].q; 
resultTrig[] = Coinsidence_Out_Trig[].q;

END; -- End design







%   -- 1. поиск совпадений по соседним FOR-ам + по FOR-ам на против  (коллениарным)
    FOR i in 1 to (Bus_W_FORs-1) GENERATE
       ResultBus1[i] = (Data_Reg.q[i-1] AND Data_Reg.q[i]) AND (Data_Reg.q[Bus_W_FORs+i-1] AND Data_Reg.q[Bus_W_FORs+i]);
     END GENERATE;
      ResultBus1[24] = (Data_Reg.q[47] AND Data_Reg.q[0]) AND (Data_Reg.q[23] AND Data_Reg.q[24]) ;
       FOR i in 1 to Bus_W_FORs GENERATE -- все результаты по ИЛИ между собой
          ResultBus1[i+1] = ResultBus1[i-1] OR ResultBus1[i];
         END GENERATE;
		  ResultBus1[0] = GND ;
            Coinsidence1_Out = ResultBus1[Bus_W_FORs+1];%