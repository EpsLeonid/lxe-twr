TITLE "Fast link";

INCLUDE "lpm_counter.inc" ;
INCLUDE "lpm_shiftreg.inc";
INCLUDE "Edge_Sensing.inc";
INCLUDE "lpm_mux.inc" ;

CONSTANT WORD_WIDTH       = 16; -- размер слова данных
CONSTANT PrescalerModule6  = 6;  -- делим входную частоту в 6 раз
CONSTANT PrescalerModule3  = 3;  -- делим входную частоту в 3 раза


SUBDESIGN Fast_Link
(
--
  --CommonStop                  : input;
  Clock           			      : input;  -- входная частота 150 МГц, частота работы модуля
  Bunch_Crossing_Data_Sample      : input;  -- частота оборота пучка, привязанная к общему стопу 
  Bunch_Crossing_Fast_Link_Start  : input;  -- 12.5 MHz from Bunch Crossing of Fast Link
  3xPH_Clk                        : output; -- тактовая частота для Serializer-а
  
-- Module specific signals
  Data_To_Ser[23..0]              : input; -- 24-х разрядное входное слово, отправляемое Serializer-ом
   
  SerDataOut[7..0]                : output; -- данные для Serializer-а 1 канал R
  NumberWord[1..0]                : output; -- номер слова
 
  DataBus_In[15..0]			      : input;  -- отправляемые с Внутренней Шины в Линк данные
  DataBusOut[15..0]     	      : output; -- выдаваемые на Внутреннюю Шину из Модуля данные (младшие 16бит шины R)
   
 
  Test1, Test2                    : output;
 
)

VARIABLE

  Data_Reg                    : lpm_shiftreg with (LPM_WIDTH=24,LPM_DIRECTION="unused"); -- регистр данных
  Tx_Buffer                   : lpm_shiftreg with (LPM_WIDTH=24,LPM_DIRECTION="unused"); -- регистр данных
  NofB_Counter    	          : LPM_COUNTER with ( lpm_width=4, lpm_direction="up" );   -- счетчик-указатель управление номером слова (байта) 
 
  MUX_W                       : LPM_MUX with ( lpm_size=3, lpm_width=8,lpm_widths=2 );  -- мультиплексор 24->8 разбиение 24 бит на 3 слова по 8 бит
   
  Send_Data_BUS[23..0]        : node; 
 
BEGIN

DEFAULTS
	DataBusOut[] = GND;
END DEFAULTS;

----пробные выходы ----
Test1 = Bunch_Crossing_Data_Sample;
Test2 = Bunch_Crossing_Fast_Link_Start;

--------------------

--******************** Входные регистры ********************
FOR i IN 0 TO 23 GENERATE
   Send_Data_BUS[i]   = Data_To_Ser[i];--  AND !Mask_Reg.q[i];
END GENERATE;

Data_Reg.data[23..0]  = Send_Data_BUS[23..0];
Data_Reg.clock        = Clock;   -- по такту защелкиваем информацию о сработавших секторах и энерговыделение
Data_Reg.load         = VCC;     -- регистры всегда в параллельной загрузке
Data_Reg.enable       = Bunch_Crossing_Data_Sample;  -- разрешаем защелкнуть состояние шины 

Tx_Buffer.data[23..0]  = Data_Reg.q[23..0];
Tx_Buffer.clock        = Clock;   -- по такту защелкиваем информацию о сработавших секторах и энерговыделение
Tx_Buffer.load         = VCC;     -- регистры всегда в параллельной загрузке
Tx_Buffer.enable       = Bunch_Crossing_Fast_Link_Start;  -- разрешаем защелкнуть состояние шины 


-- разбиение 24 бит шины на 3 слова по 8 бит 
FOR i IN 0 TO 3 GENERATE
  MUX_W.data[0][2*i]    = Tx_Buffer.q[2*i];
  MUX_W.data[0][2*i+1]  = !Tx_Buffer.q[2*i+1];

  MUX_W.data[1][2*i]    = Tx_Buffer.q[2*i+8];
  MUX_W.data[1][2*i+1]  = !Tx_Buffer.q[2*i+1+8];

  MUX_W.data[2][2*i]    = Tx_Buffer.q[2*i+16];
  MUX_W.data[2][2*i+1]  = !Tx_Buffer.q[2*i+1+16];
END GENERATE;
MUX_W.sel[1..0]         = NofB_Counter.q[3..2]-1; 
3xPH_Clk                = NofB_Counter.q[1];
 
-- Счетчик-указатель номера слова (8 бит) NofB_Counter
NofB_Counter.data[3..0]= B"0100";
NofB_Counter.clock	   = Clock;
NofB_Counter.sload	   = Bunch_Crossing_Fast_Link_Start;
-- *********** Здесь описана структура соединений шин данных *************
SerDataOut[7..0]       = MUX_W.result[7..0]; 
NumberWord[1..0]       = NofB_Counter.q[3..2]; -- дополнительные 2 бита номера слова для Serializer


END; -- End design
