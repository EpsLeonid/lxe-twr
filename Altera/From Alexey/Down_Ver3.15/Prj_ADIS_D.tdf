TITLE " ADIS Project" ;

INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "lpm_counter.inc" ;
INCLUDE "LightPulser.inc";
INCLUDE "Edge_Sensing.inc";
INCLUDE "CAMAC.inc";
INCLUDE "Arbiter.inc";
INCLUDE "Phase_Switch_DD.inc";
INCLUDE "CMD3_DAQ_LINK.inc";
INCLUDE "CMD3_UP_Link.inc";
INCLUDE "SILICON_ID.inc";
INCLUDE "POSS128W.inc";
INCLUDE "ErrorCounters.inc";
INCLUDE "Bunch_Crossing_adjust.inc";
INCLUDE "ADIS.inc";
INCLUDE "Basic_Trig.inc";
INCLUDE "Down_Bridge.inc";
INCLUDE "Ref_Freq_Gen.inc";
INCLUDE "Delay_Line.inc";
INCLUDE "ADDER8_16.inc";


INCLUDE "Test_RAM.inc";

Constant Test_MEM_Offset   	  = H"2000" ;
Constant Test_MEM_Size        = 256;

Constant Link_IFace_Offset 	  = H"0C00" ; -- Commad List 3072
Constant Link_IFace_Size  	  = 1024 ;

Constant ErrorCounters_Offset = H"1400" ;
Constant ErrorCounters_Size	  = 16;

Constant POSS_Offset		  = H"1600" ;
Constant POSS_Size			  = 128;

Constant ID_Offset		 	  = H"1800" ; 
Constant ID_Size  			  = 16 ;

--Constant BasicTrigger_Offset  = H"8000" ; 

Constant Bunch_Crossing_25_Offset= H"4000"; -- 16384
Constant Bunch_Crossing_12_5_Offset= H"4002";

Constant ADIS_Offset          = H"5000" ;
Constant ADIS_CH_Offset       = H"200" ;
Constant ADIS_Size            = 270;

Constant Sum_Ctrl_Reg_Offset  = H"7200" ;


CONSTANT ADC_Bits             = 10;  -- разрядность АЦП
CONSTANT NUM_CH_ADIS          = 8;
CONSTANT DeviceNumber         = 5 + NUM_CH_ADIS + 1+3;   -- число устройст доступных для чтения/записи
CONSTANT MasterDeviceNumber   = 3;   -- число мастер-устройств в проекте


SUBDESIGN Prj_ADIS_D
(
 -- сигналы линка
   Link_TxRx                   : output; -- сигнал направления передачи
   Link_Data                   : bidir;  -- последовательный вход/выход данных линка
   Wire_Data                   : bidir;  -- последовательный вход/выход данных 1-wire
 -- Входная частота  
   FLCLK                       : input ; -- внешняя частота с кварца (25 МГц)
   Phase0                      : input ; -- внешняя частота с линка (25МГц)
   SW_Ph                       : output; -- управление мультиплексором выбора частоты между FLCLK и Phase0
   SW_FL                       : output; -- управление мультиплексором выбора частоты между FLCLK и Phase0
   PLL_OE                      : output; -- разрешение выдачи сигнала на выход PLL 
   PLL_S0                      : output; -- Установка множителя частоты
   PLL_S1                      : output; -- для PLL (4)
   In_Phase                    : input ; -- входная, выбраная между FLCLK и Phase0, умноженная частота с внешнего PLL 
 
     
 -- Индикаторы
   LedR, LedG                  : bidir;  -- идикаторы
   LedErr,LedPhase             : output;
   
 -- КАМАК интерфейс
   CAMAC_W[16..1]              : input; --bidir;
   CAMAC_R[16..1]              : bidir; 
   CAMAC_A[4..1]               : input;
   CAMAC_F[4..0]               : input; 
   CAMAC_N, CAMAC_B            : input;
   CAMAC_S1, CAMAC_S2          : input;
   CAMAC_Q, CAMAC_X, CAMAC_L   : output; 

-- Входные данные с АЦП
   ADC_In_Data[NUM_CH_ADIS-1..0][ADC_Bits-1..0] : input;

-- Выход триггера
   Trigger_Out                 : output;

-- POSS
   POSS_Dummy_In	           : input;	-- Pin 124 должен находиться в лог. 1 (через резистор к питанию)

-- Шина для обмена между Альтерами
   Alt_Data_Bus[15..0]         : bidir;
   Alt_Direct                  : output;
   Alt_Strobe                  : output;
   Alt_Target_Ready            : input;
   Alt_Link_Message            : output;
   Alt_Sync                    : output;

-- Тестовые пины
  -- pin131               : output;
   
)

VARIABLE

-- 1. Тактовые частоты и управление частотами   
   CLK100, CLK25, Bridge_SYNC    : node; -- внутреннии частоты
   Phase_Switcher                : Phase_Switch_DD with (FmaxThresh=26000, FminThresh=23000);
    
-- 2. Индикаторы (Duration в mc, RefClock в kHz)
   LightR,LightG                 : LightPulser with (Duration = 20, RefClock = 1); 
   Ref_Clk_Gen                   : Ref_Freq_Gen with (GlobalClockFreq = 100, RefClockOut = 1);
   
-- 3.  Arbiter 
   Bus_Arbiter                   : Arbiter with ( DeviceMaxNumber=MasterDeviceNumber, ClockMaxTimout = 32);
   Address_Line[17..0] 		     : node ;  -- 16 битный адрес + 1 бит mem/reg (VCC=> mem) + 1 бит read/write (VCC=>write)
   Address_Line_[17..0] 	     : node ;  -- 16 битный адрес + 1 бит mem/reg (VCC=> mem) + 1 бит read/write (VCC=>write)
   Addr_Line_Reg[17..0]  	     : DFF ;
   Data_Line[15..0]    		     : node ;
   Data_Line_[15..0]  		     : node ;
   Data_Line_Reg[15..0]  	     : DFF ;
   Address_Valid       		     : node ;
   Target_Ready        		     : node ;
   Data_Strobe        		     : node ;

-- 4. CAMAC 
   CAMAC_IFace                   : CAMAC with ( RefClock = 100); -- 100MHz timing

-- 5. Slow link
   Link_IFace                    : CMD3_UP_Link with (RefClock = 100);
   Link_IFace_CS			     : node;

-- 7. 1-wire ID
   ID                            : SILICON_ID with (RefClock = 100, LinkSpeed = 10);
   ID_CS					     : node;

-- 8. Входные данные с АЦП
   ADISChannel[NUM_CH_ADIS-1..0] : ADIS;
   ADIS_CS[NUM_CH_ADIS-1..0]     : node;
-- суммирование групп внутри АДИСа
   Energy                        : ADDER8_16;
   Energy_Reg                    : lpm_shiftreg with (LPM_WIDTH = 13);  
   Sum_Data_BUS[7..0]            : node;
   Sum_Ctrl_Reg_CS               : node;
   Sum_Ctrl_Reg                  : lpm_shiftreg with (LPM_WIDTH = 5);
   

-- 9. POSS 
   POSS_IFace			         : POSS128W with (RefClock = 100);
   POSS_IFace_CS			     : NODE;

-- 10. Error counter
   ErrorCounters_IFace		     : ErrorCounters;
   ErrorCounters_IFace_CS	     : NODE;

-- 10. Компоратор адреса устройств 
   Dev_Sel_[DeviceNumber-1..0]   : DFF; --DFFEAS ;  -- Clocked comparator output for Select & Target_Ready		

-- 11. общий СТОП
   Event_ES_Beg                  : Edge_Sensing;
   Event_ES_End                  : Edge_Sensing; 
   Event_Trig                    : SRFF;
   LinkMsg_Trig                  : DFF;

-- 12. Basic Trigger
 --  BTrigger                      : Basic_Trig with (NUM_CH = NUM_CH_ADIS);
 --  B_Trig_CS                     : node;

-- 13. Bridge
   D_Bridge                      : Down_Bridge;
 --  Alt_Sync_DFF                  : DFF;
 --  Alt_Strobe_DFF                : DFF;
  -- Alt_Direct_DFF                : DFF;
 --  Alt_Data_Bus_Out_Buff         : lpm_shiftreg with (LPM_WIDTH = 16, LPM_DIRECTION="unused");
 --  Alt_Data_Bus_In_Buff          : lpm_shiftreg with (LPM_WIDTH = 16, LPM_DIRECTION="unused");
   
-- 14. FORs
   Bunch_Crossing_12_5           : Bunch_Crossing_adjust with (Cavity_to_Bunch_Ratio = 8, Number_of_Channel=1);
   Bunch_Crossing_25             : Bunch_Crossing_adjust with (Cavity_to_Bunch_Ratio = 4, Number_of_Channel=1);
   Bunch_Crossing_25_CS          : node;
   Bunch_Crossing_12_5_CS        : node;
   
-- 15. Test
   RAMData                       : Test_RAM;
   Test_MEM_CS                   : node;

BEGIN -- Начало описания проекта

 DEFAULTS
   Target_Ready    = GND;
 END DEFAULTS;

--Alt_Link_Message = GND;
--Alt_Sync = GND;
--Alt_Strobe = GND;
--Alt_Direct = GND;
 --ADISChannel[0].tsSm;

--************************** PLL section ***************************
  CLK100 = Global(In_Phase);  -- 100 МГц
 
-- настройки PLL
  PLL_OE = GND;
  PLL_S0 = GND; -- pin 1
  PLL_S1 = VCC; -- pin 240

-- Автоматический выбор входной частоты (между кварцом и линком)
  Phase_Switcher.Reference_Clock  = FLCLK ; -- сравниваем частоты с кварца
  Phase_Switcher.Link_Phase0      = Phase0 ; -- и линка в течении 1 мс
  Phase_Switcher.Reset            = GND; 
 
  SW_Ph = !Phase_Switcher.LinkClock_Enabled;
  SW_FL =  Phase_Switcher.LinkClock_Enabled;

 -- SW_Ph = GND;
 -- SW_FL = VCC;

--***************************** Bridge *******************************
  D_Bridge.(Clock, SyncClk) = (CLK100, Bridge_SYNC);

  D_Bridge.Addr_Bus_In[] = Address_Line[15..0];
  D_Bridge.Data_Bus_In[] = Data_Line[];
  D_Bridge.FOR_Bus_In[]  = ADISChannel[].Start;
  D_Bridge.Esum_Bus_In[] = Sum_Data_BUS[];
  D_Bridge.RW_Cycle      = Address_Line[17];
  D_Bridge.DataStrobeIn  = Data_Strobe;
  D_Bridge.Alt_Target_Ready = Alt_Target_Ready;
  
  Alt_Sync               = D_Bridge.Sync;
  Alt_Strobe             = D_Bridge.DataStrobe_Alt;
  Alt_Direct             = Address_Line[17];
 
  D_Bridge.Alt_Data_Bus_In[] = Alt_Data_Bus[];--DDR_Buffer_I.dataout_l[];
  FOR i IN 0 TO 15 GENERATE
     Alt_Data_Bus[i] = TRI(.in = D_Bridge.Alt_Data_Bus_Out[i], .oe = D_Bridge.Alt_Direct); 
  END GENERATE;

  Alt_Link_Message = Link_IFace.LinkMessage;

--*************************** Индикаторы *****************************
  Ref_Clk_Gen.Global_Clock = CLK100;
  LightG.(Global_Clock,event,Ref_Clock) = (CLK100, Link_IFace.LinkMessage, Ref_Clk_Gen.Ref_Clock_Out);
  LightR.(Global_Clock,event,Ref_Clock) = (CLK100, CAMAC_IFace.Error OR     -- светодиод вывода ошибок
                                           Link_IFace.Error, Ref_Clk_Gen.Ref_Clock_Out); 
  --LedR = LightR.LightOut;
  --LedG = LightG.LightOut;
  LedR = ADISChannel[0].Test1;
  LedG = ADISChannel[0].Test2;
  Trigger_Out = ADISChannel[0].Start;

  LedPhase = Phase_Switcher.LinkClock_Enabled;
  LedErr   = CAMAC_IFace.Error OR  Link_IFace.Error;
  

--*************** CAMAC Interface I/O connection *******************
  CAMAC_IFace.N   = !CAMAC_N  ; -- Input from Pin54
  CAMAC_IFace.B   = !CAMAC_B  ; -- Input from Pin13
  CAMAC_IFace.S1  = !CAMAC_S1 ; -- Input from Pin58
  CAMAC_IFace.S2  = !CAMAC_S2 ; -- Input from Pin60
  CAMAC_IFace.A[] = !CAMAC_A[]; -- Input from Pin 48,50,53,55
  CAMAC_IFace.F[] = !CAMAC_F[]; -- Input from Pin 42,43,44,45,46
--
  CAMAC_IFace.clock = CLK100;
	
  CAMAC_X  = CAMAC_IFace.X1;--nX1 ; -- Output to Pin47
  CAMAC_Q  = CAMAC_IFace.Q ; --nQ  ; -- Output to Pin59
  CAMAC_L  = CAMAC_IFace.LAM ; -- Output to Pin56

--	Bus_Arbiter.BARQ[3] = CAMAC_IFace.AccessRequest; -- High priority input
  CAMAC_IFace.AccessGranted      = Bus_Arbiter.BAGD[MasterDeviceNumber-1] ;
  CAMAC_IFace.DataBusStrobe      = Data_Strobe ;
  CAMAC_IFace.DataBus_In[]       = Data_Line[] ;
	
-- "Standard" Status Register connections	
  CAMAC_IFace.LinkClockCaptured  = VCC ;
  CAMAC_IFace.LinkActive         = GND ;
  CAMAC_IFace.Link_Error         = GND ;
  CAMAC_IFace.Busy_on_Digitizing = GND ; --LAM_Data.q; -- Блок занят внутренними вычислениями и не выставляет LAM
  CAMAC_IFace.Busy_on_Copy       = GND ; 
  CAMAC_IFace.DeadTime           = GND ;
 -- CAMAC_IFace.LAM_Requiest       = GND ;

-- Соединение шин данных CAMAC
    FOR i IN 1 TO 16 Generate
        CAMAC_R[i]      = OPNDRN(!CAMAC_IFace.R[i]);
   	END GENERATE;
   
	FOR i IN 1 TO 16 Generate
        CAMAC_IFace.W[i]   = !CAMAC_W[i];
	END GENERATE;
--**********************Slow Link Interface I/O connection ***********************
     -- input
    Link_IFace.Bus_Clock = CLK100;
    Link_IFace.(Clock , DataBus_In[15..0], AccessGranted      , DataBusStrobe) =
               (CLK100,   Data_Line[]    , Bus_Arbiter.BAGD[0], Data_Strobe);
    Link_IFace.Reset			= GND;
    Link_IFace.DirectIn			= Address_Line[17] ;
    Link_IFace.AddrBus_In[9..0]	= Address_Line[9..0];
    Link_IFace.Select			= Dev_Sel_[1].q ;

    -- Соединение шин данных Link-а 
    Link_TxRx				= Link_IFace.Link_TxRx; -- направление передачи
    Link_IFace.Link_Data_in = !Link_Data; -- полученные данные
    Link_Data               = TRI(.in = !Link_IFace.Link_Data_out, .oe = Link_IFace.Link_TxRx); -- данные для передачи

--******************************* SILICON ID ***********************************
    ID.(Clock , DataBus_In[15..0], DataBusStrobe) =
       (CLK100,   Data_Line[]    , Data_Strobe);
    ID.Reset			= GND;
    ID.DirectIn			= Address_Line[17];
    ID.AddrBus_In[4..0]	= Address_Line[4..0];
    ID.Select			= Dev_Sel_[3].q;

    ID.Wire_Data_in     = Wire_Data; -- полученные данные
    Wire_Data           = OPNDRN(.in = !ID.Wire_Data_out); -- данные для передачи

--********************** ADIS Interface I/O connection ***********************
     FOR i IN 0 TO (NUM_CH_ADIS-1) GENERATE
      ADISChannel[i].(Clock, Event) = (CLK100, CLK25); 
      FOR j IN 0 TO (ADC_Bits-1) GENERATE
        ADISChannel[i].In_Data[j] = !ADC_In_Data[i][j];--DDR_IO_Buffer.dataout_h[i*ADC_Bits+j]; 
      END GENERATE;
      ADISChannel[i].LinkMsg = Event_Trig.q ;

      ADISChannel[i].(DataBus_In[15..0], DataBusStrobe) =
                     (Data_Line[]      , Data_Strobe  );
      ADISChannel[i].DirectIn		  = Address_Line[17];
      ADISChannel[i].AddrBus_In[8..0] = Address_Line[8..0];
      ADISChannel[i].Select			  = Dev_Sel_[5+i].q;
      
      ADISChannel[i].SyncPulse        = GND;
    END GENERATE;


   --------------------------------- Energy sum --------------------------------
    Sum_Ctrl_Reg.(data[],clock,enable,load) = (Data_Line[4..0], CLK100,  Data_Strobe and Dev_Sel_[16].q and Address_Line[17],VCC);
    
    CASE Sum_Ctrl_Reg.q[4..0] IS
	    WHEN b"00000"  => Sum_Data_BUS[7..0] = Energy_Reg.q[7..0]; 
	    WHEN b"00001"  => Sum_Data_BUS[7..0] = Energy_Reg.q[8..1]; 
	    WHEN b"00010"  => Sum_Data_BUS[7..0] = Energy_Reg.q[9..2]; 
	    WHEN b"00100"  => Sum_Data_BUS[7..0] = Energy_Reg.q[10..3]; 
	    WHEN b"01000"  => Sum_Data_BUS[7..0] = Energy_Reg.q[11..4]; 
	    WHEN b"10000"  => Sum_Data_BUS[7..0] = Energy_Reg.q[12..5]; 
        WHEN OTHERS    => Sum_Data_BUS[7..0] = Energy_Reg.q[12..5];	
    END CASE;
   
   
    Energy.clock    = CLK100;
    Energy.data0x[] = ADISChannel[0].Amp[];
    Energy.data1x[] = ADISChannel[1].Amp[];
    Energy.data2x[] = ADISChannel[2].Amp[];
    Energy.data3x[] = ADISChannel[3].Amp[];
    Energy.data4x[] = ADISChannel[4].Amp[];
    Energy.data5x[] = ADISChannel[5].Amp[];
    Energy.data6x[] = ADISChannel[6].Amp[];
    Energy.data7x[] = ADISChannel[7].Amp[];
    
    Energy_Reg.data[] = Energy.result[]; -- 13 bits
    Energy_Reg.(clock,enable,load) = (CLK100,!Event_Trig.q,VCC); 
--********************************* POSS ***************************************
	POSS_IFace.clock 			 = CLK100;
	POSS_IFace.DataBusStrobe	 = Data_Strobe ;
	POSS_IFace.AddrBus_In[15..0] = Address_Line[15..0];
	
	POSS_IFace.AccessGranted	 = Bus_Arbiter.BAGD[1] ;
-- Project Bus Port, Slave
	POSS_IFace.DirectIn	  		 = Address_Line[17] ;
	POSS_IFace.Select			 = Dev_Sel_[4].q ;
		
--	Special Port
	POSS_IFace.Dummy_In	         = POSS_Dummy_In; -- Input from any unused pin


--***************************** Общий СТОП *********************************	
    Event_ES_Beg.(d,clk) = (!Link_Data AND !Event_Trig.q, CLK100); -- Определение стартового бита
    LinkMsg_Trig.(d,clk) = (!Link_IFace.LinkMessage, CLK100);    
    Event_ES_End.(d,clk) = (LinkMsg_Trig.q, CLK100);
    Event_Trig.(S,clk,R) = (Event_ES_Beg.q, CLK100, Event_ES_End.q);

--***************************** Bunch_Crossing adjust *********************************	
    Bunch_Crossing_25.(Cavity_Clock, BusClock, Bunch_Crossing, DataBus_In[15..0], DataBusStrobe, AddrBus_In[0]) =
                      (CLK100      , CLK100  , Event_ES_Beg.q,   Data_Line[]    , Data_Strobe  , Address_Line[0] );
    Bunch_Crossing_25.DirectIn		= Address_Line[17];
    Bunch_Crossing_25.Select		= Dev_Sel_[13].q;
   
    Bunch_Crossing_12_5.(Cavity_Clock, BusClock, Bunch_Crossing, DataBus_In[15..0], DataBusStrobe, AddrBus_In[0]) =
                          (CLK100    , CLK100  , Event_ES_Beg.q,   Data_Line[]    , Data_Strobe  , Address_Line[0]);
    Bunch_Crossing_12_5.DirectIn	= Address_Line[17];
    Bunch_Crossing_12_5.Select		= Dev_Sel_[13].q;

    Bridge_SYNC = Bunch_Crossing_12_5.Start_Enable[];  -- 12.5 МГц привязанные к стартовому биту
    CLK25       = Bunch_Crossing_25.Start_Enable[];    -- 25 МГц привязанные к стартовому биту	

--********************************* Arbiter ************************************
-- Project Bus Port, common
	ErrorCounters_IFace.clock 			=	CLK100;
	ErrorCounters_IFace.AddrBusIn[3..0]	=	Address_Line[3..0];
-- Project Bus Port, Slave
	--ErrorCounters_IFace.Select			= 	Dev_Sel_[2].q ;

    ErrorCounters_IFace.ErrorInputs[0]	=	CAMAC_IFace.Error;
    ErrorCounters_IFace.ErrorInputs[1]	=	Bus_Arbiter.ErrorLight;
    ErrorCounters_IFace.ErrorInputs[2]	=	GND;
    ErrorCounters_IFace.ErrorInputs[3]	=	Link_IFace.Error;
    ErrorCounters_IFace.ErrorInputs[4]	=	GND;
    ErrorCounters_IFace.ErrorInputs[5]	=	GND;
    ErrorCounters_IFace.ErrorInputs[6]	=	GND;
	ErrorCounters_IFace.ErrorInputs[7]	=	GND;
	ErrorCounters_IFace.ErrorInputs[8]	=	CAMAC_IFace.AccessRequest;
	ErrorCounters_IFace.ErrorInputs[9]	=	Link_IFace.AccessRequest;
	ErrorCounters_IFace.ErrorInputs[10]	=	POSS_IFace.AccessRequest;


--********************************* Arbiter ************************************
    Bus_Arbiter.BARQ[2] = CAMAC_IFace.AccessRequest; -- запрос на предастовление шины данных
	Bus_Arbiter.BARQ[0] = Link_IFace.AccessRequest;
	Bus_Arbiter.BARQ[1] = POSS_IFace.AccessRequest;
	
	Bus_Arbiter.clock       = CLK100;
	Bus_Arbiter.Reset       = GND;
	Bus_Arbiter.TargetReady = Target_Ready;
	
	Address_Valid      =  Bus_Arbiter.AddressValid ; -- адрес подтвержден
	Data_Strobe        =  Global (Bus_Arbiter.DataStrobe) ; -- защелкиваем данные

 --  Dev_Sel_OR[0] = GND;
  -- FOR i IN 0 TO DeviceNumber-1 GENERATE
   --  Dev_Sel_OR[i+1] = Dev_Sel_OR[i] OR Dev_Sel_[i].q;
     --Target_Ready = Dev_Sel_[i].q;
  -- END GENERATE; 
  -- Target_Ready = Dev_Sel_OR[DeviceNumber-1] OR D_Bridge.Target_Ready_Out;
   Target_Ready = Dev_Sel_[0].q OR
                  Dev_Sel_[1].q OR
                  Dev_Sel_[2].q OR
                  Dev_Sel_[3].q OR
                  Dev_Sel_[4].q OR
                  Dev_Sel_[5].q OR
                  Dev_Sel_[6].q OR
                  Dev_Sel_[7].q OR
                  Dev_Sel_[8].q OR
                  Dev_Sel_[9].q OR
                  Dev_Sel_[10].q OR
                  Dev_Sel_[11].q OR
                  Dev_Sel_[12].q OR
                  Dev_Sel_[13].q OR
                  Dev_Sel_[14].q; --D_Bridge.Target_Ready_Out OR
        


--  Определение устройства которому разрешен доступ на шину данных
--	Address_Line[17..0]  -- 16 битный адрес + 1 бит mem/reg (VCC=> mem) + 1 бит read/write (VCC=>write)
CASE Bus_Arbiter.BAGD[2..0] IS
	WHEN b"100"  => Address_Line_[15..0] = CAMAC_IFace.AddrBusOut[15..0] ; 
					Address_Line_[17]    = CAMAC_IFace.DirectOut ; -- направление передачи
	WHEN b"001"  => Address_Line_[15..0] = Link_IFace.AddrBusOut[15..0] ;
	                Address_Line_[17]    = Link_IFace.DirectOut ; -- направление передачи данных, на внутреннюю шину или с нее, по умолчанию =GND, передача от внутренних ресурсов платы Модуль,
	WHEN b"010"  => Address_Line_[15..0] = POSS_IFace.AddrBusOut[] ;
					Address_Line_[17]    = POSS_IFace.DirectOut ;
	WHEN OTHERS  =>	Address_Line_[15..0] = GND; -- b"0000000001010101";-- куда писать данные с линка
	                Address_Line_[17]    = GND; -- направление передачи
END CASE;

-- определение Slave-устройства с которым будет происходить общение (память или регистр)
IF ( (Address_Line[15..0] >= Test_MEM_Offset) AND (Address_Line[15..0] <= Test_MEM_Offset + Test_MEM_Size) ) 
  THEN 	Test_MEM_CS   = VCC;
  ELSE 	Test_MEM_CS   = GND;
END IF;
IF ( (Address_Line[15..0] >= Link_IFace_Offset) AND (Address_Line[15..0] <= Link_IFace_Offset + Link_IFace_Size) ) 
  THEN Link_IFace_CS  = VCC ;
  ELSE Link_IFace_CS  = GND ;
END IF;
IF ( (Address_Line[15..0] >= ID_Offset) AND (Address_Line[15..0] <= ID_Offset + ID_Size) ) 
  THEN ID_CS  = VCC ;
  ELSE ID_CS  = GND ;
END IF;
IF ((Address_Line[15..0] >= ErrorCounters_Offset) AND ((ErrorCounters_Offset + ErrorCounters_Size) >= Address_Line[15..0]) ) 
  THEN ErrorCounters_IFace_CS = VCC ; 
  ELSE ErrorCounters_IFace_CS = GND ; 
END IF ;
IF ((Address_Line[15..0] >= POSS_Offset) AND ((POSS_Offset + POSS_Size) >= Address_Line[15..0]) ) 
  THEN POSS_IFace_CS   = VCC ;
  ELSE POSS_IFace_CS   = GND ; 
END IF ;
FOR i IN 0 TO (NUM_CH_ADIS-1) GENERATE
  IF ( (Address_Line[15..0] >= ADIS_Offset + ADIS_CH_Offset*i) AND (Address_Line[15..0] <= ADIS_Offset + ADIS_CH_Offset*i + ADIS_Size) ) 
    THEN 	ADIS_CS[i]   = VCC;
    ELSE 	ADIS_CS[i]   = GND;
  END IF;
END GENERATE;
IF (Address_Line[15..0] == Bunch_Crossing_25_Offset)
  THEN  Bunch_Crossing_25_CS = VCC;
  ELSE 	Bunch_Crossing_25_CS = GND;
END IF;
IF (Address_Line[15..0] == Bunch_Crossing_12_5_Offset)
  THEN  Bunch_Crossing_12_5_CS = VCC;
  ELSE 	Bunch_Crossing_12_5_CS = GND;
END IF;
IF (Address_Line[15..0] == Sum_Ctrl_Reg_Offset)
  THEN  Sum_Ctrl_Reg_CS = VCC;
  ELSE 	Sum_Ctrl_Reg_CS = GND;
END IF;

			
Dev_Sel_[0].d  = Test_MEM_CS;
Dev_Sel_[1].d  = Link_IFace_CS;
Dev_Sel_[2].d  = ErrorCounters_IFace_CS;
Dev_Sel_[3].d  = ID_CS;
Dev_Sel_[4].d  = POSS_IFace_CS;
Dev_Sel_[13].d = Bunch_Crossing_25_CS;
Dev_Sel_[14].d = D_Bridge.Target_Ready_Out;
Dev_Sel_[15].d = Bunch_Crossing_12_5_CS;
Dev_Sel_[16].d = Sum_Ctrl_Reg_CS;

FOR i IN 0 TO (NUM_CH_ADIS-1) GENERATE
  Dev_Sel_[5+i].d  = ADIS_CS[i];
END GENERATE;

FOR i IN 0 TO DeviceNumber-1 GENERATE
Dev_Sel_[i].clrn = Address_Valid ; -- Dev_Select is enabled while Address_Valid=VCC
Dev_Sel_[i].clk  = CLK100;
END GENERATE; 
-- определение направления передачи
IF Address_Line[17] THEN   -- Мастер-устройство предоставляет данные
	CASE  Bus_Arbiter.BAGD[MasterDeviceNumber-1..0] IS          -- Мультиплексор выбора Master-устройства 
	    WHEN b"100" => Data_Line_[] = CAMAC_IFace.DataBusOut[] ;
	    WHEN b"001" => Data_Line_[] = Link_IFace.DataBusOut[] ;
  	    WHEN b"010" => Data_Line_[] = POSS_IFace.DataBusOut[] ;
 	END CASE;
  ELSE   -- Мастер-устройство требует данные 
	CASE Dev_Sel_[DeviceNumber-1..0].q IS     -- Мультиплексор выбора Slave-устройства
    	WHEN b"00000000000000001" => Data_Line_[] = RAMData.q[];
        WHEN b"00000000000000010" => Data_Line_[] = Link_IFace.DataBusOut[];
        WHEN b"00000000000000100" => Data_Line_[] = ErrorCounters_IFace.DataBusOut[];
        WHEN b"00000000000001000" => Data_Line_[] = ID.DataBusOut[];
    	WHEN b"00000000000010000" => Data_Line_[] = POSS_IFace.DataBusOut[];
        WHEN b"00000000000100000" => Data_Line_[] = ADISChannel[0].DataBusOut[];
        WHEN b"00000000001000000" => Data_Line_[] = ADISChannel[1].DataBusOut[];
        WHEN b"00000000010000000" => Data_Line_[] = ADISChannel[2].DataBusOut[];
        WHEN b"00000000100000000" => Data_Line_[] = ADISChannel[3].DataBusOut[];
        WHEN b"00000001000000000" => Data_Line_[] = ADISChannel[4].DataBusOut[];
        WHEN b"00000010000000000" => Data_Line_[] = ADISChannel[5].DataBusOut[];
        WHEN b"00000100000000000" => Data_Line_[] = ADISChannel[6].DataBusOut[];
        WHEN b"00001000000000000" => Data_Line_[] = ADISChannel[7].DataBusOut[];
        WHEN b"00010000000000000" => Data_Line_[] = Bunch_Crossing_25.DataBusOut[];
        WHEN b"00100000000000000" => Data_Line_[] = D_Bridge.Data_Bus_Out[];
        WHEN b"01000000000000000" => Data_Line_[] = Bunch_Crossing_12_5.DataBusOut[];
        WHEN b"10000000000000000" => Data_Line_[4..0] = Sum_Ctrl_Reg.q[];
        
        WHEN OTHERS             => Data_Line_[] = GND; 
 	END CASE;
END IF;

Data_Line_Reg[].d   = Data_Line_[];
Data_Line_Reg[].clk = CLK100;
Data_Line[]         = Data_Line_Reg[].q;

Address_Line_[16]   = VCC;
Addr_Line_Reg[].d   = Address_Line_[];
Addr_Line_Reg[].clk = CLK100;
Address_Line[]      = Addr_Line_Reg[].q;



-- ************************* Регистры, память данных *******************************
RAMData.(address[6..0]     , clock  , data[15..0]  , wren) =
        (Address_Line[6..0], CLK100 , Data_Line[]  , Data_Strobe and Dev_Sel_[0].q and Address_Line[17]); 

END;  -- Конец описания проекта

