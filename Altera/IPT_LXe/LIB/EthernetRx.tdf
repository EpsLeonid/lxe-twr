INCLUDE "crc32";
INCLUDE "lpm_counter";


SUBDESIGN  EthernetRx
(
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- RECEIVER section
--Ready               : input ;   -- ???? разрешение приема данных

RX_CLK	            : INPUT;    -- Clock       from the Rx channel of Eth_Controller
RX_DV	            : INPUT;    -- "DataValid" from the Rx channel of Eth_Controller
COL                 : INPUT;    -- "Collision"     -//-
CRS                 : INPUT;    -- "CarrierSense"  -//-
RXD[3..0]           : INPUT;    -- Data half-Byte from the Rx chan of Eth_Controller

Saddr[47..0]        : input ;   -- This_Device' address (used as SourceAddr 
                                        -- in the reply packets)
RxWaitSFD           : output;   -- flag:  Waiting for "StartFrameDelimiter"
RxDestAddr          : output;   -- flag:  DestinationAddr is being received
RxSourAddr          : output;   -- flag:  SourceAddr is being received
RxPkLength          : output;   -- flag:  Length of Data Block is being received
RxDataBlck          : output;   -- flag:  Block of Data is being received
RxFrameCRC          : OUTPUT;   -- flag:  Frame Check Sequence is being received
RxEndFrame          : output;   -- прием фрейма завершен
Receive_OK          : output;   -- флаг =1 - данные приняты корректно

RxCount[15..0]      : OUTPUT;   -- Cycle Counter's outputs

Daddr[47..0]        : output;   -- -- DestinationAddr for the reply packet
RxLength[15..0]     : output;   -- длина принятого блока данных (MSbit всегда = 0)!
RxData[3..0]        : OUTPUT;   -- half-Byte of received data, registered

Test[4..1]          : output;
)

VARIABLE
RX_DV_FF,  
RxD_Reg[3..0], 
COL_FF, CRS_FF      : DFF ;

Rx_DV1, RxInit      : node ; 
ChkDaddr            : DFFE ;
Daddr[47..0]        : DFFE ;    -- a Reg for latching and storing the DestAddr

RxLength[15..0]     : DFFE ;
RxEndFrame          : DFFE ; 

-- Main Cycle Counter
CtReceiv            : LPM_COUNTER with ( lpm_width=16, lpm_direction="up" );
CtReceiv_sclr       : node;     -- logic node

-- Main State Machine :
RxState             : MACHINE with STATES (stIdle,  RxChkPream, RxWaitSFD,
                RxDestAddr, RxSourAddr, RxPkLength, RxDataBlck, RxFrameCRC);

crcr                : crc32;
Receive_OK          : NODE;
	
BEGIN
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
(RX_DV_FF, RxD_Reg[], COL_FF, CRS_FF ).clk = RX_clk;
RX_DV_FF.d  = RX_DV;
COL_FF.d    = COL;
CRS_FF.d    = CRS;
	
RxD_Reg[].d = RXD[]; 
RxData[]    = RxD_Reg[];        -- transfer the registered Rx' data to Main Project

Rx_DV1 = DFF(.D= RX_DV_FF, .clk=RX_clk);
RxInit = DFF(.D=(RX_DV_FF & !RX_DV1), .clk=RX_clk); -- 1-clk pulse at the Beg_of_Receiv

-- "Frame Check Sequence" handling and CRC check : 
crcr.d[]    = RxD_Reg[];
crcr.clk    = RX_clk;
crcr.clk_en = VCC;              -- странно !
--crcr.sclr   = defined in the State Machine
Receive_OK  = crcr.crc_ok; 

-- Main Cycle Counter :
CtReceiv.clock  = RX_clk;
CtReceiv.sclr   = CtReceiv_sclr;    -- defined in the StateMachine
RxCount[]       = CtReceiv.q[];
	
RxEndFrame.clk  = RX_clk;   

-- ATTENTION !!  
-- Как видно из порядка подставления 4-битных "полу-байтов" на шину SendData 
-- (см. "trans_eth.tdf"), от каждого поля (напр., 6-байтный DestAddr) или слова 
-- (напр., 2-байтный PacketLength) 
-- байты передаются начиная со Старшего и кончая Младшим.  
-- Контроллер принимает биты каждого байта начиная с LSB и заканчивая MSB, и выставляет 
-- на RXD[3..0] сначала Младший полу-байт, потом Старший полу-байт от каждого Байта. 

-- MAIN STATE MACHINE which handles the proceeding of Receiving Cycle :
RxState.clk = RX_CLK;
    --smr.reset    = reset;    -- reset to "stIdle" state

CASE  RxState  IS
    WHEN stIdle =>      -- The INITIAL STATE is "Idle" - no signal detected. 
                    -- stIdle =1
                    -- When RX_DV appears => 
        --IF (RX_DV_FF AND Ready) Then    -- When RX_DV_FF flips to =1, ..
        IF (RX_DV_FF == VCC)            -- When RX_DV_FF flips to =1, ..
            Then  RxState = RxChkPream; -- .. jump (by next _/RX_CLK) to check if it is Preamble
                  CtReceiv_sclr = VCC; 
        End IF;
			
    WHEN  RxChkPream => -- checking if "Preamble" has begun :
                        -- any (half-Byte = H"5") is being searched for
                    -- stCcheckPreamble =1, CtReceiv =00, 
            CtReceiv_sclr = VCC;
        IF (RX_DV_FF AND RxD_Reg[]==H"5")   -- IF  Preamble detected, ..
            Then  RxState = RxWaitSFD;      -- .. jump (by next _/RX_CLK) to wait for SFD
        ELSIF  RX_DV_FF == VCC              -- IF  Preamble not detected yet, ..
            Then  RxState = RxChkPream;     -- .. continue waiting for Preamble
        ELSE                          -- If RX_DV_FF flips back to =0, ..
            RxState = stIdle;         -- .. return (by next _/RX_CLK) to the initial state 
        End IF;

    WHEN  RxWaitSFD =>  -- waiting for "Start Frame Delimiter" to appear :
                        -- (4 MSbits of SFD = H"D" ) is being searched for
                    -- RxWaitSFD =1,   CtReceiv =00, 
                  CtReceiv_sclr = VCC;
                  crcr.sclr     = VCC;
        IF    (RX_DV_FF & (RxD_Reg[]==H"D"))-- IF 4 MSbits of SFD detected, ..
            Then  RxState = RxDestAddr;     -- .. jump (by next _/RX_CLK) to receive DestAddr
        ELSIF (RX_DV_FF & (RxD_Reg[]==H"5"))-- IF Preamble detected again, ..
            Then  RxState = RxWaitSFD;      -- .. continue waiting for SFD
        ELSE                  
            RxState = stIdle;	            -- .. return (by next _/RX_CLK) to the initial state 
        End IF;

    WHEN  RxDestAddr => -- receiving "DestinationAddr" (6 Bytes) :
    -- DestAddr is to be compared with ThisDevice' address !
                    -- RxDestAddr =1,  CtReceiv = 0, RxD_Reg = DestAddr[43..40]
                    -- RxDestAddr =1,  CtReceiv = 1, RxD_Reg = DestAddr[47..44]
                    -- RxDestAddr =1,  CtReceiv = 2, RxD_Reg = DestAddr[35..32]
                    -- RxDestAddr =1,  CtReceiv = 3, RxD_Reg = DestAddr[39..36]
                    -- RxDestAddr =1,    .  .  .  .  .  .  .  .  .
                    -- RxDestAddr =1,  CtReceiv =11, RxD_Reg[]=DestAddr[ 7.. 4]
        IF (RX_DV_FF & (CtReceiv.q[3..0]==11))  -- IF 12th half-Byte received, .. 
            Then  RxState = RxSourAddr;     -- .. jump (by next _/RX_CLK) to receive SourAddr
                  CtReceiv_sclr  = VCC;     -- CtReceiv will flip to =00 by next _/RX_CLK
        ELSIF (RX_DV_FF == VCC)             -- IF receiving is ongoing, ..
            Then  RxState = RxDestAddr;     -- .. continue receiving the DestAddr
        ELSE
            RxState = stIdle;	            -- .. return (by next _/RX_CLK) to the initial state 
        End IF;
					
    WHEN  RxSourAddr => -- receiving "SourceAddr" (6 Bytes) :
    -- SourceAddr is to be stored so that to be used as DestAddr in the reply packet !
                    -- RxSourAddr =1,  CtReceiv = 0, RxD_Reg = SourAddr[43..40]
                    -- RxSourAddr =1,  CtReceiv = 1, RxD_Reg = SourAddr[47..44]
                    -- RxSourAddr =1,  CtReceiv = 2, RxD_Reg = SourAddr[35..32]
                    -- RxSourAddr =1,  CtReceiv = 3, RxD_Reg = SourAddr[39..36]
                    -- RxSourAddr =1,    .  .  .  .  .  .  .  .  .
                    -- RxSourAddr =1,  CtReceiv =11,  RxD_Reg[]=DestAddr[ 7.. 4]
        IF (RX_DV_FF & (CtReceiv.q[3..0]==11))  -- IF 12th half-Byte received, .. 
            Then  RxState = RxPkLength;     -- .. jump (by next _/RX_CLK) to receive PacketLength
                  CtReceiv_sclr  = VCC;     -- CtReceiv will flip to =00 by next _/RX_CLK
        ELSIF (RX_DV_FF == VCC)             -- IF receiving is ongoing, ..
            Then  RxState = RxSourAddr;     -- .. continue receiving the SourAddr
        ELSE
                  RxState = stIdle;         -- .. return (by next _/RX_CLK) to the initial state 
        End IF;
		
    WHEN  RxPkLength => -- receiving "PacketLength" (2 Bytes) :
                    -- RxPkLength =1,  CtReceiv = 0, RxD_Reg = Length[11.. 8]
                    -- RxPkLength =1,  CtReceiv = 1, RxD_Reg = Length[15..12]
                    -- RxPkLength =1,  CtReceiv = 2, RxD_Reg = Length[ 3.. 0]
                    -- RxPkLength =1,  CtReceiv = 3, RxD_Reg = Length[ 7.. 4]
        IF RX_DV_FF & (CtReceiv.q[1..0]== 3)    -- IF 4th half-Byte received, ..
            Then  RxState = RxDataBlck;     -- .. jump (by next _/RX_CLK) to receive DataBlock
                  CtReceiv_sclr  = VCC;     -- CtReceiv will flip to =00 by next _/RX_CLK
        ELSIF (RX_DV_FF == VCC)             -- IF receiving is ongoing, ..
            Then  RxState = RxPkLength;     -- .. continue receiving the PacketLength
        ELSE
                  RxState = stIdle;         -- .. return (by next _/RX_CLK) to the initial state 
        End IF;
		    
    WHEN  RxDataBlck => -- receiving DataBlock ( "RxLength" Bytes) :
                    -- RxDataBlck =1,  CtReceiv = 0, RxD_Reg=DByte01[3..0]=DWord01[11.. 8]
                    -- RxDataBlck =1,  CtReceiv = 1, RxD_Reg=DByte01[7..4]=DWord01[15..12]
                    -- RxDataBlck =1,  CtReceiv = 2, RxD_Reg=DByte02[3..0]=DWord01[ 3.. 0]
                    -- RxDataBlck =1,  CtReceiv = 3, RxD_Reg=DByte02[7..4]=DWord01[ 7.. 4]
        IF RX_DV_FF & (CtReceiv.q[] == ((RxLength[14..0],gnd) - 37))  -- -1!
            Then  RxState = RxFrameCRC;
                  CtReceiv_sclr  = VCC;
        ELSIF (RX_DV_FF == VCC)             -- IF receiving is ongoing, ..
            Then  RxState = RxDataBlck;     -- .. continue receiving the Data Block
        ELSE
                  RxState = stIdle;         -- .. return (by next _/RX_CLK) to the initial state 
        End IF;
				
    WHEN  RxFrameCRC  =>   -- receiving Frame' CRC (4 Bytes) :
        IF (RX_DV_FF & (CtReceiv.q[2..0]== 7))  -- IF 8th half-Byte received, ..
            Then  RxState = stIdle;         -- .. jump (by next _/RX_CLK) to the initial state
                  RxEndFrame.d  = VCC;      -- .. RxEndFrame will flip to =1 by next _/RX_CLK
        ELSIF (RX_DV_FF == VCC)             -- IF receiving is ongoing, ..
            Then  RxState = RxFrameCRC;     -- .. continue receiving the Frame' CRC
        ELSE
                  RxState = stIdle;         -- .. return (by next _/RX_CLK) to the initial state 
        End IF;
			          	     		
End CASE;
%
Tr_stIdle   = SRFF( 
        .S  = (!RX_DV_FF OR (Tr_RxWaitSFD &(RX_DV_FF & (RxD_Reg[]==H"D"))) ),
        .R  = ( Tr_stIdle AND RX_DV_FF ), 
        .clk= RX_clk ); 

Tr_RxChkPream   = SRFF(
        .S  = ( Tr_stIdle     AND RX_DV_FF ), 
        .R  = ( Tr_RxChkPream AND (RX_DV_FF & (RxD_Reg[]==H"5")) ),
        .clk= RX_clk ); 
        
Tr_RxWaitSFD    = SRFF(
        .S  = (Tr_RxChk_Pream AND (RX_DV_FF & (RxD_Reg[]==H"5")) ), 
        .R  = (Tr_RxWaitSFD   AND (RX_DV_FF & (RxD_Reg[]==H"D")) ); 
        .clk= RX_clk; );

Tr_RxDestAddr   = SRFF(
        .S  = (Tr_RxWaitSFD   AND (RX_DV_FF & (RxD_Reg[]==H"D")) ); 
        .R  = (RX_DV_FF & (CtReceiv.q[3..0]==11)),
        .clk= RX_clk; );
%

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- CHECK-UP of the DestAddr :  it must be equal to ThisDevice' address

ChkDaddr.(clk, ena) = (RX_CLK, RxDestAddr); -- enabled during receiving DestAddr
ChkDaddr.clrn = !RxInit;                -- установка в ноль в начале фрейма!

-- Compare the received half-Bytes with the correspondent half-Bytes of ThisDevAddr :
-- If at least ONCE  RxData[] NOTequal to Saddr[] then ChkDaddr will be =0 at the end 
IF  RxDestAddr  Then   
    CASE  CtReceiv.q[3..0]  IS
		WHEN 0  =>  ChkDaddr.d = (RxData[] == Saddr[43..40]); 
		WHEN 1  =>  ChkDaddr.d = (RxData[] == Saddr[47..44]) & ChkDaddr;
		WHEN 2  =>  ChkDaddr.d = (RxData[] == Saddr[35..32]) & ChkDaddr;
		WHEN 3  =>  ChkDaddr.d = (RxData[] == Saddr[39..36]) & ChkDaddr;
		WHEN 4  =>  ChkDaddr.d = (RxData[] == Saddr[27..24]) & ChkDaddr;
		WHEN 5  =>  ChkDaddr.d = (RxData[] == Saddr[31..28]) & ChkDaddr;
		WHEN 6  =>  ChkDaddr.d = (RxData[] == Saddr[19..16]) & ChkDaddr;
		WHEN 7  =>  ChkDaddr.d = (RxData[] == Saddr[23..20]) & ChkDaddr; 
		WHEN 8  =>  ChkDaddr.d = (RxData[] == Saddr[11.. 8]) & ChkDaddr;
		WHEN 9  =>  ChkDaddr.d = (RxData[] == Saddr[15..12]) & ChkDaddr;
		WHEN 10 =>  ChkDaddr.d = (RxData[] == Saddr[ 3.. 0]) & ChkDaddr;
		WHEN 11 =>  ChkDaddr.d = (RxData[] == Saddr[ 7.. 4]) & ChkDaddr;
    End CASE;
End IF;	

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- IF the received (DestinationAddr==This_Device' addr) <=> ChkDaddr=1, then ..
-- .. Latch the SourceAddr, to be used as DestinationAddr at the reply packet :  
Daddr[47..0].clk = RX_clk ; 

Daddr[ 3.. 0].d   = RxData[3..0];
Daddr[ 7.. 4].d   = RxData[3..0];
Daddr[11.. 8].d   = RxData[3..0];
Daddr[15..12].d   = RxData[3..0];
Daddr[19..16].d   = RxData[3..0];
Daddr[23..20].d   = RxData[3..0];
Daddr[27..24].d   = RxData[3..0];
Daddr[31..28].d   = RxData[3..0];
Daddr[35..32].d   = RxData[3..0];
Daddr[39..36].d   = RxData[3..0];
Daddr[43..40].d   = RxData[3..0];
Daddr[47..44].d   = RxData[3..0];

Daddr[43..40].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 0); 
Daddr[47..44].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 1);
Daddr[35..32].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 2);
Daddr[39..36].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 3);
Daddr[27..24].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 4);
Daddr[31..28].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 5);
Daddr[19..16].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 6);
Daddr[23..20].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 7); 
Daddr[11.. 8].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 8);
Daddr[15..12].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 9);
Daddr[ 3.. 0].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] ==10);
Daddr[ 7.. 4].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] ==11);

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- Building a 16-bit word of the Length of the Data Block :
RxLength[].clk      = RX_clk;
IF  RxPkLength  Then   
    CASE  CtReceiv.q[1..0]  IS
        WHEN 0 => RxLength[11..8].ena  = vcc;
        WHEN 1 => RxLength[15..12].ena = vcc;
        WHEN 2 => RxLength[3..0].ena   = vcc;
        WHEN 3 => RxLength[7..4].ena   = vcc;
    End CASE;
End IF;
RxLength[ 3.. 0].d  = RxData[3..0];     --\ 
RxLength[ 7.. 4].d  = RxData[3..0];     -- \ To build a 16-bit data word ..
RxLength[11.. 8].d  = RxData[3..0];     -- / .. of 4 consecutive half-Bytes
RxLength[15..12].d  = RxData[3..0];     --/ 
	
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- Test Outputs
Test[1] = RX_DV_FF;
Test[2] = RxChkPream;
Test[3] = CtReceiv_sclr;
Test[4] = ChkDaddr;


END;