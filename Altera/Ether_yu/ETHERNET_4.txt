TITLE "ETHERNET";
-- Ver. 2  : Rx/Tx of the "Raw_Ethernet" implemented, 
--             EthernetRx and EthernetTx are separate sub-modules. 
-- Ver.4b  : Rx/Tx of the "Raw_Ethernet" implemented in ONE module.
-- Ver.4d  : Rx/Tx of the "Raw_Ethernet" separated more clearly ; 
--             Rx_cycle break upon Reset is implemented.
-- Ver.4e  : Circuit which initializes Tx_cycle improved.
-- Ver.4f  : Synchronization of output DataWords with MainProj's Clock
--             drastically improved :  fake IO-requests eliminated.

--****************************************************************************
SUBDESIGN  ETHERNET
--============================================================================
  Основные функциональные узлы проекта: 
(
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
*  ETHERNET RECEIVER - Схема, управляющая ПРИЁМОМ Ethernet-посылки : 

--Входы, на которые поступают сигналы ОТ Ethernet-контроллера : 
RX_CLK          : INPUT;    -- Ether-Rx Clock   <- Rx-channel of Eth_Controller
RX_DV           : INPUT;    -- "DataValid"      <- Rx-channel of Eth_Controller
COL             : INPUT;    -- "Collision"     -//-
CRS             : INPUT;    -- "CarrierSense"  -//-
RXD[3..0]       : INPUT;    -- Data half-Byte   <- Rx-channel of Eth_Controller

Saddr[48..1]    : input;  --This_Device' address (to be sent at "SourceAddr" field ..
                                        --.. of the outcoming packets)
  Saddr поступает из MainProject-а.  В RECEIVER-е во время приёма посылки этот 
адрес сравнивается с "DestinationAddress", чтобы опознавать "свои" посылки. 

Daddr[48..1]    : DFFE; -- "Register" for latching and storing the DestAddr
  Daddr даже не выдаётся в MainProject, а используется внутри этого модуля 
для заполнения поля "DestinationAddr" передаваемой посылки. 

-- Main Receiving_Cycle Counter
CtReceiv        : LPM_COUNTER with ( lpm_width=12, lpm_direction="up" );

-- Triggers which represent the state of the Receiving_Cycle :
  RxLineIdle      : DFF ; -- flag:  "Idle" symbols are received     \_ не выдаются 
  RxChkPream      : DFF ; -- flag:  checking the "Preamble" symbols / в MainProject
RxWaitSFD       : DFF ; -- flag:  Waiting for "StartFrameDelimiter"
RxDestAddr      : DFF ; -- flag:  "DestinationAddr" is being received
RxSourAddr      : DFF ; -- flag:  "SourceAddr" is being received
RxPkLenTyp      : DFF ; -- flag:  "PacketLength/Type" is being received
RxDataBlck      : DFF ; -- flag:  Block of Data is being received
RxFrameCRC      : DFF ; -- flag:  "FrameCheckSequence" is being received
RxEndFrame      : DFF ; -- прием фрейма завершен
  Выходы этих триггеров также передаются через выходы модуля ETHERNET в 
MainProject для индикации состояния модуля и фазы приёма посылки.

-- Conversion of 4 half-Bytes into 1 16-bit Word :
RxShifter1      : LPM_SHIFTREG with (lpm_width=3, -- contains 1st bits (LSB) of 4 consecutive half-Bytes
RxShifter2      : LPM_SHIFTREG with (lpm_width=3, -- contains 2nd bits       of 4 consecutive half-Bytes
RxShifter3      : LPM_SHIFTREG with (lpm_width=3, -- contains 3rd bits       of 4 consecutive half-Bytes
RxShifter4      : LPM_SHIFTREG with (lpm_width=3, -- contains 4th bits (MSB) of 4 consecutive half-Bytes


----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
*  ETHERNET TRANSMITTER - Схема, управляющая ПЕРЕДАЧЕЙ Ethernet-посылки : 

--Выходы, через которые выдаются сигналы НА Ethernet-контроллер : 
TX_CLK          : INPUT;    -- Ether-Tx Clock   <- Tx-channel of Eth_Controller
TXD[3..0]       : OUTPUT;   -- half-Bytes of Data       -> Eth_Controller
TX_EN           : OUTPUT;   -- Enabling Transmission    -> Eth_Controller

--TxLenTyp[16..1] : input;    -- value of the "PkLength/Type" field
TxLength[12..1] : input ;   -- length of the DataBlock (MSbit always =0 ! )

-- Main Transmit_Cycle Counter
CtTransm        : LPM_COUNTER with (LPM_WIDTH=12, LPM_DIRECTION="up");

-- Triggers which represent the state of the Transmit_Cycle :
TxLineIdle      : DFF;
TxPreamble      : DFF;
TxStFrmDel      : DFF; 
TxDestAddr      : DFF; 
TxSourAddr      : DFF;
TxPkLenTyp      : DFF;
TxDataBlck      : DFF;
TxFrameCRC      : DFF; 
TxEndFrame      : DFF;      
  Выходы этих триггеров также передаются через выходы модуля ETHERNET в 
MainProject для индикации фазы передачи посылки.
)
          

--****************************************************************************
-- LOGIC Section
--============================================================================
BEGIN

  Разработанный модуль ETHERNET предназначен для приёма и передачи данных из/в 
контроллер Ethernet-лини.  Модуль не может одновременно принимать и передавать 
данные, поэтому для обеспечения корректной работы контроллер Ethernet-линии 
ДОЛЖЕН БЫТЬ ПРЕДУСТАНОВЛЕН В Half-Duplex режим (!!). 

  Модуль обеспечивает приём и передачу данных только в виде Ethernet-фреймов, 
т.е. посылок формата "Raw_Ethernet" => 
- все данные, содержащиеся в блоке данных принимаемого Ethernet-фрейма, пере-
  даются в MainProject без изменений для дальнейшего разбирательства. 
- все данные, которые необходимо поместить в блоке данных отправляемого Ether-
  net-фрейма, должны быть предоставлены MainProject-ом.
Поэтому все разборки с протоколами следующего уровня должны выполняться внутри
MainProject-a. 

--============================================================================
  ПРИЁМ  ETHERNET-посылки
--------------------------
  Напомним, что БАЙТЫ данных передаются по Ethernet-линии в их естественном 
порядке :  первым - MSByte, последним - LSByte (т.е. в том же порядке, как и 
записываются в тексте) ;  а вот БИТЫ каждого байта передаются в обратном 
порядке :  первым - LSB, последним - MSB (т.е. в обратном порядке по отношению 
к порядку записи в тексте).  Соответственно, при приёме/передаче каждого байта 
от Ethernet-контроллера в FPGA или от FPGA в Ethernet-контроллер сначала пере-
даётся младший полу-байт, потом - старший полу-байт. 


  Приём Ethernet-фрейма (посылки) производится модулем ETHERNET.  Выполнение 
цикла Приёма происходит под управлением неявно написанной "Машины состояний", 
состоящей из триггеров  RxLineIdle, RxChkPream, ..., RxFrameCRC и простеньких 
логических схем, управляющих включением этих триггеров. 

  Когда по Ethernet-линии не передаются посылки, по ней непрерывно передаётся 
бесконечно повторяющийся "idle-symbol" (символ молчания").  При этом Ethernet-
контроллер держит сигнал Data_Valid =0.  Когда по линии начинают поступать 
символы Преамбулы, Ethernet-контроллер выдаёт сигнал Data_Valid=1.  Этот сиг-
нал защёлкивается в триггер RX_DV_FF, а по следующему _/ RX_CLK триггер 
RxLineIdle переключается в =0, а RxChkPream переключается в =1.  

  Во время Преамбулы по Ethernet-линии передаются чередующиеся 0 и 1, при 
этом от Ethernet-контроллера поступают полу-байты, содержащие B"0101"=H"5". 
Пока поступают такие полу-байты, триггер RxWaitSFD стоит в =1. 
Последним байтом Преамбулы является байт, содержащий  "StartFrameDelimiter", 
т.е. в Ethernet-линии два последних по времени бита = 1 (последовательность 
бит в линии = [1010 1011] ) => соответственно, от Ethernet-контроллера в FPGA 
поступают полу-байты [B"0101"=H"5", B"1101"=H"D"].  То есть, последним полу-
байтом перед полем "DestinationAddr" является полу-байт H"D".  Когда посту-
пает такой полу-байт, по следующему _/ RX_CLK триггер RxWaitSFD переключается 
в =0, а триггер RxDestAddr переключается в =1. 

******** "DestinationAddr" :
  Затем поступают 6Байт (12 полу-байт) DestinationAddr, т.е. АДРЕС ПОЛУЧАТЕЛЯ. 
Сначала 1-й полу-байт 1-го Байта (MSByte) защёлкивается в "регистр" из 4-рёх 
триггеров RxD_Reg[4..1].  На следующем _/ 1-й (младший) полу-байт вдвигается 
в младшие биты 4-рёх регистров RxShifter[4..1].q0, а 2-й (старший) полу-байт 
защёлкивается в триггерах RxD_Reg[4..1].  В этот момент производится сравнение 
пришедшего Байта со старшим Байтом Saddr(Адрес_Этого_Устройства) или с H"FF".
  Аналогично принимаются 5 остальных Байт DestinationAddr, и сравниваются с 
соответствующими Байтами Saddr и с H"FF".  Если оказалось, что DestinationAddr 
равен Адресу Этого Устройства (установлен на входах Saddr),  ИЛИ 
  [(1111 1111) FF  FF  FF  FF  FF ] (=broadcast= фрейм),     ИЛИ
[ пока не реализовано!  [(???? ??01) ??  ??  ??  ??  ?? ] (=multicast= пакет), 
то нужно принимать оставшуюся часть Ethernet-фрейма и обрабатывать её. 

******** "SourceAddr" :
  Затем поступают 6Байт (12 полу-байт) SourceAddr, т.е. АДРЕС ОТПРАВИТЕЛЯ. 
Эти 6Байт принимаются аналогично.  
  Во время того такта RX_CLK, когда CtReceiv.q[]=3, старшие 16бит SourceAddr 
"распутываются" из "регистра" RxD_Reg и регистров RxShifter[4..1], и по следу-
ющему _/ защёлкиваются в соответствующие биты "регистра" Daddr :
    Daddr[44..41].d = RxShifter[4..1].q2;   --\ interconnections 
    Daddr[48..45].d = RxShifter[4..1].q1;   -- \for reconstruction 
    Daddr[36..33].d = RxShifter[4..1].q0;   -- /of the 1st(MSByte) and 2nd Bytes 
    Daddr[40..37].d = RxD_Reg[4..1].q;      --/ of the DestinationAddr
Аналогично "распутываются" и защёлкиваются остальные 16+16 бит SourceAddr, в 
моменты CtReceiv.q[]=7 и CtReceiv.q[]=11. 
Отметим, что значение "SourceAddr" нужно будет использовать в ответной (или 
другой =исходящей=) посылке как "DestinationAddr", поэтому это значение сохра-
няется в "регистре" Daddr (а не Saddr !) для последующего использования.

******** "PacketLength/Type" :
  Следующим поступает 2-Байтовое значение "PacketLength/Type".  Во время того 
такта RX_CLK, когда CtReceiv.q[]=3, 16бит PacketLength/Type "распутываются" из 
"регистра" RxD_Reg и регистров RxShifter[4..1], и по следующему \_ (по ЗАДНЕМУ 
фронту !) защёлкиваются в соответствующие биты "регистра" RxLenType.  Защёлки-
вание производится по заднему фронту RX_CLK, чтобы значение PacketLength/Type 
появилось на выходах Ether.RxLenTyp заведомо раньше _/ следующего такта, чтобы 
логика распознавания Типа пакета в MainProject-e отработала =до= _/ следующего 
такта, и чтобы, в итоге, соответствующий триггер - RxIPheader или RxARPheadr 
(в MainProject-e) - установился в =1 одновременно с триггером RxDataBlck (в 
модуле ETHERNET).  Значение PacketLength/Type сохраняется в регистре RxLenType 
до окончания нормального приёма фрейма (после чего устанавливается в начальное 
значение сигналом RxEndFrame) либо до возникновения ошибки (тогда устанавлива-
ется в начальное значение сигналом R_Err).  
  ПОЯСНЕНИЕ:  начальное значение регистра RxLenType =H"8000" - нестандартное 
значение, причём оно > 1536.  Это сделано для того, чтобы до защёлкивания в 
этот регистр актуального значения PacketLength/Type, полученного в принимаемом 
фрейме, флаг TypeRaw был заведомо =0 (т.к. >1536), и флаги TypeCMD3, TypeARP и 
TypeIP (в MainProject-e) тоже были =0 (т.к. значение нестандартное). 
  Вместе с обработкой значения "PacketLength/Type", во время того такта, когда 
CtReceiv.q[]=3, логика "Машины состояний" выдаёт сигналы, согласно которым по 
следующему _/ RX_CLK происходит : 
- триггер RxPkLenTyp переключается в =0 ;
- триггер RxDataBlck переключается в =1 ;
- счётчик CtReceiv обнуляется ;
- счётчик CtDatBlk загружает в себя значение H"0001". 

  СРАЗУ ЖЕ после того, как значение "PacketLength/Type" защёлкнется в регист-
ре RxLenTyp, начинает работать логика распознавания ТИПА пакета, содержаще-
гося в принимаемом фрейме.  Подчеркнём, что до защёлкивания принятого значения 
"PacketLength/Type" регистр RxLenTyp содержит значение =0, поэтому ненулевые 
значения флагов (обозначающих Тип пакета) и управляющих сигналов появляются 
на выходах логики распознавания только после защёлкивания "PacketLength/Type" 
в регистр RxLenTyp. 
  Непосредственно в модуле ETHERNET опознаются только пакеты типа Raw ("сырой
Ethernet");  остальные типы пакетов распознаются в MainProject-е.  Если значе-
ние "PacketLength/Type" =< 1500, значит, это пакет Raw, и значение обозначает 
размер блока данных (в Байтах).  Тогда флаг TypeRaw устанавливается в =1, и 
модуль переходит в режим приёма блока данных (триггер RxDataBlck =1), причём 
значение RxLenTyp.q[] будет использовано как размер принимаемого DataBlock.  
При этом в регистре RxLength сначала сохраняется значение по умолчанию (=48, 
этого достаточно для того, чтобы приём DataBlock продолжался), а через 10 так-
тов RX_CLK в него переписывается принятое значение из RxLenTyp.  
  Если условие ("PacketLength/Type" =< 1500 ) не выполнено, значит, это пакет 
не Raw.  При этом, независимо от типа пакета, модуль ETHERNET переходит в ре-
жим приёма блока даных, но размер принимаемого блока данных будет определён в 
MainProject-е.  Поэтому простенькая логика распознавания типа пакета, находя-
щаяся в модуле ETHERNET, переключает входы данных RxLength.d[] на входную шину
RxLengIn[], и через 10 тактов RX_CLK в RxLength записывается значение, приня-
тое из MainProject-а. 
  Хронограмма работы распознающих схем и запуска обработки протоколов IP и ARP 
критически важна для понимания работы всего функционального узла, обеспечиваю-
щего работу с Ethernet-ом, поэтому она приведена ниже на рис.1.

  После того, как принятое значение "PacketLength/Type" защёлкнулось в регистр 
RxLenTyp, оно остаётся неизменным до окончания приёма всего фрейма.  Значение 
RxLenTyp[] поступает в MainProject на логику распознавания Типа пакета.  Если 
это значение соответствует одному из опознаваемых типов ("CMD3", "IP", "ARP"), 
то флаг опознанного типа устанавливается в =1, и инициируется процедура обра-
ботки соответствующего протокола. 

Рис.1.  Хронограмма сигналов во время распознавания Протокола 
--==============================================================================
--************ LENGTH/TYPE  RECOGNITION :  *************************************
 25MHz RxClk  _____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\_____/^^^^^\____
CtReceiv.q[]  ==2==X=====3=====\_____0_____/=====1=====X=====2=====X=====3=====X=====4====
RxPkLenTyp    ^^^^^^^^^^^^^^^^^\__________________________________________________________
RxDataBlck    _________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
CtDatBlk.q[]  _______0_________/=====1=====X=====2=====X=====3=====X=====4=====X=====5====
RxLenTyp.q[]  ___________/================ Length/Type)_Value ============================
Reg_RxWord[]  ..........XXX========== DWord=Length/Type_Value ==========XXX====DWord01====
  IORq (RdWr_out=0)_____///^^^^^^^^^^^^^^^^^^^^^^^^^^\\\________________///^^^^^^^^^^^^^^^
                         |<------~8*Clk100------>|
  EthWord_Rd  __________________________________///^^\\\__________________________________

  EthAdrInit  __________________/^^^^^^^^^^^^\____________________________________________
  EthAddrLd2  _________________________///^^^^^^^^^^^^^^\\\_______________________________
EtherAdrCt.q[]->PortA =============06===================XXX=============08================
Flag of TYPE (ONE only!)__/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
RxIPheader or RxArpheadr_______/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
CtProto.q[]   ______0____________________/=====1=====X=====2=====X=====3=====X=====4======  


******** "DataBlock" :
  Итак, после приёма поля  "PacketLength/Type"  "Машина состояний" =всегда= 
переходит в состояние "RxDataBlck".   При этом в регистре RxLength сначала 
сохраняется значение по умолчанию (=48, этого достаточно для того, чтобы приём 
DataBlock-а продолжался), а через 10 тактов RX_CLK в него переписывается либо 
принятое значение "PacketLength/Type" из RxLenTyp (если пакет типа "Raw"), 
либо значение, принятое от MainProject-a по входам RxLengIn[].  Приём данных 
продолжается до того момента, когда :
- значение счётчика CtDataBlck.q[] сравняется со значением RxLength[], т.е. 
  заданное число байтов принято.  Тогда по следующему _/RX_CLK "Машина состоя-
  ний" перейдёт в состояние приёма поля "FrameCRC" (контрольная сумма фрейма). 
- от MainProject-a поступит сигнал "Reset" (при штатной работе сигнал "Reset" 
  выдаётся в случае, когда пакет опознан как "чужой").  Тогда по следующему 
  _/RX_CLK триггер RxDataBlck принудительно сбрасывается в =0, и "Машина со-
  стояний" "зависает" до окончания принимаемого фрейма.  По окончании фрейма 
  триггер RX_DV_FF переключится в =0, а по следующему _/ RX_CLK триггер 
  RxCycle тоже переключатся в =0.  При этом выдаётся сигнал RxEndFrame (дли-
  тельностью 1*RX_CLK), и триггер RxLineIdle переключится в =1, в результате 
  чего "Машина состояний" окажется в исходном состоянии готовности к приёму 
  следующих фреймов.
- "неожиданно" пропадёт сигнал RX_DV (из-за сбоя в линии Ethernet или если 
  размер DataBlock-a был определён неправильно - больше, чем на самом деле). 
  Тогда триггер RxDataBlck сбросится в =0, и будет выдан сигнал ошибки R_Err. 
  Кроме того, по окончании сигнала RX_DV триггер RX_DV_FF переключится в =0, 
  а по следующему _/ RX_CLK триггер RxCycle тоже переключатся в =0.  При этом 
  выдаётся сигнал RxEndFrame (длительностью 1*RX_CLK), и триггер RxLineIdle 
  переключится в =1, в результате чего "Машина состояний" окажется в исходном 
  состоянии готовности к приёму следующих фреймов.
Подчеркнём, что сигнал RxEndFrame =всегда= выдаётся после фактического оконча-
ния поступившего фрейма.
  ПОЯСНЕНИЕ:  при приёме DataBlock-a, т.е. в состоянии "RxDataBlck", =пока= 
используется для счёта байтов отдельный счётчик CtDataBlk, который начинает 
считать с =1 (а не с =0, как общий счётчик CtReceiv).  При таком счёте число 
CtDataBlk.q[11..1] равно числу принятых Байтов, поэтому его можно напрямую 
сравнивать с RxLength[] для определения конца DataBlock-a. 
  Можно использовать общий 12-разрядный счётчик, но тогда при переходе к каж-
дому следующему состоянию "Машины состояний" его нужно устанавливать в =1, а 
не в =0 (как сделано в текущей версии) ;  => во всех операциях, которые "при-
вязаны" к значениям общего счётчика (переходы к следующему состоянию "Машины 
состояний, защёлкивание слова данных в Reg_RxWord, и т.п.) нужно увеличить 
соответствующие значения на 1. 

******** Передача данных в MainProject :
  ПАРАЛЛЕЛЬНО с выполнением приёма Ethernet-фрейма все его байты, начиная с 
поля DestinationAddr, =попарно= выдаются в MainProject в виде 16-битных слов 
данных, синхронизованных с =внутренним Clock-ом MainProject-а= (сигнал Clock). 
Каждое слово "распутывается" из "регистра" RxD_Reg и регистров RxShifter[4..1] 
и защёлкивается в регистр Reg_RxWord внутри того такта RX_CLK, при котором 
CtReceiv.q[1..0]=3.  "Регистр" Reg_RxWord работает от Clock-а, поэтому обнов-
ление данных на его выходе уже синхронизовано с этим Clock-ом.  Для надёжной 
работы "регистра" Reg_RxWord строб RxWord_en, по которому этот регистр защёл-
кивает слово данных, тоже синхронизован с Clock-ом.  Этот строб формируется 
"схемой вырубки" (см. строку "RxWord_en = ..." файла "ETHERNET.tdf") на двух 
триггерах, работающих от Clock-а.  Выдача этого строба инициируется логической 
схемкой, которая срабатывает при [CtReceiv.q[1..0]==3 И при наличии ещё неко-
торой комбинации сигналов].  Все входные сигналы этой схемки изменяются по 
_/^ RX_CLK ;  однако, из-за различия задержек от CtReceiv.q1 и от CtReceiv.q0 
до Лог.Ячейки, на которой реализована эта схемка, она может выдавать короткие 
ложные срабатывания вскоре после _/^ RX_CLK.  Т.к. _/^ Clock-а может поступить 
в любой момент относительно _/^ RX_CLK-а, это может привести к срабатыванию 
"схемы вырубки" в неправильный момент (и =реально= наблюдались лишние стробы 
при переключении CtReceiv.q[1..0] от =1 к =2 ).  Чтобы исключить лишние сраба-
тывания "схемы вырубки", на триггерах RxW1 и RxW2 сделана схемка, которая 
переключается из лог.0 в лог.1 и обратно только при условии, что сигнал RxWord 
после перехода 0->1 или 1->0 продержится в новом значении не менее 5нс.  После 
добавления этой схемки лишние стробы перестали появляться, а задержка _/^ 
строба от момента переключения CtReceiv.q[1..0] в =3 получилась от (0.5*Clock + 
+ маленько) до (1.5*Clock + маленько) (см. хронограмму ниже). 

 25MHz RX_CLK   ___/^^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\____
CtReceiv.q[]    =2==X======3===============3========\_____0_____________
  RxWord        _____/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\\\\\\\___________

100MHz Clock    __/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\_
RxW1            _______/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\________________
RxW2            ___________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\____________
                     |----->| Delay = (0.5*Clock + little)
RxWord_en       ____________/^^^^^^^\___________________________________

100MHz Clock    _/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\__
RxW1            ______________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_________
RxW2            __________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____
                     |------------>| Delay = (1.5*Clock + little)
RxWord_en       ___________________/^^^^^^^\____________________________

  Сразу после защёлкивания очередного DWord в Reg_RxWord выдаётся запрос на 
вычитывание готового слова в MainProject в виде (IORq=1, RW=0).  По этому 
запросу слово данных может быть записано в отдельное ОЗУ секции "ETHERNET In-
terface" основного проекта.  ПОДРОБНОЕ ОПИСАНИЕ процедуры записи всех данных 
Ethernet-фрейма в ОЗУ см. в описании обработки ARP-пакетов (в файле 
"Ethernet_UDP.txt"). 

--============================================================================
  ПЕРЕДАЧА  ETHERNET-посылки
------------------------------
  Передача Ethernet-фрейма инициируется при поступлении от MainProject-а сиг-
нала StTransmit (длительностью не менее 1такта внутреннего Clock-a MainPro-
ject-a).  Этим сигналом триггер enTransmit устанавливается в =1 (и находится 
в =1 до окончания передачи фрейма).  После этого по ближайшему ^\_ TX_CLK-a 
доп.триггер TxCycle0 переключается в =1 ;  за вторую половину этого периода 
TX_CLK-a выходной сигнал TxCycle0 =гарантированно= доходит до всех триггеров, 
которые должны переключиться по следующему _/^ TX_CLK-a.  По следующему _/^ 
TX_CLK-а выдаётся сигнал TX_EN на Ethernet-контроллер, устанавливается флаг 
TxCycle, и выдаётся сигнал TxInit = 1*TX_CLK _/^^^^\_, который стробирует 
загрузку значений TxLength в TxLength_Reg и TxLenTyp в TxLenTyp_Reg[4..1]. 

  Выполнение цикла передачи Ethernet-фрейма (посылки) происходит под управле-
нием неявно написанной "Машины состояний", состоящей из триггеров  TxLineIdle, 
TxChkPream, ..., TxFrameCRC и простеньких логических схем, управляющих включе-
нием этих триггеров. 

******** "TxPreamble" и "TxStFrmDel" :
  По стробу TxInit "Машина состояний" переходит из состояния "TxLineIdle" в 
"TxPreamble", т.е. триггер "TxPreamble" переключается в =1.  В течение 15 
тактов TX_CLK на выходы данных TXD[3..0] передаётся код  B"0101" (=5), после 
чего триггер TxPreamble переключается в =0, триггер TxStFrmDel переключается 
в =1, и на выходы данных передаётся код B"1100" (=H"D" = 13).  Таким образом 
на выход будет передано 7 байтов, равных  B"0101 0101" (=H"55") и 8-й байт, 
у которого 1-й по времени (младший) полу-байт равен B"0101", а второй (стар-
ший) равен B"1100" (H"D").  

******** "DestinationAddr" :
  Поле "DestinationAddr" состоит из 6Байт => передаётся в виде 12 полу-Байт. 
Для этого значение DestinationAddr ("запутанное" нужным образом) загружается 
в 4 12-битных регистра сдвига Daddr_Reg[4..1] =перед= началом передачи 
"DestinationAddr", а во время передачи этого поля данные в Daddr_Reg[4..1] 
сдвигаются (q0->q11), так что на выходы подаются полу-байты в нужном порядке. 
Altera выдаёт сначала Младший, потом Старший полу-байт от каждого байта, а 
Контроллер всасывает их и передаёт биты в линию Ethernet начиная с LSB и за-
канчивая MSB : 
  Daddr[41..44], Daddr[45..48],  (MSByte,   с LSB до MSB)
  Daddr[33..36], Daddr[37..40],  (2nd Byte, с LSB до MSB)
  . . . . . . . . . . . . . . 
  Daddr[ 1.. 4], Daddr[ 5.. 8]   (LSByte,   с LSB до MSB) .
Значение DestinationAddr загружается в регистры Daddr_Reg[4..1] из "регистра" 
Daddr[48.. 1] (в который было сохранено значение SourceAddr из последнего 
принятого Ethernet-фрейма) непосредственно перед началом передачи "Destina-
tionAddr", т.е. во время передачи "StartFrameDelimiter". 

******** "SourceAddr" :
  Поле "SourceAddr" состоит из 6Байт => передаётся в виде 12 полу-Байт. Для 
этого значение SourceAddr=АдресЭтогоУстройства со входов Saddr[48..1] "запу-
тывается" нужным образом и перед началом передачи "SourceAddr" загружается в 
4 12-битных регистра Saddr_Reg[4..1], а во время передачи этого поля данные 
продвигаются аналогично тому, как это делалось при передаче "DestinationAddr". 

******** "PacketLength/Type" :


******** "DataBlock" :
  1-е слово данных защёлкивается в регистр Reg_TxWord ещё во время состояния 
"TxPkLenTyp", поэтому к моменту перехода в состояние "TxDataBlck" оно уже выс-
тавлено на выходах Reg_TxWord.q[]. Одновременно с тем, как триггер TxDataBlock 
переключается в =1, DWord01 "запутывается" (обратная операция к "распутыванию" 
данных при приёме) и защёлкивается в 4 сдвиговых регистра TxShifter[4..1].  
За 4такта TX_CLK слово DWord01 выдаётся в контроллер Ethernet в виде 4-х полу-
байтов.  




END;