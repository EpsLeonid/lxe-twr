--TITLE "Interface"; --ads5281"

  INCLUDE "Loader"; 
  INCLUDE "trans_eth";
  INCLUDE "receiver_eth";


SUBDESIGN interface   -- ads5281 

(
	RESET,RX_CLK,TXclk                  : INPUT ;  -- входной сигнал сброса (nRESET или NRST)
	RX_DV,COL,CRS,RXD[3..0]             : input ; 
	Data_ou[95..0]                      : input ;
	StEthRdata                          : input ;
	enP_Start,en_Start,P_Start          : output;              --?
	P_Reset                             : output;
	R_data_req                          : output;
	enRdataADC                          : output;
	RadrRAM[25..0]                      : output;
	kop[3..0]                           : output;
	iniRdataADC                         : output;
			  
    -- pll_adc (ad95252)
    
    CS_pll,SCLK_pll,SDIO_pll            : output;   --bidir ; 
      
    -- АЦП
    
	CS, S_CLK, S_DATA                   : output;  -- выходные сигналы узла загрузки АЦП
	
    -- управление рабочим циклом
	
	en_WriteData,en_WriteData_d         : input ; 
	en_start_sync                       : input ;
        
    -- передатчик Ethernet-10/100 

TXDout[3..0],TXena                      : output;
p[3..0]                                 : input;
End_dd                                  : output;  
EndTrans,SendEndData,DataField          : output;
data,EnReply,end_delay                  : output;
LOAD_Reg,Rcheck,Rok,enIni               : output;
ENadjust,SDACdata                       : output;
LDACdata,endReadData                    : output; 

RgDat[63..0]                            : output;
Daddr[47..0]                            : output;
CheckDes                                : output;
Rdata[3..0]                             : output;
workMemSize[7..0]                       : output;           
rg_delay_a[15..0]                       : output;          
rg_delay_b[15..0]                       : output; 
rg_iniADR_rd[19..0]                     : output;
read_length[15..0]                      : output;

WrIniRAM                                : output; 
enRiniRAM                               : output;
enWiniRAM                               : output;
AdrWrRAM[5..0]                          : output; 
RgDAP_RAM[31..0]                        : output;
dataRAM_ini[23..0]                      : output;
R_DATA_bl                               : output;
Ini_a_p                                 : output; 

radrIni[11..0]                          : output; 
Fd[10..0]                               : output;
fl_a,fl_b                               : output; 
couTransmit[15..0]                      : output;
en_radr_mem                             : output;   
    
)

VARIABLE

P_Reset,cou_reset[7..0]                 : dffe ;
End_P_reset,LOAD_Reg                    : dffe ;
en_Start                                : dffe ;
enP_Start,cou_PS[8..0],P_Start          : dffe ;    
R_data_req                              : dffe ;
IniL                                    : Loader;          
dataRAM_ini[23..0]                      : dffe ;
enWiniRAM,AdrWrRAM[5..0]                : dffe ;
reqREADiniRAM                           : dffe ;
iniRiniRAM,enRiniRAM                    : dffe ;
RadrRAM[25..0]                          : dffe ;
--DATA_DAP_RAM[31..0]                     : dffe ;
delayST,couDelSt[6..0],end_delay        : dffe ;
EiLr,EiLr_d,St_EiLr,SReply,StReply      : dffe ;
EnReply                                 : dffe ;
Tr_eth                                  : trans_eth;

TXDout[3..0],TXena,EndTrans             : node ;
en_radr_mem                             : node ;
Saddr[47..0]                            : node ;
stRiniRAM                               : dffe ; 
enIni,endIni                            : node ; 
iniRdataADC,enRdataADC                  : dffe ;
SendEndData,couEndData[1..0]            : dffe ;
EndSendData                             : node ;
rec_eth                                 : receiver_eth;
RgDat[63..0],Daddr[47..0]               : node ;
RgDAP_RAM[31..0]                        : node ;
CheckDes,Rcheck,Rok                     : node ;
Rdestination,stW_RAM,endReadData        : node ;   
kop[3..0]                               : node ;
Raddr[15..0]                            : node ;
data,DestinationAddr,SourceAddr         : node ;
PacketLenth,DataField                   : node ; 
SDACdata, LDACdata                      : node ;
End_dd,End_d                            : dffe ;
enWork_reply, enWork_reply_d            : dffe ;
workMemSize[7..0]                       : dffe ;
rg_delay_a[15..0]                       : dffe ;
rg_delay_b[15..0]                       : dffe ;   
rg_iniADR_rd[19..0]                     : dffe ;
read_length[15..0]                      : dffe ;
WrIniRAM                                : NODE ;
endWIni                                 : dffe ;
R_DATA_bl                               : dffe ;
Ini_a_p, Ini_a_pd                       : dffe ;
R_data_reqb                             : dffe ;
end_R_DATA_BL                           : dffe ;
cou_load[2..0]                          : dffe ;
end_LOAD_Reg                            : node ;
Fd[10..0]                               : lcell;
fl_a,fl_b                               : dffe ;
couTransmit[15..0]                      : node ;
cou_nb[19..0]                           : dffe ;

        
BEGIN

Saddr[47..0] = (H"1a1a1a1a1a1",p[3..0]);               --   H"1a1a1a1a1a11"

-- приемник Ethernet - прием командных слов и управляющих массивов

  rec_eth.reset        = reset;
  rec_eth.ready        = vcc;
  rec_eth.RX_CLK       = RX_CLK;
  rec_eth.RX_DV        = RX_DV;                   
  rec_eth.COL          = COL;
  rec_eth.CRS          = CRS;
  rec_eth.RXD[3..0]    = RXD[3..0];          
  rec_eth.Saddr[47..0] = Saddr[47..0];
  rec_eth.p[3..0]      = p[3..0];
 
RgDat[63..0]         = rec_eth.RgDat[63..0];
kop[3..0]            = RgDat[3..0];
Daddr[47..0]         = rec_eth.Daddr[47..0];
RgDAP_RAM[31..0]     = rec_eth.RgDAP_RAM[31..0];
WrIniRAM             = rec_eth.WrIniRAM;           -- признак записи в INIRAM!!!
CheckDes             = rec_eth.CheckDes;
Rcheck               = rec_eth.Rcheck;
Rok                  = rec_eth.Rok;
Rdestination         = rec_eth.Rdestination;
stW_RAM              = rec_eth.stW_RAM; 
Raddr[15..0]         = rec_eth.Raddr[15..0]; 
Rdata[3..0]          = rec_eth.Rdata[3..0]; 

--===========================================================================================================
-- ДЕШИФРАЦИЯ и исполнение КОМАНД КАНАЛА СВЯЗИ 

   -- Nop        = (RgDat[3..0] == 0) -- нет операции, ожидание команды (ИСХОДНОЕ СОСТОЯНИЕ)
   -- P_Reset    = (RgDat[3..0] == 1) -- СБРОС элементов модуля в исходное состояние, ИНИЦИАЛИЗАЦИЯ PLL и АЦП     
   -- LOAD_Reg   = (RgDat[3..0] == 2) -- Запись УПРАВЛЯЮЩИХ КОНСТАНТ (ВЕЛИЧИНЫ ЗАДЕРЖЕК, РАЗМЕР ПАМЯТИ)
   -- en_Start   = (RgDat[3..0] == 3) -- Разрешение запуска/ПРОГРАММНЫЙ ЗАПУСК 
   -- R_data_req = (RgDat[3..0] == 4) -- Запрос на чтение массива данных
   -- R_DATA_bl  = (RgDat[3..0] == 5) -- Загрузка НАЧАЛЬНОГО АДРЕСА (НОМЕРА БЛОКА) и Запрос на повторное чтение блока данных
   -- Ini_a_p    =	(RgDat[3..0] == 6) -- инициализация PLL и АЦП (выполняется после загрузки RAMini)
   -- RAMini       (RgDat[3..0] == 7) -- загрузка таблицы коэффициентов в RAMini с последующим чтением

   -- Программный сброс в исходное состояние (P_Reset)
   --====================================================================================================================================
   
	   P_Reset.d        = (RgDat[3..0] == 1) & !End_P_reset; 
       P_Reset.ena      = CheckDes & Rcheck & Rok
                        # End_P_reset;
       P_Reset.clrn     = reset;                                             --prn      = reset;  ИСПРАВЛЕНО!                 
    
       cou_reset[].d    = cou_reset[].q + 1;
       cou_reset[].clrn = P_Reset & reset;
    
       End_P_reset.d    = (cou_reset[] == 255);
       
       End_d.d          = End_P_reset;
       End_dd.d         = End_d;
       
   (P_Reset,cou_reset[],End_P_reset,End_d,End_dd).clk = RX_CLK;
       
-- процедура инициализации АЦП и ФАПЧ (запуск по заднему фронту P_Reset)  -- ИСПРАВИТЬ САМУ ПРОЦЕДУРУ ЗАГРУЗКИ РЕГИСТРОВ АЦП И ГУН 
    
   IniL.End_P_reset      = End_P_reset # Ini_a_p;
   IniL.RX_CLK           = RX_CLK;
   IniL.reset            = reset; 
   IniL.TXclk            = TXclk;
   IniL.WrIniRAM         = WrIniRAM;
   IniL.AdrWrRAM[5..0]   = AdrWrRAM[5..0];
   IniL.enWiniRAM        = enWiniRAM;  
   IniL.RgDAP_RAM[23..0] = RgDAP_RAM[23..0];
   IniL.RadrRAM[5..0]    = RadrRAM[5..0]; 
   IniL.enRiniRAM        = enRiniRAM;
      
   dataRAM_ini[23..0].d 	= IniL.dataRAMini[23..0];
   dataRAM_ini[23..0].ena   = en_radr_mem & enRiniRAM;
   dataRAM_ini[23..0].clk   = TXclk;

   S_DATA    = IniL.SDATA;
   S_CLK     = IniL.S_CLK;
   CS        = IniL.CS;

   CS_PLL    = IniL.CS_PLL;
   SCLK_PLL  = IniL.SCLK_PLL;
   SDIO_pll  = IniL.SDATA_PLL; 
   
   enIni     = IniL.enIni;
   endIni    = IniL.endIni;
   
   radrIni[11..0] = IniL.radrIni[11..0]; 
   
--================================================================================================================= 
   -- Флаг записи управляющих констант в регистры 
                         
       LOAD_Reg.d      = !end_LOAD_Reg;   
       LOAD_Reg.ena    = (RgDat[3..0] == 2) & CheckDes & Rcheck & Rok & !en_WriteData
                       # end_LOAD_Reg;                 
       LOAD_Reg.clk    = RX_CLK;                 
       LOAD_Reg.clrn   = reset & !P_Reset;  
       
       cou_load[].d    = cou_load[].q + 1; 
       cou_load[].clk  = RX_CLK;
       cou_load[].clrn = LOAD_Reg;
       
       end_LOAD_Reg = (cou_load[] == 7);
       
       Fd[10..0] = rg_delay_a[10..0] & !cou_load[2]
                 # rg_delay_b[10..0] &  cou_load[2];
            
       fl_a.d = (cou_load[] == 1) & LOAD_Reg
              # End_dd;                           -- НУЖНО ФОРМИРОВАТЬ И ПРИ ОКОНЧАНИИ ПРОГРАММНОГО СБРОСА! 
       fl_b.d = (cou_load[] == 5) & LOAD_Reg
              # End_dd; 
           
       (fl_a,fl_b).clk  = RX_CLK; 
       (fl_a,fl_b).clrn = reset & !P_Reset;
                            
-- фиксация содержимого управляющих регистров:
   
   -- РЕГИСТР ОБЪЕМА ИСПОЛЬЗУЕМОЙ ПАМЯТИ 
      
   workMemSize[].d    = RgDat[15..8];
   workMemSize[].ena  = CheckDes & Rcheck & Rok & (RgDat[3..0] == 2);
   workMemSize[].clk  = RX_CLK;
   workMemSize[].clrn = reset & !P_Reset;
   
   -- РЕГИСТР ЗАДЕРЖКИ ПЕРВЫЙ

   rg_delay_a[].d     = RgDat[31..16];
   rg_delay_a[].ena   = CheckDes & Rcheck & Rok & (RgDat[3..0] == 2);
   rg_delay_a[].clk   = RX_CLK;
   rg_delay_a[].clrn  = reset & !P_Reset;

   -- РЕГИСТР ЗАДЕРЖКИ ВТОРОЙ

   rg_delay_b[].d     = RgDat[47..32];
   rg_delay_b[].ena   = CheckDes & Rcheck & Rok & (RgDat[3..0] == 2);
   rg_delay_b[].clk   = RX_CLK;
   rg_delay_b[].clrn  = reset & !P_Reset;
     
 --===================================================================================================================================== 
  -- флаг разрешения запуска (en_Start)
                       
 en_Start.d     = (RgDat[3..0] == 3) & !en_start_sync; 
 en_Start.ena   = CheckDes & Rcheck  & Rok & !en_WriteData
                # en_Start & en_start_sync; 
 en_Start.clk   = RX_CLK;             
 en_Start.clrn  = !en_WriteData & reset & !P_Reset;             
                
   -- флаг программного запуска

 enP_Start.d    = (RgDat[3..0] == 3) & !P_Start;                                
 enP_Start.ena  = CheckDes  & Rcheck & Rok & RgDat[4]       -- ПРОГРАММНЫЙ ЗАПУСК ФОРМИРУЕТСЯ ПРИ RgDat[4]= 1!
                # P_Start;
 enP_Start.clk  = RX_CLK; 
 enP_Start.clrn = reset & !P_Reset;-- & !Start;                    
 
 -- кто сбрасывает программный запуск?                   
        
 cou_PS[].d     = cou_PS[].q + 1;
 cou_PS[].clk   = RX_CLK;
 cou_PS[].clrn  = enP_Start;
    
 P_Start.d      = (cou_PS[8..2] == 127);
 P_Start.clk    = RX_CLK;
 P_Start.clrn   = enP_Start;

--========================================================================================
-- ЦИКЛ РЕГИСТРАЦИИ ДАННЫХ --=============================================================
 
--sync                                      : input ;  -- 2.4MHz 
--trig (Ext_Start)                          : input ;  -- внешний запуск 

-- флаг инициализации рабочего цикла с привязкой к sync - СИНХРОСИГНАЛ "НУЛЕВАЯ СЕПАРАТРИСА" 2.4 МГц
-- 1. ДЛЯ ЭТОГО НУЖНО СФОРМИРОВАТЬ СИНХРОСИГНАЛ nSYNC ДЛЯ PLL (AD9524), привязанный к нулевой сепаратрисе ( к синхросигналу sync)
-- и задержанный относительно ее на 0,1,2,3,4 периода опорной частоты 181.2 МГц 
-- 2. Запуск процедуры регистрации данных, инициируемый внешним импульсом trig, привязывается к опорным синхроимпульсам АЦП, 
--    уже подстроенным по фазе:
--                             - к моменту появления 0-го, 1-го, 2-го, 3-го или 4-го банча (при регистрации сигналов каждого 5-го банча) 
--                             - к моменту появления каждого четвертого 0-го банча в четырехоборотном "скользящем" режиме регистрации данных
--                              (запуск производится в момент, когда активная фаза синхросигналов АЦП совпадает с нулевой сепаратрицей) 

--===========================================================================================
-- СУБМОДУЛЬ ПРИВЯЗКИ СИНХРОИМПУЛЬСОВ

-- ОПОРНЫЕ СИГНАЛЫ
--ADCCLKa                                   : input ;  -- синхроимпульс от АЦПa (frame данных) 
--ADCCLKb                                   : input ;  -- синхроимпульс от АЦПb (frame данных)
--ADCCLK6a                                  : input ;  -- "БЫСТРЫЕ" синхроимпульсы от АЦПa (300МГц, проходят через PLL) 
--ADCCLK6b                                  : input ;  -- "БЫСТРЫЕ" синхроимпульсы от АЦПd (300МГц, проходят через PLL)
--sync                                      : input ;  -- 2.4MHz нарастающий фронт - нулевая сепаратриса,длительност 70 нс
--trig                                      : input ;  -- внешний запуск


--======================================================================================================================================        
-- флаг запроса на чтение массива данных (R_data_req)
                       
   R_data_req.d     = (RgDat[3..0] == 4) & !enRdataADC; 
   R_data_req.ena   = CheckDes & Rcheck & Rok & (RgDat[3..0] == 4)
                    # enRdataADC; 
   R_data_req.clk   = RX_CLK;
   R_data_req.clrn  = reset & !P_Reset;
   
   -- привязка к TXclk               
                  
   iniRdataADC.d    = R_data_req 
                    # R_data_reqb; 
   iniRdataADC.clk  = TXclk;                              
   iniRdataADC.clrn = !enRdataADC;
   
   enRdataADC.d     = !EndTrans;
   enRdataADC.ena   = iniRdataADC
                    # EndTrans & endReadData  
                    # EndTrans & R_DATA_bl;   -- завершение процедуры чтения блока данных  
   enRdataADC.clk   = TXclk;                  
   enRdataADC.clrn  = reset & !P_Reset; 
   
   -- счетчик количества считанных блоков
   
   cou_nb[19..0].d    = cou_nb[] + 1;
   cou_nb[19..0].ena  = EndTrans;
   cou_nb[19..0].clk  = TXclk;
   cou_nb[19..0].clrn = enRdataADC;
   
   -- флаг-указатель конца текущего цикла чтения данных
   
   endReadData      = (cou_nb[19..4] == read_length[15..0]) & (cou_nb[3..0] == 15);
                        
--====================================================================================================================================== 
-- R_DATA_bl  = (RgDat[3..0] == 5) -- Загрузка НАЧАЛЬНОГО АДРЕСА (НОМЕРА БЛОКА) и Запрос на повторное чтение блока данных

-- РЕГИСТР НАЧАЛЬНОГО АДРЕСА ПРОЦЕДУРЫ ЧТЕНИЯ ДАННЫХ - ДЛЯ ПОБЛОЧНОГО ЧТЕНИЯ ДАННЫХ (УКАЗАТЕЛЬ НОМЕРА ПРОПУЩЕННОГО БЛОКА)!
   
   rg_iniADR_rd[19..0].d    = RgDat[51..32];                                          --(19..0)
   rg_iniADR_rd[19..0].ena  = CheckDes & Rcheck & Rok & (RgDat[3..1] == 2);  
   rg_iniADR_rd[19..0].clk  = RX_CLK;
   rg_iniADR_rd[19..0].clrn = reset & !P_Reset;
   
   -- РЕГИСТР-УКАЗАТЕЛЬ КОЛИЧЕСТВА БЛОКОВ!
   
   read_length[].d     = RgDat[31..16];
   read_length[].ena   = CheckDes & Rcheck & Rok & (RgDat[3..0] == 4);
   read_length[].clk   = RX_CLK;
   read_length[].clrn  = reset & !P_Reset;

   R_DATA_bl.d         = !end_R_DATA_BL;
   R_DATA_bl.ena       = CheckDes & Rcheck & Rok & (RgDat[3..0] == 5)
                       # end_R_DATA_BL;                               
   R_DATA_bl.clk       = RX_CLK;
   R_DATA_bl.clrn      = reset & !P_Reset;
   
   end_R_DATA_BL.d     = vcc;
   end_R_DATA_BL.clk   = TXclk;  
   end_R_DATA_BL.ena   = EndTrans; 
   end_R_DATA_BL.clrn  = R_DATA_bl;
   
   R_data_reqb.d       = (RgDat[3..0] == 5) & !enRdataADC; 
   R_data_reqb.ena     = CheckDes & Rcheck & Rok & (RgDat[3..0] == 5)
                       # enRdataADC;
   R_data_reqb.clk     = RX_CLK;
   R_data_reqb.clrn    = reset & !P_Reset;
   
--======================================================================================================================================
-- Ini_a_p    =	(RgDat[3..0] == 6) -- инициализация PLL и АЦП 

   Ini_a_p.d     = !Ini_a_pd;
   Ini_a_p.ena   = CheckDes & Rcheck & Rok & (RgDat[3..0] == 6)
                 # Ini_a_pd;
   Ini_a_p.clk   = RX_CLK;
   Ini_a_p.clrn  = reset & !P_Reset;
   
   Ini_a_pd.d    = Ini_a_p;
   Ini_a_pd.clk  = RX_CLK;
   Ini_a_pd.clrn = reset & !P_Reset;

--======================================================================================================
-- флаг разрешения процедуры записи данных в iniRAM (RAMini)            ---- ДАННЫЕ???

  enWiniRAM.d    = !(AdrWrRAM[5..0] == 63);         
  enWiniRAM.ena  =  stW_RAM                & (RgDat[3..0] == 7)    
                 # (AdrWrRAM[5..0] == 63)  &  enWiniRAM & WrIniRAM ;
  
---------------------------------------------------------------------------------------------------------
   -- Счетчик адреса порта записи iniRAM 

  AdrWrRAM[].d    = AdrWrRAM[].q + 1;
  AdrWrRAM[].ena  = WrIniRAM & enWiniRAM;        -- запись в iniRAM, ограничение адреса
  AdrWrRAM[].clrn = !Rdestination;                
      
-- Промежуточный триггер для формирования запроса на чтение

   endWIni.d      =  (AdrWrRAM[] == 63); 
   endWIni.ena    =  WrIniRAM & enWiniRAM; 
   endWIni.clk    =  RX_CLK;
   endWIni.clrn   =  reset & !reqREADiniRAM;       
     
----------------------------------------------------------------------------------------------------------
-- запрос на процедуру чтения данных из iniRAM (формируется после записи в это RAM)

 reqREADiniRAM.d  = endWIni & Rcheck;
 
 (enWiniRAM,AdrWrRAM[],reqREADiniRAM,iniRiniRAM).clk  = RX_CLK;
 (enWiniRAM,reqREADiniRAM).clrn = reset; 
 
  -- привязка запроса к TXclk, формирование флага разрешения для процедуры чтения iniRAM

     iniRiniRAM.d    = vcc;
     iniRiniRAM.ena  = reqREADiniRAM; 
     iniRiniRAM.clrn = reset & !enRiniRAM;
     
     stRiniRAM.d     = iniRiniRAM;
     stRiniRAM.clrn  = reset & !enRiniRAM;

     enRiniRAM.d     = stRiniRAM;
     enRiniRAM.ena   = !enRiniRAM & stRiniRAM
                     #  enRiniRAM & (RadrRAM[5..0] == 63) & en_radr_mem;                      
                            
     (iniRiniRAM,stRiniRAM,enRiniRAM,stRiniRAM).clk   = TXclk;
     enRiniRAM.clrn  = reset;
----------------------------------------------------------------------------------------------------------
   -- адресный счетчик портов чтения RAM      
   
     RadrRAM[].d     = RadrRAM[].q + 1;
     RadrRAM[].ena   = en_radr_mem;                                       -- разрешение инкримента адреса от передатчика 
     RadrRAM[].clk   = TXclk;
     RadrRAM[].clrn  = reset & !iniRdataADC & !iniRiniRAM;                -- !Rdestination & сброс при приеме команды
         
--===========================================================================================================
-- задержка старта очередной посылки (интервал между пакетами Ethernet)  !!!!!РАЗОБРАТЬСЯ! НЕ ИСПОЛЬЗУЕТСЯ?

     delayST.d         = StReply                                       & !end_delay    -- ПОДТВЕРЖДЕНИЕ
                       # StEthRdata                                    & !end_delay    -- запуск чтения данных
                       # EndTrans & endReadData & enRdataADC           & !end_delay    -- запуск чтения признака окончания массива
                       # EndTrans & !(couEndData[] == 3) & SendEndData & !end_delay;   -- запуск передачи признака конца массива (продолжение)
              
     delayST.ena       = StReply                                       & !end_delay
                       # StEthRdata                                    & !end_delay
                       # EndTrans & endReadData & enRdataADC           & !end_delay    
                       # EndTrans & !(couEndData[] == 3) & SendEndData & !end_delay   
                       # end_delay;

     couDelSt[].d      = couDelSt[].q + 1;                  
     couDelSt[].clrn   = delayST;

     end_delay.d       = (couDelSt[] == 127);--40);
  
(delayST,couDelSt[],end_delay).clk  = TXclk;
(delayST).clrn = reset & !P_Reset;
-----------------------------------------------------------------------------------------------------
-- флаг разрешения передачи признака конца массива

   SendEndData.d     = !EndSendData; 
   SendEndData.ena   = EndTrans & endReadData & enRdataADC
                     # EndSendData;
   SendEndData.clrn  = reset & !P_Reset;
   
   EndSendData       = (couEndData[] == 3) & EndTrans;                  
                     
   couEndData[].d    = couEndData[].q + 1;                   
   couEndData[].ena  = EndTrans;
   couEndData[].clrn = SendEndData;

(SendEndData,couEndData[]).clk = TXclk;
-----------------------------------------------------------------------------------------------------------------
   EiLr.d    = enIni;                          -- СБРОС элементов модуля в исходное состояние, ИНИЦИАЛИЗАЦИЯ PLL и АЦП
  
 -- задержка

   EiLr_d.d    = EiLr;

(EiLr,EiLr_d,StReply,EnReply,St_EiLr).clk  = TXclk;
(EiLr,EiLr_d,EnReply,St_EiLr).clrn = reset;  

-- формирование сигналов разрешения:

  St_EiLr.d = !EiLr & EiLr_d;                                     -- инициализация и загрузка регистров

  SReply.d       = (RgDat[3..0] == 0) & CheckDes & Rcheck & Rok   -- nop
                 #  St_EiLr                                       -- ResetADC
                 # (RgDat[3..0] == 2) & CheckDes & Rcheck & Rok   -- ЗАГРУЗКА РЕГИСТРОВ                    -- ДОБАВЛЕНО!
                 # (RgDat[3..0] == 3) & CheckDes & Rcheck & Rok   -- разрешение запуска
                 #  stRiniRAM;
                                  
  SReply.ena     = (RgDat[3..0] == 0) & CheckDes & Rcheck & Rok   -- nop
                 #  St_EiLr
                 # (RgDat[3..0] == 2) & CheckDes & Rcheck & Rok 
                 # (RgDat[3..0] == 3) & CheckDes & Rcheck & Rok
                 #  stRiniRAM;
                                  
  SReply.clk     = RX_CLK;
  SReply.clrn    = reset & !EnReply; 
  
-- суммирование сигналов запуска и ПОДТВЕРЖДЕНИЯ, привязка SReply к другой частоте

  enWork_reply.d   = en_WriteData_d;                             -- формирование запуска подтверждения готовности АЦП к чтению данных
  enWork_reply_d.d = enWork_reply;
  
  (enWork_reply,enWork_reply_d).clk  = TXclk;
  (enWork_reply,enWork_reply_d).clrn = reset; 

  StReply.d    = SReply # St_EiLr # !enWork_reply & enWork_reply_d; 
  StReply.clrn = reset & !EnReply;
  
-- флаг ответной передачи, НУЖНО СФОРМИРОВАТЬ ТАКЖЕ nПРИ ПЕРЕХОДЕ en_work в ноль - признак завершения регистрации данных

  EnReply.d    = !EnReply & StReply;
  EnReply.ena  = !EnReply & StReply
               #  EnReply & EndTrans;
    
-----------------------------------------------------------------------------------
-- контроллер шины М2 канала связи Ethernet (передатчик) 
--=================================================================================
-- передатчик 
-- внутренние переменные: 
-- Lenght[15..0]  - длина блока данных, параметр, зависящий от типа передачи  
-- Daddr[47..0]   - регистр адреса партнера (адрес фиксируется при приеме управляющей посылки), 
-- Saddr[47..0]   - собственный адрес, фиксирован для каждого фазометра

-- адрес источника информации (АЦП)

Tr_eth.reset               = reset;
Tr_eth.TXclk               = TXclk;
Tr_eth.RgDat[3..0]         = RgDat[3..0];
Tr_eth.workMemSize[7..0]   = workMemSize[7..0];
Tr_eth.rg_delay_a[15..0]   = rg_delay_a[15..0];
Tr_eth.rg_delay_b[15..0]   = rg_delay_b[15..0];
Tr_eth.EnReply             = EnReply;
Tr_eth.Saddr[47..0]        = Saddr[47..0];
Tr_eth.Daddr[47..0]        = Daddr[47..0];
Tr_eth.SendEndData         = SendEndData;
Tr_eth.StEndData           = end_delay;
Tr_eth.PakN[19..0]         = RadrRAM[25..6]      & !R_data_bl
                           # rg_iniADR_rd[19..0] &  R_data_bl;
Tr_eth.read_length[15..0]  = read_length[15..0]  & !R_data_bl;                               
Tr_eth.enRdataADC          = enRdataADC;
Tr_eth.enRiniRAM           = enRiniRAM;
Tr_eth.en_start            = en_start;
Tr_eth.en_work             = en_WriteData;

Tr_eth.Data_ou[95..0]      = Data_ou[95..0];
Tr_eth.dataRAMini[23..0]   = dataRAM_ini[23..0];
 
TXDout[3..0]    = Tr_eth.TXDout[3..0];
TXena           = Tr_eth.TXena;
EndTrans        = Tr_eth.EndTrans;
en_radr_mem     = Tr_eth.en_radr_mem;
DestinationAddr = Tr_eth.DestinationAddr;
SourceAddr      = Tr_eth.SourceAddr;
PacketLenth     = Tr_eth.PacketLenth;
DataField       = Tr_eth.DataField;                 
data            = Tr_eth.data;

couTransmit[15..0] = Tr_eth.couTransmit[15..0];   

END;