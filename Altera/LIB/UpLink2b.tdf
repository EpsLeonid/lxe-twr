TITLE "UpLink - right version" ;
-- Файл содержит унифицированную реализацию медленного линка КМД-3 - 
-- модуль "UpLink", работающий на нижестоящем узле ССД.
-- Данная часть должна встраиваться в платы сбора данных и обеспечивать 
-- связь с "вышестоящим"
-- по дереву блоком - БППД (он же - селивановская коробка)
% Данная версия расширена узлами :
"Пресэмплер" - автоматическая подстройка фазы, компенсирующая
возможную разность задержки фазы и данных в селивановской коробке
%
Include "CMD3_DAQ_LINK.inc";
Include "PulseShaper.inc";
--INCLUDE "RedirectorRAM.inc" ;
INCLUDE "CRC_Gen.inc";
INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "lpm_counter.inc" ;

PARAMETERS
(
RefClock=100   -- value of frequency (MHz) fed at "Clock" input; 
               -- must be Flink x2, x3 or x4 ;    default=100 (Flink x4)
);
ASSERT (RefClock>24 AND RefClock<126)
REPORT "You enter RefClock (%) which is not suitable for Link function" RefClock
SEVERITY ERROR;

Constant PrescalerModule = RefClock div Link_Speed ;

SUBDESIGN  UpLink
(
-- Module specific signals
-- Connections to Serial Link
LinkClk             : INPUT ;   -- Clock (25MHz) from Link's SynchroLine
LinkData_in         : input ;   -- Serial data <= from DataLine
LinkData_out        : output ;  -- Serial data => into DataLine
TxRx                : OUTPUT; -- направление передачи, управляет приемо-передатчиком LVDS

-- Connections to User Project
Clock               : input;    -- Global Clock used in user project, usually 100MHz 

LinkMessage         : output;-- сообщение о приходе валидной команды, аналог сигнала FLT+ для "энергетических" каналов
IORq                : output; -- Data_ready or Data_required	
RdWr_out            : output; -- =1(Wr) => Data_ready / =0(Rd) => Data_required

OpCode_out[(Command_Size + Pause -1)..0]: output; -- получаемая-она_же-отправляемая команда
InData_out[15..0]   : output; -- 1st word - "InData" 
CRC_Out[15..0]      : output;

DataBus_in[15..0]   : input;    -- отправляемые с Внутренней Шины в Линк данные
DataBus_out[15..0]  : output;   -- выдаваемые на Внутреннюю Шину из Линка данные

Select              : input = GND; -- Link is selected for data reading/writing
RdWr_in             : input = GND; -- RdWr=0 => data will be read from Link / RdWr=1 => data will be written to Link
DataStrobe          : input = GND; -- input data must be latched while DataStrobe=1 

Error               : output;   -- сигнал ошибки (неверная команда)
Reset               : input = GND;   -- Common FPGA Reset

%
-- Master Mode Signals -- используется при работе данного Модуля в режиме Master)
AccessRequest       : output; -- запрос к Арбитру на доступ к шине для чтения/записи данных Пользователя в режиме Master	
AccessGranted		: input;  -- Разрешение Арбитра выставить Адрес и направление обмена (захват шины)
RdWr_out            : output; -- направление передачи данных, на внутреннюю шину или с нее, по умолчанию =GND, передача от внутренних ресурсов платы Модуль,
AddrBusOut[15..0]   : output; -- адрес при операциях доступа ко внутренним ресурсам Оцифровщика (чтения/записи по Командному Листу).
%
-- Slave Mode Signals	-- используется при работе данного Модуля в режиме Slave
--AddrBus_In[15..0]   : input;  -- адрес при операциях доступа чтения/записи Командного Листа с КАМАК-а
	
-- От Пользователя требуется только обеспечить реакцию на запрос модуля Линка
-- (забрать или предоставить данные), не превышающую 18..16 тактов линка. 
-- Число выдаваемых/забираемых Линком определено Протоколом работы Линка 
-- и для данного модуля задано константами.

Test[8..1]          : output ; -- to be conected to test output of main Project 
)

VARIABLE
--******** Automatic Phase Ajustment ********
Prescaler			:	LPM_COUNTER with ( lpm_width=4, lpm_direction="up" );
Prescaler_Desabler	:	SRFF; -- Flag of Phase-Dependent enable 
PrescalerOut		:	node ;  -- enable of action
Presampler			:	DFF	; -- Sampling input data at high clock rate
Sample_Enable		:	node	; -- One FPGA Clock pulse which enables all data moving

--******** Flow Control ********
LinkBitCounter		: LPM_COUNTER with ( lpm_width=WORD_WIDTH, lpm_direction="up" ); -- счетчик числа принятых/переданных бит из/в линк
LinkActive          : node; -- флаг начала цикла приема/передачи данных из/в линк
StartLinkCycle		: node; -- сигнал начала цикла приема/передачи данных из/в линк
EndLinkCycle		: node; -- флаг окончания цикла приема/передачи из/в линк
ChangeDirect        : node; -- сигнал о преключении направления передачи

RxOpCode_ld	        : node;
RxInData_ld         : node;
RxWord_ld           : node; -- сигнал конца фрейма (о приеме одного слова), 
-- высоким уровнем разрешает перезагрузку принятого слова из RxShifter в Reg_RxData
-- LockRxData[WordsToGoDown + 1..0] : node ; -- выходы компараторов-формирователей, используются для явного определения схемы "ИЛИ"

TxOpCode_ld         : node ;
TxInData_ld         : node; -- высоким уровнем разрешает перезагрузку команды и первого слова в TxShifter
TxWord_ld           : node; -- высоким уровнем разрешает перезагрузку слова из TxDataReg в TxShifter
CRC_ld              : node ;
--LockTxWord[WordsToGoUp+1..0] : node ;-- выходы компараторов-формирователей

--******** Reciever Part ********
RxShifter           : LPM_SHIFTREG with (lpm_width=(WordSize + Pause + Pause), -- contains input data (running), sampled at NORMAL rate 
                                    lpm_direction="left"); --shift: q0 -> q[MSB]
Reg_OpCode          : LPM_SHIFTREG with (lpm_width=(CommandSize + Pause), -- contains Command
                                    lpm_direction="left"); -- not important
Reg_InData          : LPM_SHIFTREG with (lpm_width=WordSize, lpm_direction="left");  -- регистр номера события (первое слово после OpCode, влючая биты паузы )
Reg_RxData          : LPM_SHIFTREG with (lpm_width=WordSize, lpm_direction="left");  -- регистр номера события (первое слово после OpCode, влючая биты паузы )
HeaderErr           : node; --  
Header_Error        : node; -- Flag to desable data movement, not TIMING of Link
DeadTimePulse       : PulseShaper with (
                Duration = FLOOR( (DeadTime*RefClock)/ 1000 ) ); -- Формирователь мертвого времени - защитного промежутка
--ParityError         : node; --
--CRC_Error           : node;
RdWr_Error          : node; -- error during Read/Write operation 

--Command[COMMAND_SIZE+PAUSE-1..0]	: node; -- Command is used instead of RegOpCode.q if Error occured
--First_Word[WORD_WIDTH-1..0]	: node;

--******** Transmitter Part ********
TxShifter           : LPM_SHIFTREG with (lpm_width=WordSize,  -- регистр-передатчик выходных данных 
                                    lpm_direction="left"); --shift: q0 -> q[MSB]
Reg_TxData          : LPM_SHIFTREG with (lpm_width=WordSize, lpm_direction="left"); -- регистр-буфер данных передатчика 
%
-- Redirector Part
WordCounter                : LPM_COUNTER with ( lpm_width=OrderOfBitNumber, lpm_direction="up" ); -- счетчик числа принятых/переданных слов

RedirRAM                    : RedirectorRAM;
Addr_Page_offset[9..0]		: node;
Data_Page_offset[9..0]		: node;
--RAM_a_we					: node;
--RAM_b_we					: node;
%
	
CRC_Checker         : CRC_Gen with (PolinomPower = WordSize);

--**********************************************************************************************
BEGIN

DEFAULTS
	RxWord_ld = GND;
	TxWord_ld = GND;
END DEFAULTS;

--============================================================================
--************ Data Sampling and Clock Adjustment ************

-- Input signal from DataLine is being sampled at HIGH rate: Fsampl = Fclk
Presampler.(d, clk) = (LinkData_in, Clock) ;  -- Data is sampled at HIGH rate

			Prescaler_Desabler.clk	=	Clock;
			Prescaler_Desabler.R	=	Presampler.q ; 
			-- Когда Стартовый Бит засэмплируется , то вот здесь-то и отпускаем предделитель,
			-- чтобы его выход стробировал продвижение данных по шифтеру Rx
			--Prescaler_Desabler.S	=	EndLinkCycle OR HeaderError OR Reset;  -- 
			Prescaler_Desabler.S	=	EndLinkCycle OR Reset;

-- Define the proper Bit Detection Frequency: Fbit = Fclk / PrescalerModule 
    IF (Prescaler.q[] == (PrescalerModule-1) ) 	
        THEN PrescalerOut = VCC;
        ELSE PrescalerOut = GND;
    End IF;
Prescaler.clock	=	Clock;
Prescaler.sclr	=	PrescalerOut OR Prescaler_Desabler.q ;
-- Определяем относительную фазу сэмплирования:
    -- Предделитель остановлен в состоянии НОЛЬ, пока не придет Стартовый Бит
    -- первый Sample_Enable возникает, когда счетчик еще стоит в нуле, а 
    -- стартовый бит уже всосался в Prescaler_Desabler, таким образом 
    -- защелкивание стартового бита в шифтер произойдет на следующем клоке
    IF (Prescaler.q[] == b"0000" AND !Prescaler_Desabler.q ) 
        THEN Sample_Enable = VCC;  -- Main Syncro Pulse
        ELSE Sample_Enable = GND;
    End IF;

-- RxShifter: catches serial data, and collects a portion of data 
--            to be transformed to a parallel Data_Word
RxShifter.shiftin   = Presampler.q;                 -- Data are catched..
RxShifter.(clock, enable) = (Clock, Sample_Enable); --.. and shifted at NORMAL rate, 
    -- Момент защелкивания БИТА данных определяется выходной фазой предделителя.
    -- Первый PrescalerOut позволяет защелкнуть стартовый бит в сдвигатель, 
    -- data is shifted q[0] -> q[CommandSize+Pause -1]
RxShifter.aclr	=	Prescaler_Desabler.q ;-- Нет синхронизма - > нет данных
RxShifter.sclr	=	TxRx OR Header_Error ;

--============================================================================
--************ Link Cycle operation Control ************

StartLinkCycle  = RxShifter.q[CommandSize+Pause-1];-- Starting in any case when StartBit enters
LinkActive  = SRFF(.s=StartLinkCycle, .r=(EndLinkCycle OR Reset), .clk=Clock);

CASE RxShifter.q[COMMAND_SIZE+PAUSE-1..0] IS
--    WHEN  CMDL_Cfg_Read     => HeaderErr = GND;   -- Чтение памати редиректора
--    WHEN  CMDL_Cfg_Write    => HeaderErr = GND;	-- Запись в память редиректора
    WHEN  Read1             => HeaderErr = GND;	-- Read  1 word from Object
    WHEN  Write1            => HeaderErr = GND;	-- Write 1 word  to Object
    WHEN  Read              => HeaderErr = GND;	-- Read 62 words from Object(s)
    WHEN  Write             => HeaderErr = GND;	-- Write 8 words  to Object(s)
    WHEN  CMDL_Exe_Read_000 => HeaderErr = GND;	-- Чтение 0
    WHEN  CMDL_Exe_Read_010 => HeaderErr = GND;	-- Start_Regul (Чтение 1)
    WHEN  CMDL_Exe_Read_100 => HeaderErr = GND;	-- Start_Alter (Чтение 2)
    WHEN  CMDL_Exe_Read_110 => HeaderErr = GND;	-- Чтение 3
    WHEN  CMDL_Exe_Write_001=> HeaderErr = GND;	-- Запись 0
    WHEN  CMDL_Exe_Write_011=> HeaderErr = GND;	-- Запись 1
    WHEN  CMDL_Exe_Write_101=> HeaderErr = GND;	-- Запись 2
    WHEN  CMDL_Exe_Write_111=> HeaderErr = GND;	-- Запись 3
    WHEN OTHERS             => HeaderErr = VCC;
End CASE;

Header_Error  = DFFE(.d=HeaderErr, .clk=Clock,  -- check validity...
                       .ena=(StartLinkCycle AND !LinkMessage), --when whole Command entered RxShifter
                       .clrn=!EndLinkCycle);    --reset at the End of Cycle

Error	=	Header_Error OR RdWr_Error ;-- OR Marker_Error_Flag.q ;

-- Управление защелкиванием Reg_OpCode
RxOpCode_ld  = !LinkActive ;


--********  The "reference" counter:  ********
--    counts LinkClock periods => this counter's state defines all signals 
--    which handle the Link operation
LinkBitCounter.(clock,cnt_en)= (clock, (LinkActive AND Sample_Enable));
--LinkBitCounter.sclr = EndLinkCycle OR HeaderError OR Reset ;
LinkBitCounter.sclr = EndLinkCycle OR Reset ;

-- Управление защелкиванием Reg_InData
IF (LinkBitCounter.q[(OrderOfBitNumber-1)..0] == (WORD_WIDTH+PAUSE)) 	
    THEN  RxInData_ld = VCC;    -- _/^\_  ONE pulse
    ELSE  RxInData_ld = GND;
End IF;

-- Генерим схемы совпадения на моменты заполнения Rx shiftera и используем их 
-- для записи Data_Word в буферный регистр приёмника
FOR i in 1 to WordsToGoDown GENERATE
    IF (LinkBitCounter.q[OrderOfBitNumber-1..0] == ((WORD_WIDTH+PAUSE)*(1+i))) 
        Then  RxWord_ld = VCC;  -- _/^\_ - (WordsToGoDown) pulses
        Else  RxWord_ld = GND;
    End IF;
End GENERATE;

-- условие переключения с приема на передачу:
IF  (LinkBitCounter.q[OrderOfBitNumber-1..0] == BitOfReverse)
    THEN ChangeDirect = VCC;            -- переключаемся с приема на передачу
    ELSE ChangeDirect = GND;
END IF;     
-- Receiving mode <=> TxRx=0 / Transmission mode <=> TxRx=1
-- по концу цикла переключаемся на прием (состояние по умолчанию)
--TxRx.(S,clk,R) = (ChangeDirect,Clock,EndLinkCycle OR HeaderError);
TxRx = SRFF(.s=ChangeDirect, .clk=Clock, .r=EndLinkCycle, .clrn=!Reset);


-- Handling  the TxShifter  and  selection of Data to be transmitted:
CASE LinkBitCounter.q[(OrderOfBitNumber-1)..0] IS
-- подсоединяем к Tx шифтеру выходы с Reg_OpCode
    WHEN  BitOfAnswerStart  =>  
                    TxOpCode_ld = VCC;  -- load OpCode
            TxShifter.data[WORD_WIDTH-1..(WORD_WIDTH-(COMMAND_SIZE+PAUSE))] = Reg_OpCode.q[]; 
-- подсоединяем к Tx шифтеру выходы с Reg_InData
	WHEN  Bit_of_Header_UP_Reload => 
                    TxInData_ld = VCC;  -- load InData
                    TxShifter.data[] = Reg_InData.q[];
-- подсоединяем к Tx шифтеру остальные данные
    --WHEN... comparators for strobing data loading are described below
    --                TxShifter.data[] = Reg_TxData.q[];
-- подсоединяем к Tx шифтеру CRC register
    WHEN  Bit_of_CRC_Reload =>  
                    CRC_ld      = VCC;  -- load CRC
                    TxShifter.data[] = CRC_Checker.CRC_Parallel_Out[];
    WHEN OTHERS =>  TxOpCode_ld = GND;
                    TxInData_ld = GND; 
                    TxWord_ld   = GND; 
                    CRC_ld      = GND;
                    TxShifter.data[] = Reg_TxData.q[];
End CASE;

-- Гененерим схемы совпадения на моменты перезагрузки данных в Tx shifter
FOR i in 1 to (WordsToGoUp) GENERATE
    IF  LinkBitCounter.q[(OrderOfBitNumber-1)..0] == ((BitOfAnswerStart+COMMAND_SIZE+PAUSE)+(WORD_WIDTH+PAUSE)*i) 
        THEN  TxWord_ld = VCC; -- формируем импульс для защелкивания данных в регистр Tx shifter
        ELSE  TxWord_ld = GND;
    End IF;
End GENERATE;


-- По концу работы линка запускаем формировку защитного промежутка	
IF ( LinkBitCounter.q[OrderOfBitNumber-1..0] == (MaxNumberOfBit+1) ) 	
    THEN  DeadTimePulse.d = VCC;
    ELSE  DeadTimePulse.d = GND;
End IF;
DeadTimePulse.(Clk, Reset)= (Clock, Reset); -- _/^^^^\_

EndLinkCycle= DeadTimePulse.q ; 

LinkMessage = DFF(.d=LinkActive, .clk=Clock) OR EndLinkCycle ; -- Connection to User Interface, one clock later,
--	 when OpCode locked. Duration extended with DeadTime.

--============================================================================
--************ Registers and Bus Connections ************
-- Here the Registers which take part in data transmission and their
-- connections to user project are defined

-- Reg_OpCode catches and holds the OpCode
Reg_OpCode.data[(CommandSize+Pause-1)..0]= RxShifter.q[(CommandSize+Pause-1)..0];
Reg_OpCode.(clock, enable, load)= (Clock, RxOpCode_ld, VCC); -- catch data when RxOpCodeReload=1 
Reg_OpCode.(aclr, sclr)         = (Reset, EndLinkCycle );

--IF (Header_Error == GND)      -- 
--    THEN  Command[]	= Reg_OpCode.q[];   -- If OpCode valid - send it to user project
--          First_Word[]= Reg_InData.q[];
--    ELSE  Command[]   = CMDL_Cfg_Read ;   -- Substitution if Error found
--          First_Word[]= 512; -- Addreses of Pedestals
--END IF;
OpCode_out[]    = Reg_OpCode.q[];           -- OpCode => user project

-- Reg_InData catches and holds the InData_word
-- Note: If Error, Reg_InData will be loaded with 0000, since RxShifter is cleared
Reg_InData.data[(WordSize-1)..0]= RxShifter.q[(WordSize+Pause-1)..Pause]; 
Reg_InData.(clock,enable, load) = (Clock, Sample_Enable AND RxInData_ld, VCC);
Reg_InData.(aclr, sclr)         = (Reset, EndLinkCycle%GND% );
InData_out[15..0]   = Reg_InData.q[15..0];  -- InData => user project
--AddrBus_out[15..0] = Reg_InData.q[15..0]; -- InData используется как адрес 
            -- только при операциях Rd/Wr  from/to  user project's objects

-- Reg_RxData catches and holds the data words coming in Command_Sequence
-- Note: If Error, Reg_RxData will be loaded with 0000, since RxShifter is cleared
Reg_RxData.data[(WordSize-1)..0]= RxShifter.q[(WORD_WIDTH+PAUSE-1)..PAUSE]; 
Reg_RxData.(clock, enable, load)= (Clock, Sample_Enable AND RxWord_ld, VCC);
Reg_RxData.(aclr, sclr)         = (Reset, EndLinkCycle );
DataBus_out[15..0] = Reg_RxData.q[15..0];   -- Data received => user project

-- Buffer register: loads Data words to be transmitted from Data bus
Reg_TxData.data[]  = DataBus_in[]; -- подключение буферного параллельного регистра Tx к интерфейсу пользователя
Reg_TxData.(clock, enable, load) = (Clock, 
                (Select AND DataStrobe AND RdWr_in), VCC); -- load data at "Write" operation when DataStrobe comes
Reg_TxData.(sclr, aclr) = (EndLinkCycle, Reset);

-- TxShifter: loads Data_Word to be transmitted and shifts it,
--            thus transforming a parallel Data_Word into serial bits sequence
TxShifter.shiftin = GND; -- используется для создания паузы (сдвигаем на PAUSE тактов)
--TxShifter.data[] -- see above, in "Link Cycle operation Control" section
TxShifter.(clock,enable)= (Clock, Sample_Enable); -- сдвигаем данные для передачи в линк
TxShifter.load  =   TxOpCode_ld
                OR  TxInData_ld
                OR  TxWord_ld
                OR  CRC_ld ;    -- защелкиваем данные для передачи в линк

LinkData_out = TRI(TxShifter.shiftout, TxRx); -- connection to BIDIR output

--============================================================================
--************ Section "User Interface Control" ************
IORq    =SRFF(.S=(((RxInData_ld # RxWord_ld)& Sample_Enable)  -- Request: user should read data
                OR((TxInData_ld # TxWord_ld)& Sample_Enable)),-- Request: user MUST supply data
    -- С-л TxInData_ld грузит "InData" в TxShifter, и запрашиват чтение с шины 
    -- в Reg_TxData (не инкрементируя счетчика слов).  Следующий запрос на 
    -- чтение возникает одновременно с перезагрузкой в TxShifter уже готового 
    -- слова данных, прочитанного по первому запросу.
               .R=(Select AND DataStrobe),   -- Reset when data transfer done
               .clk=Clock,
               .clrn=!(EndLinkCycle # Reset)) ;

RdWr_out= SRFF(.S=(RxInData_ld OR RxWord_ld),--"Write": Link => user project
               .R=(Select AND DataStrobe),   -- Reset when data transfer done
               .clk=Clock,
               .clrn=!(EndLinkCycle # Reset)) ;

-- When RdWr_out=1: (Link => UserProj ("Write")) requested, =>     \
--    => UserProj should "read" data from Link => RdWr_in must be =0\ Must be:
-- When RdWr_out=0: (Link <= UserProj ("Read")) requested, =>       /RdWr_in != RdWr_out
--    => UserProj must "write" data to Link => RdWr_in must be =1  /
IF ( ((IORq & Select) == VCC) AND (RdWr_in == RdWr_out) ) 
    Then RdWr_Error = VCC; 
    Else RdWr_Error = GND;
End IF;

--============================================================================
-- CRC Checker
CRC_Checker.Clock				=	Clock;
CRC_Checker.Bit_Sample_Enable	=	Sample_Enable;
CRC_Checker.Serial_In			=	TxShifter.shiftout;
CRC_Checker.Reset				=	Reset ;

%-- CRC_Gen control for data block only
CRC_Checker.Start_Seed_Load = TxHeaderReload ; -- CRC Check begin with
CRC_Checker.Message_End		=	TxWordReload;
%
-- CRC_Gen check from Start Bit
CRC_Checker.Start_Seed_Load 	=	TxRx ;
CRC_Checker.Message_Begin		=	TxOpCode_ld;

CRC_Out[]   = CRC_Checker.CRC_Parallel_Out[];

--============================================================================
--Test1 = CRC_Checker.Residue_OK ;
Test1 = Sample_Enable;
Test2 = LinkActive ;--Sample_Enable ;
Test3 = RxOpCode_ld OR RxInData_ld OR RxWord_ld;
Test4 = TxInData_ld OR TxWord_ld ;--TxInData_ld ;
Test5 = RxShifter.q[0];
Test6 = RxShifter.q[1];
Test7 = RxShifter.q[2]; 
--Test7 = CRC_Checker.Test1;
Test8 = LinkBitCounter.q0 ;
--Test8 = CRC_Checker.CRC_Serial_Out;

END;