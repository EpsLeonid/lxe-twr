TITLE  "Processor" ;    -- Multifunctional Processor Unit

******************************************************************************
<<<<_____ PROCESSOR module - A  LOOK  INSIDE ____>>>              ┌──┐   ─┬─        
                                                                  │  │ ├──┼──┤ 
SEE  FUNCTIONAL  SCHEMATIC !                               └──┘   ─┴─  

==============================================================================

ПРОЦЕССОР
----------
    ПРОЦЕССОР включает в себя : 
- ОЗУ ProgRAM, в котором записаны программы
- основной счетчик адреса ProgCt
- счетчик проходов по циклу PassCt
- Таблицу LUT_ProgCtrl, вырабатывающую сигналы управления Микропрогр.автоматом 
- "Регистр" из триггеров, названных именами сигналов - для фиксации сигналов 
  управления основными узлами Процессора
- локальную шину данных, с мультиплексором на входе - мультиплексор позволяет 
  выбрать источник данных

    Запуск программы производится следующим образом.  Сразу после поступления
сигнала ProgInit (по фронту 1-го Клока) с-л ProgStart становится =1, и стоит 
в сост-и "1" до момента, когда триггер ProgInit1 установится в "1" (за 1Клок 
до фронта 25МГц-Клока).  Когда ProgInit1=1, на входы данных счетчика ProgCt 
подается НАЧАЛЬНЫЙ адрес запускаемой программы.  Через 1Клок после того, как 
ProgInit1 стал =1, триггер ProgInit2 тоже переключается в "1", и находится 
в сост-и "1" в течение 1/2Клока.  Импульсом ProgInit2 производится асинхронная 
загрузка начального адреса.  После этого управление работой Процессора произ-
водится согласно программным словам, вычитываемым из ОЗУ; таким образом, на-
чинается выполнение программы.

    ProgCt перещелкивается именно по тому _/ 100МГц-Клока, который совпадает 
с _/ или \_ 25МГц-Клока.  Момент перещелкивания ProgCt будем считать НАЧАЛОМ 
выполнения Операции.  Новый адрес защелкивается в регистр адреса ProgRAM по \_ 
(через 5нс после Начала Оп-и), а выходные данные защелкиваются в выходном 
регистре ProgRAM по следующему \_ (через 15нс после Начала Оп-и). 

Значение битов слова ПЗУ:
16  \                           000 - ?? HALT
15   > Command Type             001 - set Control word
14  /                           010 - load PassCt (preparation for Loop)
13  Tx_Enable                   011 - IF(PassCt>#0) - decr PassCt & go to next Pass
12  DataBus_addr3                         else incr ProgCt (go further)
11  DataBus_addr2               100 - Load ProgCt (JUMP Unconditional)
10  DataBus_addr1                . . . 
 9  RAM_we                      111 - END_of_Prog
 8  RAM_Ct_load
 7  RAM_Ct_count
 6  Reg2_ADC2_shift
 5  Reg2_ADC2_load
 4  Reg2_ADC1_shift
 3  Reg2_ADC1_load
 2  ADC_cs  / Shift in Reg1_ADCx
 1  MUX_Ct_count

    Четыре старших бита ProgRAM.q[15..12] (Код_Операции) поступают на Табли-
цу LUT_ProgCtrl, вырабатывающую сигналы управления Микропрограммным Автоматом, 
через лэтчи.  Это обеспечивает возможность зафиксировать Код_Оп-и в операциях, 
в которых вычитывается следующее за словом Кода_Оп-ции слово, и в то же время
получается минимальная задержка прохождения сигналов от выходного регистра 
ОЗУ до Таблицы.  От момента защелкивания нового слова программы в выходном 
регистре ProgRAM (по \_) до следующего _/ (следующее Начало Оп-ции) остается 
1/2Клока, т.е. 5нс. 

 25MHz Clock  __________/~~~~~~~~~~~~~~~\_______________/~~~~~~
100MHz Clock  __/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\__

ProgCt_Cen    ______/^^^^^^^\_______/^^^^^^^\_______/^^^^^^^\__
ProgCt.q[]    ___________XXX
ProgRAM addr  _______________XXX
ProgRAM.q[]   _______________________X




    Выполнение программных циклов организуется следующим образом. Перед 
началом цикла (в слове, предшествующем первому слову цикла, или немного 
раньше) должна быть записана команда ("Load",Ddst=PassCt,#nnnnnnnn), 
где "nnnnnnnn"=(требуемое_число_циклов). По этой команде число "nnnnnnnn" 
записывается в PassCt. После загрузки PassCt Процессор, последовательно 
выполняя дальнейшие команды, проходит по циклу первый раз, и доходит до 
последней команды цикла. В последнем слове цикла должна быть записана 
команда ("EndLoop",..,#aaaaaaaa), где "aaaaaaaa" - адрес первой команды 
цикла. 
По команде "EndLoop": 
-   если содержимое PassCt > 1, то: 1) в основной счетчик адреса ProgCt 
  загружается число "aaaaaaaa" => следующей будет выполняться команда, 
  являющаяся первой в цикле, 2) счетчик циклов PassCt декрементируется.
-   если содержимое PassCt = 1 (во время последнего прохода), то: 
  1) ProgCt инкрементируется => Процессор выходит из цикла и начинает 
  выполнять дальнейшую программу, 2) PassCt так же декрементируется (чтобы 
  выход PassCt.eq1 стал =0 и не держал сигнал Condition в =1). 
    При выполнении команды "EndLoop" управляющие сигналы для счетчика ProgCt 
(ProgCt_count и ProgCt_load) должны быть установлены ДО Начала следующей 
Операции, то есть от момента, когда код команды вычитывается из ProgRAM до 
установления управляющих сигналов на ProgCt должно быть < 5нс (!).  Поэтому
логическая схема, которая формирует эти сигналы, сделана максимально 
простой: проверяется состояние всего 6 сигналов ( OpCode (4 бита), Condition 
и LastStage ).  Вследствие этого сигнал Condition формируется следующим 
образом.  По умолчанию он равен сигналу PassCt.eq1; таким образом, во время 
выполнения команды "EndLoop" сигнал Condition на момент вычитывания команды 
равен сигналу PassCt.eq1, что позволяет сразу же использовать его для выра-
ботки сигналов ProgCt_count и ProgCt_load.  При выполнении же команд услов-
ного перехода (JumpCnd) и ожидания (Wait) принятие решения прохождение сигнала PassCt.eq1 
в сигнал Condition маскИруется 
, и только 
во время выполнения команд условного перехода (JumpCnd) и ожидания (Wait) 
сигнал Condition равен состоянию флага CoincidTrig.   
    

    В конце программы, который обозначается командой End_of_Prog 
(R_ROM_q[16..14]=B"111"), счетчик ProgCt устанавливается в сост-е #255. 
В 255-й ячейке ПЗУ записана команда "Halt", по которой сигнал ProgCt_count 
обнуляется, и микропрограммный автомат остается в этом состоянии.  


РАБОЧИЙ  ЦИКЛ  ОЦИФРОВКИ
-------------------------
    Цикл оцифровки по с-лу "START" выполняется при условии, что триггер 
готовности R_StdBy взведен (по F25A0). Цикл начинается по фронту сигнала 
Start (он же - "Блокировка"). Этот фронт является "Общим Стопом": по этому 
фронту устанавливается триггер U5a (вне Альтеры), сигнал которого управляет 
работой аналоговых каналов. По этому сигналупроизводятся следующие действия. 
Во-первых, все FORы устанавливаются в активное состояние (LOW), тем самым 
заканчивая преобразование t->U. Во-вторых, прекращается запись состояния 
FOR-ов в Reg_Hit, так что в этом регистре остается защелкнутым состояние 
FOR-ов, присутствовавшее непосредственно перед фронтом Start-а. В-третьих, 
инициируется выполнение программы оцифровки Микропрограммным автоматом. 

    В начале цикла оцифровки производится "инициирование" программы: 
в счетчик адреса микропрограмм Prog_Ct загружается начальный адрес программы 
оцифровки, счетчики адреса RAM_Ct, содержащий текущий адрес ОЗУ, и MUX_Ct, 
управляющий аналоговым коммутатором, обнуляются. 
    В начале программы после заполнения регистра Reg_InData его содержимое 
записывается в ОЗУ (в адрес #1), а также в Reg_IOData - для последующей 
передачи в Линк. Затем счетчик адреса ОЗУ RAM_Ct инкрементируется, и содержимое 
регистра Reg_Hit записывается в ОЗУ (в адрес #1). 
    После этого выполняется ожидание в течение заданного числа тактов. 
    "Ответная_посылка" должна начаться на 161-м такте (согласно Протоколу 
работы Линка). Передатчик TTL=>LVDS необходимо активировать заранее. Поэтому 
на 157-м такте выставляется с-л OutD_en на 1 такт, так что с-л TxRx переклю- 
чается в "1", и затем поддерживается в этом состоянии с помощью RS-триггера. 
По с-лу TxRx=1 приемопередатчик TTL<=>LVDS устанавливается в режим передачи. 
Однако, выдача данных в Линк будет разрешена только тогда, когда лог.1 дойдет 
по цепочке триггеров до триггера OutD_del4, и он установится в "1". Поэтому 
в течение 4 тактов уровни в линии нормализуются к состоянию, соответствующему 
передаче лог.0 . 
    На 161 такте  снова устанавливается с-л OutD_en=1, и начинается передача 
Ответной_посылки: с помощью мультиплексора LinkMUX вход оконечного триггера 
Link_OutD подключается в нужной последовательности к VCC и GND, выполняя 
таким образом передачу [1-OpCode]. 
    После 2 тактов паузы начинаются два параллельных процесса: оцифровка 
данных с помощью двух АЦП и передача данных в Линк. АЦП тактируются частотой, 
равной частоте "Фазы" (12.5МГц), а Линк работает на двойной частоте (25МГц). 
Поэтому за время, в течение которого два АЦП синхронно выдают по 1 слову 
данных, два предыдущих слова данных поочередно передаются по Линку. 
Во время оцифровки первых двух напряжений в Линк выдаются два слова данных - 
InData и слово FOR-ов из Reg_Hit. 
    Это делается следующим образом. Одновременно с этим   Link_OutD подаются 
данные с Reg_IOData.q15, и в течение 15 тактов производится сдвиг данных 
(слово InData) в этом регистре, таким образом в Линк выдается InData. 
Затем в течение 4-тактовой паузы в Reg_IOData загружается содержимое Reg_Hit. 
После паузы снова устанавливается OutD_en=1, и делается сдвиг в Reg_IOData, 
при котором слово Hit-ов выдается в Линк. 
    Параллельно с этим на АЦП подаются управляющие сигналы, и АЦП начинают 
выдавать данные в последовательном виде. Эти данные от каждого АЦП записываются 
по последовательному входу в соответствующий регистр (Reg1_ADC1 и Reg1_ADC2).
Когда первое слово данных от каждого АЦП полностью загружено в Reg1_ADCx, 
эти данные в параллельном виде переписываются в два соответствующих регистра 
Reg2_ADCx, после чего регистры Reg1_ADCx готовы к приему новых данных от АЦП.  
[   ПОКА: 1) Reg1_ADC1 => RAM(addr=#even);  2) Incr. RAM_Ct;  
[ 3) Reg1_ADC2 => RAM(addr=#odd); в это время еще идет передача Reg2_ADC2=>Link
[ Теперь передача закончена, поэтому 4) Reg1_ADCx => Reg2_ADCx; идем повторять
[ цикл сначала.
Данные из Reg2_ADCx переписываются в ОЗУ, после чего поочередно снова преобра-
зуются в последовательный вид и передаются в Линк. 
[   ВНИМАНИЕ! 
[   Чтобы начало и конец c-ла ADC_cs совпадали с _/ с-ла ADC_clk, сделано 
[ следующее: 
[ 1) Триггер ADC_clk перещелкивается по \_ Клока, т.е. синхронно с "регистром"
[   "Reg_Contr"; а конкретно, поскольку работа триггера ADC_clk разрешается по 
[   с-лу Prog_run=1, _/ ADC_clk происходит в те же моменты, когда на выходе 
[   "Reg_Contr" появляются слова, содержащиеся в ЧЕТНЫХ адресах ПЗУ. 
[ 2) Поэтому соотв-щая смена состояния бита R_ROM_q2 должна происходить при 
[ переходе от нечетного к четному адресу (иными словами, новое состояние 
[ бита R_ROM_q2 должно начинаться с ЧЕТНОГО адреса). Соотв-но, длина ЦИКЛА
[ оцифровки одного канала должна быть равна четному числу тактов. 

    Все основные функциональные узлы Receiver-a (счетчики, регистры) меняют 
состояния по _/ Клока, поэтому сигналы, управляющие их режимами, надежнее 
всего менять по \_ Клока => сделано, что триггеры "регистра" Reg_Ctrl меняют 
состояния по \_ (хотя, при необходимости, можно сделать смену состояний 
триггеров ADC_cs и Reg1_ADC_Cen по _/). 


    Появилась новая идея - более экономно (и перспективно) сделать так: 
    Оцифровка производится по ADC_cs, из этого с-ла с помощью простой схемки 
делается с-л сдвига для Reg1_ADCx, и из него же с помощью не менее простой 
схемки делается Reg2_ADCx_Cen и Reg2_ADCx_load длиной 1 Клок. Таким образом, 
для управления всей этой требухой от ПЗУ берется только 1 бит. Данные, полу-
ченные от АЦП и преобразованные в параллельны вид, по следующему (после приема 
последнего бита данных от АЦП) такту тупо переписываются в Reg2_ADCx. 
   Затем шина Data подключается к Reg2_ADC1, и данные записываются в ОЗУ, а 
также одновременно и в Reg_IOData. После этого счетчик адреса ОЗУ инкремен- 
тируется, шина Data подключается к Reg2_ADC2, и данные записываются в ОЗУ. 
В это же время можно уже передавать слово данных (от ADC1), содержащееся в 
Reg_IOData, в Линк. После передачи этого слова данных в Reg_IOData перепи-
сывается слово данных из Reg2_ADC2, и это слово также передается в Линк.


  По окончании цикла оцифровки вырабатывается с-л ProgEnd. По этому с-лу: 
-   устанавливается триггер R_Ready, по с-лу которого уст-ся LAM
-   сбрасывается триггер R_Cycle
-   вырабатывается с-л EndConv, который подготавливает аналоговые каналы к 
  приему следующих сигналов.
[ ВНИМАНИЕ! В связи с тем, что с-л "Блокировка" поступает непосредственно 
[ на триггер U5a, чтобы не возникал затык при 
[
[   C-л EndConv должен возникать ПОСЛЕ окончания оцифровки и заканчиваться 
[ ПОЗЖЕ окончания "Блокировки", чтобы триггер U5a пришел в исходное состояние. 
[ Для продления EndConv сделан триггер Start_end, который устанавливается 
[ с-лом ProgEnd при НАЛИЧИИ "Блокировки" (иначе его нечем будет потом сбросить),
[ а сбрасывается по концу "Блокировки").
[

 
==============================================================================
2.  CAMAC  PART
================

    CAMAC-интерфейс включает в себя:
-   Схему выбора фазы Клока (C_Tr1, C_Tr2)
[-   Схему, формирующую сигналы начала и конца цикла (C_CycleBeg и C_CycleEnd)]
-   Главную ПЛМ C_LUT1, формирующую управляющие сигналы для CAMAC-интерфейса
-   Регистр  C_RegCtrl[], содержащий управляющие с-лы в течение CAMAC-цикла
-   Регистр адреса  C_RegAddr[8..1]
-   "Статусный_Регистр": его 8[..4] биты представляют собой триггеры с 
  индивидуальными осмысленными именами (Mode [, ..., ...]), а 4..1 биты пере-
  дают состояние с-лов (DataReady, R_StdBy, Gate, "Блокировка"). 
-   Схему, формирующую управляющие сигналы для передачи 16 слов (коды порогов) 
  из ОЗУ RAM в регуляторы порога (сигналы Dasy_d и Dasy_c, TrimDAC_d и 
  TrimDAC_c). В эту схему входят: микропрограммный автомат (счетчик C_ProgCt и 
  ПЗУ C_ROM), триггеры, управляющие работой этого микропрограммного автомата 
  (C_ProgTr1, C_ProgTr2, C_Prog_run, C_Prog_work), триггер Dasy_c.

    Обработка CAMAC-команды начинается по приходу N=0. По ближайшему переходу 
Local_Clk (_/ или \_) выбирается, инвертировать его или не инвертировать при 
подаче на шину C_c. 
    При переходе с-ла N из 1 в 0 триггеры C_N1...C_N4 последовательно переходят 
из "0" в "1", и состояние (C_N3=1 C_N4=0) обозначает начало CAMAC-цикла. В этот 
момент ПЛМ C_LUT1 определяет, учитывая текущее состояние Блока, разрешено ли и 
возможно ли исполнение поступившей команды. Если да, то выдаются (X=1, Q=1), и 
начинается выполнение этой команды. В противном случае выдаются (X=1, Q=0). 

CAMAC-функции: 
--------------- 
см. ниже, в гл. "T2Q module - a look from outside". 

Решение об исполнении команды принимается следующим образом: 

-   Если в момент поступления команды Блок не производит никаких действий, то 
  принимается и выполняется любая команда.

-   Команда "RESET_All" (F30Axx, кроме F30A1) выполняется всегда. Сбрасываются 
  все триггеры, поддерживающие работу микропрограммных автоматов, счетчики 
  адреса программ, триггеры готовности.
-   Команда "RESET_Digitizer" (F30A1) выполняется всегда. Сбрасываются все 
  триггеры, поддерживающие работу микропрограммного автомата DIGITIZER-а, 
  счетчик адреса программ R_ProgCt, триггер Mode.

-   Команды записи/чтения регистров (F16Axx / F0Axx) выполняется, если в 
  момент ее поступления не производится цикл загрузки кодов в TrimDACs
  (C_Prog_run = 0), не производится цикл оцифровки (R_Cycle = 0) и 
  триггер готовности к оцифровке сброшен (R_StdBy=0). 

-   Команды записи/чтения данных в/из ОЗУ (F17A8 / F1A8) выполняется, если в 
  момент ее поступления не производится цикл загрузки кодов в TrimDACs
  (C_Prog_run = 0), не производится цикл оцифровки (R_Cycle = 0) и 
  триггер готовности к оцифровке сброшен (R_StdBy=0). 

[-   Для чтения оцифрованных данных используется спец. команда F2Axx. Она 
[  выполняется только при наличии сигнала готовности данных (R_Ready) И если 
[  не производится никаких действий. 

-   Команда загрузки кодов в TrimDACs (F18A0) выполняется, если в момент ее 
  поступления не производится цикл загрузки кодов в TrimDACs (C_Prog_run = 0),
  не производится цикл оцифровки (R_Cycle = 0) и триггер готовности к оцифровке 
  сброшен (R_StdBy=0). 

-   Команда "Get_Ready_for_Start" (F25A0) выполняется, если в момент ее 
  поступления не производится никаких действий, и если Блок не находится уже 
  в состоянии готовности к оцифровке (R_StdBy = 0).
-   Команда "Compulsive_Digitizing" (F25A1) выполняется, если если в момент ее 
  поступления не производится никаких действий, и независимо от состояния 
  триггера R_StdBy.

    При выполнении команд чтения/записи в RAM используется, ессессно, внут-
ренняя шина данных Data[16..1]. При чтении данных источником с-лов для шины 
должно быть RAM (выбирается при DataMUX_address = #7), а при записи - входы 
W[16..1] (выбирается при DataMUX_address = #0). Установка адреса для муль-
типлексора DataMUX осуществляется путем сброса/установки триггеров 
DataMUX_addr[3..1] по входам Clrn/Prn. 
    При выполнении команд "Get_Ready_for_Start" "Compulsive_Digitizing" соот-
ветствующий триггер (R_StdBy или R_Start1) взводится с задержкой на 6-7мкс 
после CAMAC-цикла. При этом Start, вызванный FORами, сработавшими от наводок 
во время самогО этого CAMAC-цикла, заведомо уже прошел и не может вызвать 
ложного запуска. 

Режим "NORMAL" - триггер Mode устанавливается в "1" (при записи в "Статусный 
  регистр"). В этом режиме разрашается прием команд с Линка и выдача FORов 
  на шины R и W магистрали CAMAC. 
    Хотя выполнение CAMAC-циклов возможно (т.к. выдача FORов на магистраль 
  CAMAC блокируется с-лом Busy), РЕКОМЕНДУЕТСЯ на время работы с CAMACом 
  переключать все платы T2Q в крейте в режим "CAMAC". 

Режим "CAMAC" -   Триггер "Mode" сбрасывается в "0" ; При этом подается сигнал 
  асинхронного сброса на триггер Link_d, тем самым запрещая прием команд с 
  Линка. Операция (например, оцифровка) выполняется по команде от CAMACа, 
  (код операции записывается в Reg_OpCode по параллельным входам).



========================================================================
ИЗМЕНЕНИЯ, внесенные для ТЕСТОВ
--------------------------------
1.  На ногу PhaseDetect подается частота Local_clk, деленная на 8. 

3.  Чтобы сделать повторяемое "Принудительное Data_Reading" по F25A0, сигнал 
  R_Ready отключен от входной комбинации F25A0

4.  Тактовый сигнал для Receiver_Part взят с Local_clk

[ 5.  Бит R_ROM_q13 используется для имитации послед. кода АЦП, и подан на 
[   входы регистров Reg1_ADC1 (без инверсии) и Reg1_ADC2 (с инверсией)


ВЕРСИИ
-------
t2q_2.tdf    - отлажены запись/чтение данных в/из ОЗУ по КАМАКу

t2q_4.tdf    - запущен Микропрограммный Автомат Receiver-a, 
                 отлажены ADC_cs и ADC_clk; Принуд.оцифровка по F25A0

t2q_5tst.tdf - запущена запись "последовательных данных" (имитируемых с 
                 помощью ПЗУ) в ОЗУ.

t2q_6tst.tdf - отлажены запись/чтение данных в/из ОЗУ по КАМАКу;
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП. Т.о., обеспечено чтение оцифрованных данных 
                 в КАМАК. "Принудительная оцифровка" по F25A0.
                 Отлажена прописка кодов в TrimDACs. - из-за ошибки в разводке 
                 пришлось ее дорабатывать - see t2q_8tst.tdf 

t2q_7.tdf    - отлажены запись/чтение данных в/из ОЗУ по КАМАКу; 
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП. Т.о., обеспечено чтение оцифрованных данных 
                 в КАМАК. "Готовность к оцифровке" по F25A0, начало 
                 оцифровки по внешнему Start-у.

t2q_8tst.tdf - отлажены запись/чтение данных в/из ОЗУ по КАМАКу;
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП, выполнение программных циклов. Т.о., обеспечено 
                 чтение всех оцифрованных данных в КАМАК. 
                 "Принудительная оцифровка" по F25A0. 
                 Выдается сигнал "FLT+_Async" по "16OR Fors".
                 Отлажена прописка кодов в TrimDACs, с учетом ошибки в 
                 разводке. 

t2q_9.tdf     - отлажены запись/чтение данных в/из ОЗУ по КАМАКу;
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП, выполнение программных циклов. Т.о., обеспечено 
                 чтение всех оцифрованных данных в КАМАК.
                 "Готовность к оцифровке" по F25A0 (R_StdBy взводится с 
                 задержкой 6-7мкс после CAMAC-цикла), начало оцифровки по 
                 внешнему Start-у. "Принудительная Оцифровка" по F25A1 (R_Start 
                 взводится с задержкой 6-7мкс после CAMAC-цикла). 
                 Выдается сигнал "FLT+_Async" через 1280ns после "16OR Fors". 
                 Его можно использовать как "Start". 
                 Отлажена прописка кодов в TrimDACs, с учетом ошибки в 
                 разводке. 

t2q_9tst.tdf  - отлажены запись/чтение данных в/из ОЗУ по КАМАКу;
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП, выполнение программных циклов. Т.о., обеспечено 
                 чтение всех оцифрованных данных в КАМАК. 
                 "Готовность к оцифровке" по F25A0 (R_StdBy взводится с 
                 задержкой 6-7мкс после CAMAC-цикла), начало оцифровки по 
                 внешнему Start-у. "Принудительная Оцифровка" по F25A1 (R_Start 
                 взводится с задержкой 6-7мкс после CAMAC-цикла). 
                 Выдается сигнал "FLT+_Async" через 1280ns после "16OR Fors". 
                 Его можно использовать как "Start". Чтобы аналоговая часть 
                 успевала очухаться, выдача Start-а блокируется на 144мкс 
                 после начала цикла оцифровки (т.е. заведомо остается время 
                 после его окончания).
                 Отлажена прописка кодов в TrimDACs, с учетом ошибки в 
                 разводке. 

t2q_10lnk.tdf - отлажены запись/чтение данных в/из ОЗУ по КАМАКу;
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП, выполнение программных циклов. Т.о., обеспечено 
                 чтение всех оцифрованных данных в КАМАК.
                DIGITIZER работает по клоку ОТ ЛИНКА !
                отлажена работа по команде, поступающей с Линка; 
                отлажена (почти проверена) передача оцифрованных данных в Линк.
                 "Готовность к оцифровке" по F25A0 (R_StdBy взводится с 
                 задержкой 6-7мкс после CAMAC-цикла), начало оцифровки по 
                 внешнему Start-у. "Принудительная Оцифровка" по F25A1 (R_Start 
                 взводится с задержкой 6-7мкс после CAMAC-цикла). 

t2q_10tst.tdf - отлажены запись/чтение данных в/из ОЗУ по КАМАКу;
                 отлажено управление мультиплексорами и ключами, прием
                 данных от АЦП, выполнение программных циклов. Т.о., обеспечено 
                 чтение всех оцифрованных данных в КАМАК.
                DIGITIZER работает по клоку ОТ ЛОКАЛЬНОГО ГЕНЕРАТОРА,
                 поэтому прием команд с линка ОТКЛЮЧЕН. 
                отлажена (почти проверена) передача оцифрованных данных в Линк.
                 "Готовность к оцифровке" по F25A0 (R_StdBy взводится с 
                 задержкой 6-7мкс после CAMAC-цикла), начало оцифровки по 
                 внешнему Start-у. "Принудительная Оцифровка" по F25A1 (R_Start 
                 взводится с задержкой 6-7мкс после CAMAC-цикла). 


******************************************************************************
<<<<_____ T2Q MODULE - A  LOOK  FROM  OUTSIDE ____>>>>

==============================================================================
1.  DIGITIZER  PART
====================

Функциональные узлы ОЦИФРОВЫВАЮЩЕЙ части
-----------------------------------------
    Узлы DIGITIZERa, ощутимые для пользователя:
-   Регистр Reg_InData, в который записывается слово данных, приходящее 
  по Линку сразу после Кода_Операции
-   Регистр Хитов, в который записывается состояние с-лов FORов
-   ОЗУ RAM, в котором содержатся все данные

ОБРАБОТКА  FORов
-----------------
    Состояние FORов постоянно пишется в регистр Reg_Hit до прихода сигнала 
"Блокировка". Таким образом, в этом регистре оказывается защелкнутым состояние 
FORов на момент последнего перед фронтом "Блокировки" фронта Клока. 16-битное 
слово данных, соответствующее этому состоянию, записывается в ОЗУ (в адрес 
#01), и может быть передано по Линку. 
    ДЛЯ  ТРИГГЕРА сигналы FORов обрабатываются следующим образом. Они проходят 
через вентили "И", которые позволяют замаскИровать нежелательные каналы. 
16-битное слово "маски" содержится в регистре Reg_Mask. Незамаскированные FORы 
поступают на схему, которая обеспечивает формирование [ПОКА: до 4; ПОТОМ: до 6] 
групповых сигналов Group1..Group6 (логических сумм нескольких FORов по "ИЛИ") 
и выдачу этих сигналов на выбранные шины магистрали CAMAC (16 шин R и 16 
шин W). Конфигурирование этой схемы производится посредством записи данных 
в 7 регистров. Регистры Reg_Grp1..Reg_Grp6 содержат 16-битные маски, каждая из 
которых определяет, какие FORы включаются в соответствующую логическую сумму 
Group1..Group6. Регистр Reg_GrpOut содержит [ПОКА: 4; ПОТОМ: 6] 3-битных кодов, 
каждый из которых определяет, на какую из доступных ему шин будет выведен 
соответстсующий сигнал Group1..Group6. Например, сигнал Group1 может быть 
выведен на шины R1..R8; Group2 - на R9..R16; ...; Group4 - на W9..W16. Эти 
сигналы выдаются на шины только в режиме "NORMAL" (в статусном регистре бит 
MODE = 1), и при этом выходы Альтеры имитируют режим "Открытый Коллектор". 
Выходы, выдающие сигналы групп на шины CAMACa, деактивируются также сигналом 
Busy, дабы не мешать работе CAMACa (ежели чо).

    ДЛЯ  РАБОТЫ  С  МАКЕТОМ  ДК, чтобы обеспечить запуск от проволочек, 
незамаскированные FORы подаются на схему "16ИЛИ", и суммарный сигнал выдается 
на выход Service_InOut. 
    ВРЕМЕННАЯ  МЕРА  ДЛЯ  ТЕСТИРОВАНИЯ  НА  СТОЛЕ - незамаскированные FORы 
подаются на схему "16ИЛИ", и по фронту суммарного сигнала запускается 
задержка на 32Клока (1280нс). Задержанный сигнал длительностью 1Клок (при- 
вязанный, ессессно, не к FORу, а к Клоку) выдается на выход Link_Data. 
Чтобы аналоговые каналы успевали очухаться после цикла оцифровки, сделано,
что при запуске цикла оцифровки запускается также таймер на ~160мкс (заведомо 
длиннее оцифровки), который запрещает выдачу Starta на это время. 


ОЦИФРОВКА
----------
    Фронт сигнала "Блокировка" является "Общим Стопом". По этому фронту взво- 
дится триггер (вне Альтеры), сигнал которого управляет измерением времени 
в каналах T2Q. По этому же сигналу начинается выполнение цикла оцифровки.
В начале цикла сразу же сбрасывается триггер готовности R_StdBy, и начинается 
выполнение программы оцифровки микропрограммным автоматом. 
    До начала оцифровки необходимо выждать ~4-5мкс, пока устаканятся напряжения 
в аналоговых каналах. В течение этого времени содержимое регистров Reg_InData 
и Reg_Hit записывается в ОЗУ в адреса #0 и #1 соответственно, и затем просто 
не делается никаких действий до окончания времени ожидания.  
    По окончании ожидания выполняется заданное число циклов оцифровки (в каждом 
цикле 2 АЦП выдают по 1 слову данных), и параллельно с измерениями эти данные 
[выдаются в Линк], а также складываются в ОЗУ. 
    По окончании цикла оцифровки аналоговые каналы платы приводятся в состояние 
готовности к приему следующих входных сигналов. Аналоговые каналы могут 
срабатывать (и самосбрасываться), но следующий цикл оцифровки будет выполнен 
только по следующей "Блокировке", при условии, что триггер готовости к 
оцифровке будет взведен (см. CAMAC-Interface). 

    ДЛЯ  ТЕСТИРОВАНИЯ  предусмотрена возможность запустить цикл оцифровки 
принудительно по команде от CAMACa. При этом триггер (вне Альтеры), сигнал 
которого управляет измерением времени в каналах T2Q, остается невзведенным
(т.к. Start-a не было), и сигнал "Ворота" остается в состоянии "открыто".
    ВРЕМЕННАЯ  МЕРА  ДЛЯ  ТЕСТИРОВАНИЯ  НА  СТОЛЕ - при оцифровке триггер 
R_StdBy не сбрасывается, и сразу после окончания оцифровки плата готова к 
выполнению следующего цикла оцифровки (поскольку желательно, чтобы следующая 
"Блокировка" поступила через >= 5мкс после окончания оцифровки, сделана схема, 
запрещающая выдачу Starta в течение ~160мкс). 

==============================================================================
2.  CAMAC  PART 
================

CAMAC - interface: 
-------------------
    Узлы CAMAC-интерфейса, ощутимые для пользователя:
-  Главная ПЛМ C_LUT1, которая формирует управляющие сигналы для CAMAC-интер-
 фейса с учетом состояния различных узлов платы T2Q
-  Регистр Маски Reg_Mask (16бит)
-  6 (ПОКА: 4) Регистров Групп  Reg_Grp1...Reg_Grp6 (по 16бит)
-  Регистр вывода групп Reg_GrpOut (16бит)
-  Регистр адреса   C_RegAddr (8бит)
-  Статусный_Регистр (8бит)
-  Схему, формирующую управляющие сигналы для передачи 16 слов данных из 
 ОЗУ RAM в Регуляторы порога: сигналы Dasy_d и Dasy_c, TrimDAC_d и TrimDAC_c.
 
   Обработка CAMAC-команды начинается по приходу N (N=0). В начале CAMAC-
цикла ПЛМ C_LUT1 определяет, учитывая текущее состояние Блока, разрешено ли 
и возможно ли исполнение поступившей команды. Если C_LUT1 решает выполнять 
команду, то выдаются (X=1, Q=1).  В противном случае выдаются (X=1, Q=0). 

CAMAC - функции: 
-----------------
F16A_0  - запись данных в Регистр Reg_Mask
F16A[1..6] - запись данных в Регистры_групп Reg_Grp1..Reg_Grp6
F16A_7  - запись данных в Регистр Reg_GrpOut
F16A_8  - запись данных в Регистр Адреса для последующего доступа к RAM
F16A10  - запись в Статусный Регистр

F_0A_0  - чтение данных из Регистра Reg_Mask
F_0A[1..6] - чтение данных из Регистров_групп Reg_Grp1..Reg_Grp6
F_0A_7  - чтение данных из Регистра Reg_GrpOut
F_0A_8  - чтение данных из Регистра Адреса
F_0A10  - чтение данных из Статусного Регистра

F17A_8  - запись данных в RAM по адресу, предварительно заданному по F16A8

F_1A_8  - чтение данных из RAM по адресу, предварительно заданному по F16A8

F18Axx  - передача (предварительныо записанных) кодов из RAM в TrimDACs

F25A_0  - "Готовность к Оцифровке" (цикл оцифровки инициируется Start-ом)
F25A_1  - "Принудит. Оцифровка"    (цикл оцифровки инициируется этой командой)

F30Axx  - Reset ALL
F30A_1  - Reset DIGITIZER_Part

Условия, при которых выполняются различные команды, в основном следующие. 
Команды "Reset ALL" и "Reset Digitizer_Part" выполняются, ессессно, всегда. 
Команды записи/чтения регистров и ОЗУ выполняются при условиях, что плата 
T2Q не выполняет цикл оцифровки, не выполняет цикл переписи кодов в Регуля-
торы порогов, и триггер готовности R_StdBy сброшен в 0. Команда "Принудительная 
оцифровка" выполняется при условиях, что плата T2Q не выполняет цикл оцифровки
и не выполняет цикл переписи кодов в Регуляторы порогов. Подробности см. выше,                                         
в 1-й части, гл. "CAMAC-Part". 
  ВРЕМЕННАЯ  МЕРА  ДЛЯ  ТЕСТИРОВАНИЯ  НА  СТОЛЕ - при оцифровке триггер готов- 
ности R_StdBy не сбрасывается, что обеспечивает многократный запуск оцифровки. 
При этом для облегчения доступа к данным команды записи/чтения ОЗУ и всех 
регистров выполняются независимо от состояния триггера R_StdBy. 

РАБОТА  С  ПЛАТОЙ  T2Q
-----------------------
    По включению питания в Альтеру загружается программа (в том числе - 
default коды порогов, равные половине максимального значения). После этого 
плата готова к приему команд от CAMACa. 
    Для начала неплохо бы сделать Общий_Сброс. 
    После этого нужно прописать нужные коды порогов в Регуляторы порогов. 
Это делается в 2 этапа. Сначала 16 слов кодов записываются в ОЗУ: 
1-й канал <=> адрес #64,  ... , 16-й канал <=> адрес #79. 
- F16A8 Data=AA - запись адреса AA в Reg_Addr        \ и так 
- F17A8 Data=NN - запись числа  NN в ОЗУ в адрес AA  /  16 раз
Теперь даем команду переписать эти коды из ОЗУ в регуляторы порога (F18A0).
  
    Теперь, если нужно получать сигналы для триггера, необходимо записать 
маску в Reg_Mask. 

    Ну вот, теперь плата подготовлена к работе. Можно давать команду готов- 
ности (F25A0). После этой команды плата ожидает Start-a, и по Start-у выпол-
няет цикл оцифровки. По окончании оцифровки данные находятся в ОЗУ, и плата 
выставляет LAM. 
    Когда есть LAM - можно читать данные. 
- F16A8 Data=AA - запись адреса AA в Reg_Addr        \ и так 
- F_1A8         - чтение данных из ОЗУ из адреса AA  /  48+2 = 50 раз
    Наслаждаемся полученными данными. Чтобы подготовить плату к следующему 
Start-у, снова даем команду F25A0. 

