Title "TA12 Module for LXeTower";
-- v.2  : The project of digitizing module for LXe-calorimeter
-- v.2b : The project of digitizing module for LXe-calorimeter with new Ether module for UDP
-- v.2c : The project of digitizing module for LXe-calorimeter with new Ether module for UDP

-- v.4d  : With ETHERNET_4b module, this Project supports ARP-request / ARP-reply, 
--           and is capable of receiving UDP-packets and sending them back. 
-- v.4g  : With ETHERNET_4d module, this Project provides full support of UDP-protocol 
--           (incl. ARP-request/ARP-reply) => this Project provides FULL COMPATIBILITY 
--           with any standard hardware/software. 
-- v.4i : With ETHERNET_4f module, this Project provides full support of UDP-protocol 
--           (incl. ARP-request/ARP-reply), and =guaranteed= synchronization of signals 
--           aligned to all clocks (RxClk, TxClk and Clock100) is provided. 

INCLUDE "lpm_compare.inc" ;
INCLUDE "lpm_ff.inc";
INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "lpm_counter.inc" ;
INCLUDE "lpm_add_sub.inc";
INCLUDE "lpm_divide.inc";
INCLUDE "pdo.inc";
INCLUDE "seio.inc";
INCLUDE "diffin.inc";

INCLUDE "EdgeSensing.inc" ;
INCLUDE "LevelSensing.inc" ;
INCLUDE "DelayLine.inc" ;
INCLUDE "PulseShaper.inc" ;
INCLUDE "LightPulser.inc";
INCLUDE "PhaseSwitch.inc";

INCLUDE "PLL_TA12.inc";

INCLUDE "DDR_in.inc";
INCLUDE "Digitizer_TA6.inc";
INCLUDE "WFTA_HistRAM.inc";
INCLUDE "DataSelect_v2.inc";
INCLUDE "ImRam.inc";
INCLUDE "ReadRam.inc";
INCLUDE "AddrRam.inc";

--INCLUDE "PROCESSOR.inc" ;
INCLUDE "PROCESSOR2m.inc" ; -- ^^ replaced temporarily ?
INCLUDE "RAMmain.inc" ;     -- MainRAM - general purpose RAM
INCLUDE "RAMcommd.inc" ;    -- CommandList RAM
INCLUDE "RAMsetup.inc" ;    -- RAM containing data for ADCs setup
--INCLUDE "TestRAM_main.inc";
INCLUDE "EtherRAM2P.inc";     -- ^^ replaced with 2-port RAM (temporarily ?)

INCLUDE "UpLink.inc";
INCLUDE "Fast_Link.inc";
INCLUDE "ETHERNET.inc";

INCLUDE "TestRAM_main.inc";
INCLUDE "ErrorCounters.inc";

--============================================================================
-- Map of Objects' addresses in TA12 Module

Constant SetupRAM_Offset		= H"0200";	-- RAM block, 256words * 8bits \_Contains data
Constant SetupRAM_Size			= 256;		-- #512..#767                  / for ADCs set-up
Constant MainRAM_Offset			= H"0300";	-- main RAM block, 256words * 16bits
Constant MainRAM_Size			= 256;		-- #768..#1023
Constant ProgRAM_Offset 		= H"0400";	-- Program RAM block, 256words * 16bits
Constant ProgRAM_Size			= 256;		-- #1024..#1279

--Constant CtrlStat_offset		= H"0800";	-- #2048 "Control-Status Reg", composed of named Triggers
--Constant BaseAddr_offset		= H"0802";	-- #2049  Base Address of Program to be started
--Constant ADCfeed_Init			= H"0803";	-- #2050  ADC Setup started 
--Constant UDPlength_Offset		= H"0804";	-- #2052  Length of UDP Data block
--Constant UDP_PkNum_Offset		= H"0805";	-- #2053  Number of UDP-packet transmitted
--Constant EthPause_Offset		= H"0806";	-- #2054  Value of Ethernet' PAUSE (in 10ns units)
--Constant EthOpCode_Offset		= 2048+ 7;	-- #2055=H"0807" - EthOpCode (read-only register)
Constant Servo_offset			= H"0800";	--\(#2048..#2055) addresses of servo Regs and Cnts :
Constant Servo_size				= 8;		--/ CtrStat-"reg"(#2048), Reg_BaseAddr(#2049), etc.

--Constant Link_IFace_Offset  = 2048+32;  -- #2080=H"0820" - Link's InData_Port
--                                        -- #2081=H"0821" - Link's Data_Port
--                                        -- #2082=H"0822" - OpCode (read-only register)
--                                        -- #2083=H"0823" - unused
Constant Link_IFace_Offs		= H"208";  -- Link_IFace_Offs[13..0] = LinkIFace_Offset[15..2]
Constant FIFO_OpCode_offset		= H"0824";  -- #2084 = 2048+36
Constant FIFO_InData_offset		= H"0825";  -- #2085 = 2048+37

--Constant SelCommdList			= H"0BB8";	-- #3000 - Select the CommandList (read-only register)
Constant CommdList_Offset		= H"0C00";	-- #3072  RAM block containing the Command Lists
Constant CommdList_Size			= 1024;		-- #3072..#4095

Constant ADC_RAM_Offset 		= H"1000";	-- #4096 RAM of ADC1 #5120 RAM of ADC2 #6144 RAM of ADC3
											-- #7168 RAM of ADC4 #8192 RAM of ADC5 #9216 RAM of ADC6
Constant ADC_RAM_Size			= 1024;		-- ?acia? iaeanoe iia ea?aue eaiae
Constant Compres_Offset			= H"4000";

Constant EtherRAM_Offset		= H"5000";	-- #20480
Constant EtherRAM_Size			= 1024;

Constant WF_RAM_Offset			= H"6000";	-- #24576
Constant WF_RAM_Size			= 768;
Constant WF_RAM_SE_Ctrl			= H"6800";	-- #26624

Constant ErrorCounters_Offset	= H"6900";	-- #26880
Constant ErrorCounters_Size		= 16;

Constant TestRAM_Offset 		= H"7000";	-- #28672, Test RAM block
Constant TestRAM_Size			= 256;		-- 256words * 16bits

-- Parameters of the TA12 Module

Constant ADC_Bits				= 12;	-- Number of ADC bits
Constant NUM_CH					= 4;	-- Number of channels on the board
CONSTANT TA_Bits				= 10;	-- Number of transfered bits to IPT_LXe
Constant WriteWFDelayTime		= 65;	-- Delay of WForm_copying_to_ExternalRAM after LinkMessage (1mks), чтобы Линк успел распознать номер события.

-- Map of Objects' addresses in Ethernet 

--Constant ThisDeviceAddr		= H"666666008CEF"; 
Constant ThisDeviceAddr			= H"0555555555CF";	-- MAC
Constant ThisDeviceIPAddr		= H"C0A8400A";		-- IP: 192.168. 64. 10

Constant ARP_InitAddr			= 8;				-- 8=8192=8200 BaseAddr for storing ARP-packets in EtherRAM
Constant ARP_InitAd_plus07		= ARP_InitAddr + 7;
Constant ARP_InitAd_plus09		= ARP_InitAddr + 9;
Constant ARP_InitAd_plus12		= ARP_InitAddr +12;	-- used in UDP-packet transmission cycle
Constant ARP_InitAd_plus14		= ARP_InitAddr +14;
Constant ARP_InitAd_plus16		= ARP_InitAddr +16;
Constant ARP_InitAd_plus23		= ARP_InitAddr +23;
Constant UDP_InitAddr			= 48;				--48=8192=8240 BaseAddr for storing UDP-packets in EtherRAM
Constant UDP_InitAd_plus01		= UDP_InitAddr + 1;
Constant UDP_InitAd_plus02		= UDP_InitAddr + 2;
Constant UDP_InitAd_plus12		= UDP_InitAddr +12;
Constant UDP_InitAd_plus13		= UDP_InitAddr +13;
Constant UDP_InitAd_plus14		= UDP_InitAddr +14;	-- used in UDP-packet transmission cycle

Constant EtherRam_DataAddr		= 62;

SUBDESIGN TA12_Digitizer
(
-- 1. Reference Clock's & Frequency Control I/O
FQuartz			: input;	-- 25MHz clock from Quartz oscillator       <- Pin46
-- In TA6 module Link's Clock is checked inside Altera but switched outside 
Sw_Quartz		: output;	-- connects Quartz to PLL ref.Input         -> Pin45
Sw_LinkClk		: output;	-- connects Link's Clock to PLL ref.Input   -> Pin49

PLL_res			: output;	-- Ref.clock for PLL (dedicated)            <- Pin31
PLL_in			: input;	-- Ref.clock for PLL (dedicated)            <- Pin31
PLL_ExtOut		: output;	-- Output of PLL.e0 to outside              -> Pin69

-- 1.1 PLL Installation
PLLinst_S0		: output;
PLLinst_S1		: output;
PLLinst_EN		: output;

-- Outputs for Indicators on LED's
LedR			: output;	-- drives the Red LED               -> Pin18
LedG			: output;	-- drives the Green LED             -> Pin21
LedB			: output;	-- drives the Blue(Yellow) LED      -> Pin22
LedTest         : output;   -- drives additional LED            -> Pin217

-- 2. Links signals 
-- 2a. UpLink signals 
LinkClk			: input;    -- Clock from Link's ClockLine              <- Pin 
LinkData_p		: bidir;    -- Data <-> Link's DataLine                 <->Pin 
LinkData_n		: bidir;    -- Data <-> Link's DataLine                 <->Pin 

-- 2b. FastLink signals 
SerDataOut[13..0]			: output;  -- aaiiua aey ia?aaa?e n iiiiuu? Serializer-a a EIO
NWordFLink[1..0]			: output;  -- iiia? neiaa a aaiiuo aey ia?aaa?e n iiiiuu? Serializer-a a EIO
RPWDN						: output;  -- aee/auee Serializer-a
TPWDN						: output;  -- aee/auee Deserializer part
REN							: output;  -- aee/auee Serializer-a
DEN							: output;  -- aee/auee Serializer-a
SerClk						: output;  -- oaeoiaue neaiae Serializer-a
FLink_Sync					: input;  -- neaiae neio?iiecaoee Serializer-a/Deserializer-a
TAWF_DataStrobe				: output;

-- 3. Ethernet Controller's ports     LXT972
CRS							: input;    -- Carrier_Sense                    <- Pin126
RxClk						: input;    --                                  <- Pin137
RxDV						: input;    -- Data_Valid                       <- Pin139
RxD[3..0]					: input;    -- inputs for data half-Bytes       <- Pin[145..142]
RxEr						: input;    -- RxEr not in use!!!!              <- Pin109-corner

TxClk						: input;    --                                  <- Pin135
TxEn						: output;   --                                  -> Pin134
TxD[3..0]					: output;   -- inputs for data half-Bytes       <- Pin[128,131,132,133]
COL							: input;    -- Collision_Detect not used        <- pin127

-- 4. Digitizers  
ADC_In_Data[NUM_CH-1..0][1..0]	: input;    -- input of data from ADC Pin197..219, Pin110..123,...
ADC_FrameClk[2..0]				: input;
ADC_DataClk[2..0]				: input;
ADC_SEN[2..0]					: output;
ADC_SDATA[2..0]					: output;
ADC_SDOUT[2..0]					: input;
ADC_SCLK						: output;
ADC_Reset						: output;

-- 5. Ext RAM  
ExtRAM_Addr[15..0]		: output;
ExtRAM_Data[15..0]		: bidir; -- must be change to bidir!!!
ExtRAM_OutEn			: output;
ExtRAM_CEn				: output;
ExtRAM_WriteEn			: output;
ExtRAM_LowerByteControl	: output;
ExtRAM_UpByteControl	: output;

-- 6. Test signal
ExtReset			: input = GND;  -- external Reset (tied to GND --VCC)   <- Pin

Test_in[16..0]		: input;
Test[10..2]			: output;
)

VARIABLE
--============================================================================
--******** 1. Reference clock's & Frequency Control **************************
PLL				: Pll_TA12;  -- PLL:  Fin=25MHz, PLL.c0=(25MHz shift=0), PLL.c1=(100MHz shift=0)
Clk12_5			: node; -- This is Global Node
Clk25			: node; -- This is Global Node 
--Clk37_5			: node; -- This is Global Node 
--Clk75			: node; -- This is Global Node
Clk100			: node; -- This is Global Node
Clk300_adc		: node; -- This is Global Node

-- Automatic Clock Switch: if External_Clock frequency (kHz) is in specified 
--   range, PhaseSwitch transfers the External_Clock to PLL1's reference input, 
--   thus all PLL's output clocks are locked to the External_Clock. 
PhaseSw			: PhaseSwitch with (FmaxThresh=26000, FminThresh=23000, RefClock=25000);

Clk25del1,
Clk25del2       : node;
PhaseSet,               -- _/^^\_ pulse aligned to _/ front of StartBit
Phase12,
Synchro12,              -- 1-clock _/^\_ pulse aligned to _/ front of PHASE
Synchro25       : node; -- 1-clock _/^\_ pulse aligned to PHASE and half-PHASE

--******** Power-up self-Reset and self-Set pulses ***************************
PowerUp0,                      --\   Circuit 
PowerUp1, PowerUp2,            -- \  which generates 
PowerUp3, PowerUp4,            --  \ a pulse 
PowerUp5, PowerUp6,            --  / for power-up Reset  \  many milliseconds apart 
PwrUpReset,                    -- /  and then few pulses  > from each other
PwrUpSet1,PwrUpSet2 : node;    --/   for power-up Set    /  

--============================================================================
--******** 2. Timers for Indicators on LED's (Duration in ms, RefClock in kHz)
B_Flash			: LightPulser with (Duration = 20, RefClock = 100000); -- Blue
R_Flash			: LightPulser with (Duration = 20, RefClock = 100000); -- Red
LinkFlash		: LightPulser with (Duration = 40, RefClock = 100000); -- Green
Test_Flash		: LightPulser with (Duration = 20, RefClock = 100000); -- color??
EtherTx_Flash	: LightPulser with (Duration = 16, RefClock = 100000); -- Blue

--============================================================================
--******** 3a. Up_Link
Link_IFace			: UpLink with (RefClock = 100);
--Reg_OpCode			: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
--										 lpm_direction="unused"); -- not important
--OpCode_load			: node; -- puts Reg_OpCode into "load" mode

Delay_LinkMessage	: DFF;

b2v_inst2			: pdo;
b2v_inst3			: seio;
b2v_inst4			: seio;
b2v_inst5			: diffin;

--============================================================================
--******** 3b. Fast_Link TA6/12->IPT

FLink_Data_BUS				: lpm_shiftreg with (lpm_width=12, lpm_direction="unused");
--FLink_cnt					: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- n?ao?ee a?aiaie aey neio?iiecaoee

FLink_Reg_LinkOpCode		: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
												 lpm_direction="unused"); -- not important
TxWFhist					: SRFF;
DelayWriteWFhist			: DelayLine with (DelayCode = 90,  -- to delay the real END of Write WFHist
								  DurationCode= 2); --  after LinkMessage-cycle
DataCount					: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- n?ao?ee aaiiuo ec iaiyoe eaiaea aey ia?aaa?e ii eeieo a EIO
ChannelCount				: lpm_counter with (lpm_width = 4, lpm_direction="up"); -- n?ao?ee eaiaeia aey ia?aaa?e ii eeieo a EIO
StopCount					: node;
NWordCount					: lpm_counter with (lpm_width = 2, lpm_direction="up"); -- n?ao?ee iiia?a neiaa ia?aaaaaaiiai ii eeieo a EIO

%
OutData						: LVDS_Out;
--OutData[TA_Bits-1..0]		: node;
OutData_Reg					: lpm_shiftreg with (lpm_width=14, lpm_DIRECTION="unused"); -- 
%
TestLinkCt					: lpm_counter with (lpm_width = 20, lpm_direction="up"); -- oanoiaue n?ao?ee aey i?iaa?ee ia?aaa?e aaiiuo

FLink_Error					: node;

--============================================================================
--******** 5. Processor, RAM blocks and registers ****************************
--CPU             : Processor ;
CPU             : Processor2m ;
BaseAd[7..0]    : node; -- address of the beginning of selected Program
BaseAddr[7..0]  : node; -- address of the beginning of selected Program, registered

--ADC_RAM belongs to "Digitizer_TA6" unit, and is defined there
MainRAM         : RAMmain;  -- RAM  256words * 16bits, 1-port
--ProgRAM belongs to "Processor" unit, and is defined there
CommandRAM      : RAMcommd; -- RAM 1024words * 16bits, 1-port
SetupRAM        : RAMsetup; -- RAM 256words * 8bits, 2-port

-- Register contains Base Address of Program to be started
Reg_BaseAddr    : LPM_SHIFTREG with (lpm_width=8, lpm_direction="left");

--============================================================================
--******** 6. Digitizing data / Processing ******************************************************
ADCfeed_Init		: node; -- initializes the procedure of feeding the Setup data to ADCs
ADCfeed_Beg1		: node; -- intermediate signal, for change from Clk100 to Clk12_5
ADCfeed_Beg2		: node; -- Strobe: makes ADCfeed_BitCt and ADCfeed_Reg to load initial data
ADCfeed_Cycle1		: node; -- flips to =1 in 1/2 Clk12_5 after ADCfeed_Beg2 (by _/ of Clk12_5)
ADCfeed_Cycle2		: node; -- flips to =1 in  1  Clk12_5 after ADCfeed_Beg2 (by \_ of Clk12_5)

ADCfeed_NxtB		: node; --logic signal for deriving the Strobe (see the next line)
ADCfeed_NextB		: node; --Strobe: makes ADCfeed_Reg to load the next DWord, =then= makes the ADCfeed_AddrCt to increment

ADCfeed_WordEnd		: node; -- strobe at the end of sending of each 24-bit word to ADC
ADCfeed_End  		: node; -- strobe, resets ADCtest_Cycle1 to =0 at the End of sending all 24-bit words to ADC

ADCfeed_En			: node; -- Enable signal for ADC (to be inverted into active LOW)

ADCfeed_AddrCt		: LPM_COUNTER  with (lpm_width=8, lpm_direction="up" ); --
ADCfeed_WordCt		: LPM_COUNTER  with (lpm_width=4, lpm_direction="down", lpm_svalue=10 );
ADCfeed_BitCt		: LPM_COUNTER  with (lpm_width=5, lpm_direction="down", lpm_svalue=25 );

ADCfeed_Reg			: LPM_SHIFTREG with (lpm_width=8,   -- converts 8-bit DWords into series
										 lpm_direction="left"); --shift: q0 -> q[MSB]
%
ADCtest_reg			: lpm_shiftreg with (lpm_width=102, lpm_DIRECTION="left",  -- actually, this reg is SETUP !
--					  lpm_svalue = b"010000000000011000000001000100000000000001111111110001000001001101000010100000010000000111101000000010"); -- 
--					  lpm_svalue = b"010000000000011000000001000100000000000001111111110001000001001101000010100000010000000111101000000010"); -- 
--									"01						 0001					   0001						 0001					   "
--									"set	addr	 data		set		addr	 data		 set	addr		data		set		addr	 data"
--									 2bit	14bit	 8bit		2bit	14bit	 8bit		 2bit	14bit		8bit		2bit	14bit	 8bit
--									reg H"06" / reg H"01" / reg H"134" / reg H"122"
--									010000000000011000000001000100000000000001111111110001000001001101000010100000010000000111101000000010
--									reg H"0E" / reg H"0F" / reg H"0A" / reg H"06"
--									010000000000111011111011000100000000001111111000000001000000000010100101010100010000000000011000000010
--											reg H"05" 00000000000101 00000001	Output data are transmitted on 1/2-wires
--											reg H"06" 00000000000110 00000011	TEST PATTERN EN / RESET
--					  						reg H"0A" 00000000001010 01010101	(1&2ch) Custom pattern
--											reg H"0B" 00000000001011 01010101	(3&4ch) Custom pattern
--											reg H"0E" 00000000001110 10100011	Custom pattern [11:4] 101000110011
--											reg H"0F" 00000000001111 00110000	Custom pattern [3 :0] 111110111110
		lpm_svalue = b"010000000000000111111111000100000100110100001010000001000001001000100000001000110000010011010000000000"); -- SETUP sequence
--		lpm_svalue = b"0100000000000001 11111111 00 0100000100110100 00101000 00 0100000100100010 00000010 00 1100000100110100 00000000"); -- 
--					   W     0   0   1  Dith=OFF    W     1   3   4  DithA=OFF   W     1   2   2  ChopA=OFF   R     1   3   4             
--
--ADCsetup_reg		: lpm_shiftreg with (lpm_width=50,  -- actually, this reg is TEST !
--					  lpm_svalue = b"01000000000001010000000100010000000000011000000010",lpm_DIRECTION="left"); -- 
--											reg H"05" 00000001			reg H"06" 00000010 Output data are transmitted on 1/2-wires 	TEST PATTERN EN
--									"set	addr		data	set		addr	 data"
--									 2bit	14bit		8bit	2bit	14bit	 8bit
%

TA12Channel[NUM_CH-1..0]			: Digitizer_TA6;
ADC_DataClk_Gl[2..0]				: node;
ADC_DataClk_D						: node;
DDR_InLVDS[NUM_CH-1..0][1..0]		: DDR_In;
DDR_Reg_pos[NUM_CH-1..0][1..0]		: lpm_shiftreg with (lpm_width=3,lpm_DIRECTION="left");
DDR_Reg_neg[NUM_CH-1..0][1..0]		: lpm_shiftreg with (lpm_width=3,lpm_DIRECTION="left");
InData[NUM_CH-1..0]			: node;
InData_RegMix[NUM_CH-1..0]	: lpm_shiftreg with (lpm_width=ADC_Bits,lpm_DIRECTION="unused"); -- 
InData_Reg[NUM_CH-1..0]		: lpm_shiftreg with (lpm_width=ADC_Bits,lpm_DIRECTION="unused"); -- 

TAWF_HistRAM				: WFTA_HistRAM;
TAWF_RAM_cs					: node;
TAWF_HistRAM_Cnt			: lpm_counter with (lpm_width = 11, lpm_direction="up");

--Compres						: DataSelect_V2;

-- External memory

--DataCnt				: lpm_counter with (lpm_width = 8, lpm_direction="up" ); -- 
--ChannelCnt			: lpm_counter with (lpm_width = 2, lpm_direction="up" ); -- 
--ShiftWriteEnCt		: lpm_counter with (lpm_width = 10, lpm_direction="up" ); -- 
WriteWFEnd			: node;
DelayWriteWFEnd		: DFF;
WriteWFCt			: lpm_counter with (lpm_width = 7, lpm_direction="up" ); -- 
EnWriteWFHist		: SRFF;
WriteDATA			: lpm_shiftreg with (lpm_width = 16, lpm_direction="unused");
WrRdExtRAMAddr		: lpm_shiftreg with (lpm_width = 16, lpm_direction="unused");
Write_ExtRamCt		: lpm_counter with (lpm_width = 16, lpm_direction="up" ); -- 
StopWrite			: node;

Read_time			: SRFF;
DelayReadTime[1..0]	: DFF;
Read_TimeCt			: lpm_counter with (lpm_width = 12, lpm_direction="up" ); -- 
Read_Ram			: ReadRam;
Read_ExtRamCt		: lpm_counter with (lpm_width = 9, lpm_direction="up" ); -- 
EnRead_ExtRamCt		: lpm_counter with (lpm_width = 16, lpm_direction="up" ); -- 
Addr_Ram			: AddrRam;
WrRdAddr_Reg		: lpm_shiftreg with (lpm_width = 16, lpm_direction="unused");
DelayWorkTime[1..0]	: DFF;
WrAddrCnt			: lpm_counter with (lpm_width = 6, lpm_direction="up" ); -- 
ReadAddrCnt			: lpm_counter with (lpm_width = 6, lpm_direction="up" ); -- 

ReadCnt			: lpm_counter with (lpm_width = 1, lpm_direction="up" ); -- for testing double read of ExtMem

ReadExtMem			: node;
StopRead_ExtRam		: node;

--EtherTxEn			: DFFE;

Write_IntRamCt		: lpm_counter with (lpm_width = 10, lpm_direction="up" ); -- 

Compres				: DataSelect_V2;

--==============================================================================
--************ 9. Control Unit  ************************************************

StartOne        : node; -- Trigger of One-Shot_Start
St_One          : node; -- 1*Clk100 _/^^\_ for resetting StartMulti
StartMulti      : node; -- Trigger of Multiple_Start
St_Multi        : node; -- 1*Clk100 _/^^\_ for resetting StartOne

EtherCMD3mode   : node; -- Trigger, enables "CMD3" mode of Ethernet
EtherUDPmode    : node; -- Trigger, enables "UDP" mode of Ethernet

--Start_Link      : PulseShaper with (DurationCode=4);--Start whatever by Link command
Start_Link[4..1]: node; --triggers for generating a 4*Clk100 pulse, for common use

St_ADC_Link     : node;
StartADC_Link   : node;
--StartADC_Link   : PulseShaper with (DurationCode=4);--Start Digitizer by Link command
--StartADC_Ext    : PulseShaper with (DurationCode=4);-- Start ADC by external Start pulse
--StartADC        : node; -- all sources of Start ADC combined

StartWFTx		: node;

StProc_Link     : node;
StartProc_Link	: node;
--StartProc_Link  : PulseShaper with (DurationCode=4);--Start Processor by Link command
--StProc_Ether    : node;
--Delay_StProc_Ether  : DelayLine with (DelayCode = 240,  -- to delay the real start of Processor 
--                                      DurationCode= 4); -- after receiving an Ethernet command
--StartProc_Ether : node; -- final signal which starts Processor upon Ethernet command
StartProc       : node; -- all sources of Start_Processor combined

--------------------------------------------------------------------------------
--********  INITIALIZE  Ethernet Tx_cycles upon Link-Commands  *****************
CommdStReg_Ini, 
CommdOther_Ini  : node;
OutData_rdy     : DFFE; --Request for sending Output_Data via Ethernet
--OutData_rdy     : DelayLine with (DelayCode=200, DurationCode=2);
CommdPut_en     : node; --initial strobe for loading of Link-Command'_Attrib-s into FIFO

CommdPut_init   : node; -- sets the FIFO' registers in loading mode
CommdPut_wait   : node; -- =1 if the loading of a new Commd'_Attrib-s is postponed
CommdPut_ld,            --handles loading of Link-Command'_Attributes into FIFO
Commd_ld[4..1]  : node; --strobes for loading Commd'Attrib-s into correspondent cell of FIFO

CommdMov_int    : node; -- 4*Clk100 "protection interval" before MOVing the FIFO
CommdMov_en     : node; -- strobe for MOVing data in FIFO (from Cell#4 to Cell#1)

--Counter which handles input and output of Link-Command'_Attributes into FIFO
StackCt         : LPM_COUNTER with (lpm_width=2%, lpm_direction="up"%);

OpCode1_bit[ 8..1]  : DFFE; --  8-bit "register" - Cell#1 of FIFO, for OpCode
OpCode2_bit[ 8..1]  : DFFE; --  8-bit "register" - Cell#2 of FIFO, for OpCode
OpCode3_bit[ 8..1]  : DFFE; --  8-bit "register" - Cell#3 of FIFO, for OpCode
OpCode4_bit[ 8..1]  : DFFE; --  8-bit "register" - Cell#4 of FIFO, for OpCode
InData1_bit[16..1]  : DFFE; -- 16-bit "register" - Cell#1 of FIFO, for InData
InData2_bit[16..1]  : DFFE; -- 16-bit "register" - Cell#2 of FIFO, for InData
InData3_bit[16..1]  : DFFE; -- 16-bit "register" - Cell#3 of FIFO, for InData
InData4_bit[16..1]  : DFFE; -- 16-bit "register" - Cell#4 of FIFO, for InData
Contin[4..1]        : DFFE; -- "Continue to send Packets" when executing "StartRegular" Link-Command

EtherTxRq_Link  : node; --(request for) Start of an Ether' Tx cycle (UDP or CMD3) by Link

--PhSwErr_Ct      : lpm_counter with (lpm_width=16, lpm_direction="up") ; -- counts PhaseSwitch's flips
--LinkErr_Ct      : lpm_counter with (lpm_width=16, lpm_direction="up") ; -- counts Link's errors

Busy            : node; -- flag: Action in progress (Digitizing, Link cycle, ...)
Error           : node;
RESET           : node; -- main RESET, i.e. =RESET all=  
Reset2          : node; -- partial reset :  keeps basic settings
RSTdel          : node; -- delay for forming RESET and Reset2 pulses

--============================================================================
--******** 10. Error counter
ErrorCounters_IFace			: ErrorCounters with (Width = 7);
ErrorCounters_IFace_CS		: node;

--============================================================================
--******** 11. Internal Bus of Project **************************************** 
--    Address recognition and devise selection
RW				: node; -- RW=1 - a (master)unit will output data 
AddrBus[15..0]	: node; -- 16 bit address
DataBus[15..0]	: node; -- 16 bit bidir Data Line
--Data[15..0]		: NODE; -- 16 bit bidir Data Line

--Bus_Arbiter		: Arbiter with (DeviceMaxNumber=4%,TimeOut=6%);
AcsRqDetect		: node; -- =new= "AccessReq" detected
AccessGrtd		: node; -- by 1clk after AccessReq, =1 during whole Operation
AddrSettled		: node; -- Arbiter asserts this signal at next clock after Request Granted
AddrValid		: node; -- OR'ed Address Comparator's output, dff-strobed
BusOper1,
BusOper2,
BusOper3		: node; -- delay by 3 clocks 
DataStrobe		: node; --Strobe: latch data into the destination object, and finish the Bus Oper-n
--  signals of Address Comparators
DevSel[17..1]	: DFF ; -- Registered Addr_Comparator outputs for Selection

MainRAM_cs		: node; -- select for Rd/Wr from/to MainRAM
ProgRAM_cs		: node; -- ProgRAM is declared in Processor module 
CommandRAM_cs	: node; -- select for Rd/Wr from/to CommandList
SetupRAM_cs		: node; -- select for Rd/Wr from/to SetupRAM
EtherRAM_cs		: node; -- select for Rd/Wr from/to TestRAM

Link_cs			: node;
--OpCode_cs		: node; -- select for Link's OpCode register 
FIFO_OpCode_cs  : node; -- FIFO-Cell#1 :  OpCode reg
FIFO_InData_cs  : node; -- FIFO-Cell#1 :  InData reg
Servo_CS		: node; -- select for various Reg-s (CtrlStat-"Reg", BaseAddr Reg, etc.) 
Servo_Mux[16..1]: node; -- Multiplexer of Data Bus among various Registers

TA12Channel_cs[NUM_CH-1..0]   : node;
Compres_cs		: node; 

--DDREqu_cs[NUM_CH-1..0]		: node;
--DDRNEqu_cs[NUM_CH-1..0]		: node;

ZERO_cs			: node; 

--==============================================================================
--******** 9. ETHERNET ********************************************************
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
Ether			: ETHERNET;     -- ETHERNET module

EthWord_Rd		: node; -- strobe at "Read"  operation, read 1 DWord from ETHERNET
EthWord_Wr		: node; -- strobe at "Write" operation, write 1 DWord to ETHERNET

TypeRaw			: node; -- flag :  "Raw" packet received
Typ_CMD3, TypeCMD3	: node; -- fast|registered flag :  "CMD3" packet received
Typ_IP, TypeIP	: node; -- fast|registered flag :  IP  packet received
Typ_ARP,TypeARP	: node; -- fast|registered flag :  ARP packet received

--******** =Local= bus for the ETHETNET module, "Bus Handler"
RdWr			: node; -- RdWr=1 ("Write") => Data: MainProj -> Ethernet
Eth_AcsRqDetect	: node; -- =new= "AccessReq" detected
Eth_AccessGrtd	: node; -- by 1clk after AccessReq, =1 during whole Operation
Eth_AddrSettled	: node; -- Flag: Address is (reliably) settled at AddrBus
Eth_BusOper1,
Eth_BusOper2,
Eth_BusOper3	: node; -- delay by 3 clocks 
Eth_DataStrobe	: node; -- Strobe: latch data into the destination object, and finish the Bus Oper-n

--------------------------------
--Подготовка данных для Ethernet

StartWFTx_Eth	: node;
St_EthTx_Ether	: node;
St_Ether_Link	: node;
TxWFhist_Eth			: SRFF;
Delay_EthMessage		: DFF;
DelayWriteWFhist_Eth	: DelayLine with (DelayCode = 90,  -- to delay the real END of Write WFHist
									DurationCode= 2); --  after LinkMessage-cycle
DataCount_Eth			: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- n?ao?ee aaiiuo ec iaiyoe eaiaea aey ia?aaa?e ii eeieo a EIO
ChannelCount_Eth		: lpm_counter with (lpm_width = 2, lpm_direction="up"); -- n?ao?ee eaiaeia aey ia?aaa?e ii eeieo a EIO
StopCount_Eth			: node;

-- Circuitry which latches the 1st Byte received, as it is a COMMAND
RxDBlkDel[4..1]	: node; --delay of the "RxDataBlck" by 2 RxClocks and a little more
EthOpCode_save	: node; -- strobe for latching the =1st= Ethernet' DataWord (OpCode)
EthOpCode_saved	: node; -- =1 when Ethernet' OpCode is saved, till the End of Frame

Delay_St_Ether_Link		: SRFF;
EtherLinkMessage		: SRFF;
EmptyMess				: node;
EtherLinkTimeCt			: lpm_counter with (lpm_width = 11, lpm_direction="up");
StartEthTx_Link			: PulseShaper with (DurationCode= 8); --Start Ethernet' Transmit by end of Link command

EndEtherTx		: node;
EtherBank_1,
EtherBank_2,
EtherBank_3		: SRFF;
EtherPause1,
EtherPause2,
EtherPause3		: SRFF;
EtherBankDelay	: lpm_counter with (lpm_width = 12, lpm_direction="up");

StartEthTx_Cnt	: lpm_counter with (lpm_width = 8, lpm_direction="up");
StatusPack		: lpm_shiftreg with (lpm_width=16, lpm_direction="unused");

---- Counter which contains address for exchange between ETHERNET and TestRAM
--EthAddrCt		: lpm_counter with (lpm_width = 11, lpm_direction="up");
--Eth_InitAddr[10..0] : node; -- initial address of data to be Transmitted

--CntBoard		: lpm_counter with (lpm_width = NUM_board-1, lpm_direction="up");

--********  Proceeding of the RECEIVING Cycle  *********************************
ProtoNext		: node; -- makes the Protocol Execution Circuit to go to the next Stage

--Circuit which handles the Ether'addresses within Rx_Cycle ;
--  Triggers are connected in to decouple stages of big logic.
RxAdrSet[6..1]	: node; -- logical nodes - conditions for Setting addr. within Tx_cycle
RxAdrSet1a,
RxAdrSet1b		: node; -- flips  0->1, 1->0  when TxAdrSet1 has =garanteedly= settled.
RxAdrSet2a,
RxAdrSet2b		: node; -- flips  0->1, 1->0  when TxAdrSet2 has =garanteedly= settled.
RxAdrSet3a,
RxAdrSet3b		: node; -- flips  0->1, 1->0  when TxAdrSet3 has =garanteedly= settled.
RxAdrSet4a,
RxAdrSet4b		: node; -- flips  0->1, 1->0  when TxAdrSet4 has =garanteedly= settled.
RxAdrSet5a,
RxAdrSet5b		: node; -- flips  0->1, 1->0  when TxAdrSet5 has =garanteedly= settled.
RxAdrSet6a,
RxAdrSet6b		: node; -- flips  0->1, 1->0  when TxAdrSet6 has =garanteedly= settled.
EthAdrInit		: node; -- strobe : set the initial addr for storing DataBlock
EthNextAdr[6..1]: DFFE; -- initial addr for storing data during the next Stage of receiving
EthAddrLd[2..1]	: node; -- "request" for loading next InitAddr into EtherAdrCt

EthAdrCt_en		: node; -- strobe for operating EtherAdrCt =after= .. 
					--.. a DWord has been stored into RAM or a DWord has been read out from RAM
RxStop			: node; -- makes ETHERNET to stop receiving, IF 

--Counter which contains address for data exchange between ETHERNET and EtherRAM
EtherAdrCt		: lpm_counter with (lpm_width = 10, lpm_direction="up");
--RAM for DataWords, PortA is used exclusively by Ethernet section
EtherRAM		: EtherRAM2P;   -- RAM for DWords (Ethernet section uses PortA)
--EtherRAM_cs	: node;       --declared at "Data Bus" section

--Main Protocol Cycle Counter :
CtProto			: LPM_COUNTER with ( lpm_width=6, lpm_direction="up" );

ProtoInited		: node; -- Execution of a Protocol =has been= initiated

Rx_Err			: node; -- Error during Ethernet Receiving

--********  Execution of the CMD3-packet  **************************************
-- Circuitry which latches the 1st Byte received, as it is a COMMAND
CMD3OpCode_save	: node; --strobe for latching the =1st= DWord (OpCode) of DataBlock of CMD3-packet
CMD3command		: node; -- =1 when CMD3' OpCode is saved, till the End of Frame
Reg_EthOpCode[8..1] : DFFE; -- "register" for storing CMD3' OpCode received from Ethernet

Eth_Reg_LinkOpCode		: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
											 lpm_direction="unused"); -- not important
Eth_Reg_LinkEvNumber	: lpm_shiftreg with (lpm_width=16, lpm_direction="unused");

--********  Execution of the IP-packet  (UDP-packet)****************************
RxDVtrig		: node; --unnecessary trigger, but it helps Quartus to analyze the Stages

RxIPheader		: DFF ; -- flag:  IP-header is being received
RxIP_Saddr		: DFF ; -- flag:  IP-Packet's "SourceAddr" is being received
RxIP_Daddr		: DFF ; -- flag:  IP-header's "DestinAddr" is being received
TypeUDP			: SRFF; -- flag:  "UDP" tag detected
RxUDPheadr		: DFF ; -- flag:  UDP-header is being received
RxUDPDBlck		: DFF ; -- flag:  UDP-DataBlock is being received

RxIPleng[12..1]	: DFFE; -- "register" containing the length of IP-Pkt's Data_Block
RxIPleng_ld		: node; -- strobe for catching the "IP-Length" value

--********  Execution of the ARP-packet  ***************************************
RxARPheadr		: DFF ; -- flag:  ARP-header is being received
RxARPSaddr		: DFF ; -- flag:  ARP-packet's SourceAddr (MAC+IP) is being received
RxARPDaddr		: DFF ; -- flag:  ARP-packet's DestinationAddr (MAC only!) is being received
RxARPDadIP		: DFF ; -- flag:  ARP-packet's DestinationAddr (IP only!) is being received
RxARPDBlck		: DFF ; -- flag:  ARP-DataBlock is being received 

--Register (temporary - simply a bus) which contains "ThisDevice'_IP" 
ThisDeviceIP[32..1]	: node;

DadrIP_MSW		: node; -- strobe for checking the MSWord of IP-Daddr
DadrIP_LSW1,
DadrIP_LSW2, 
DadrIP_LSW3, 
DadrIP_LSW4		: node; -- delay for deriving strobe for checking the LSWord of IP-Daddr
DadrIP_LSW		: node; -- strobe for checking the LSWord of IP-Daddr

ChkIPDaddr		: DFFE; -- represents the result of checking of "IP-Daddr"
DadrIP_cmp		: node; -- strobe for using the result of checking of "IP-Daddr"

--********  Recognizng the Commands received from Ethernet  ********************
Ether_ARPreply	: node; -- flag: ARP-reply command is being proceeded
TxARPrepl_Rq	: node; -- request for sending ARP-reply

--For Tests :  Send a UDP-packet "in reply" upon receiving a UDP-packet
UDPtestDel		: node; --Handles the delay CountDown before Requesting a UDP Tx_cycle
UDPtstDelCt		: LPM_COUNTER with (LPM_width=3,    --\_ Makes the delay before..
        LPM_direction="down",  LPM_Svalue=7 );      --/ ..requesting a UDP Tx_cycle
TxUDP_Rq_UDP	: node; --request for starting a UDP Tx_cycle upon receiving UDP-packet

UDPtstSeries	: node; --enables initiation of UDP-Tx_cycles upon Link commands 12 times
UDPtstSerCt		: LPM_COUNTER with (LPM_width=4,    --\_ Counts UDP-Tx_cycles ..
        LPM_direction="down",  LPM_Svalue=12 );     --/ ..started in one Series

StEthTx_Ether	: node; -- start Ethernet Tx cycle upon CMD3 command
Eth_WRITE,				-- flag:  CMD3' "Write" command is received 
EtherWRITE		: node; -- flag:  CMD3' "Write" command is received, registered 
--EtherWR_we		: node; -- Upon Ether' "WRITE" command, enables ETHERNET -> TestRAM

--********  Proceeding of the TRANSMISSION Cycle  ******************************
EtherPauseRg[10..1] : DFFE; --"register" which contains Duration of Ether' PAUSE
EtherPauseCt    : LPM_COUNTER with (LPM_width=10,   --\_ Makes the PAUSE before..
                        LPM_direction="down" );     --/ ..initiating a next Tx_cycle
EtherBusy       : node; -- flag:  ETHERNET is busy
EthBusyEnd      : node; -- 1*Clk100 _/^^\_ by the end of EtherBusy

EtherTx_Rq      : node; --all requests for starting a Tx_cycle in reply for =any= Link Commd
Tx_Rq_StReg     : DFF;  --Request for starting a Tx_cycle in reply for Link "StartNormal" Commd
Tx_Rq_Other     : DFF;  --Request for starting a Tx_cycle in reply for Link Commd other than "StartNormal"

InitARP         : node; -- initializes ARP-reply Tx_cycle 

TxUDP_Rq_Long   : node; -- all requests for starting a LONG UDP-Tx_cycle, gathered
TxUDPwait       : node; -- "WaitList" of request for (long) UDP-Tx_cycle
InitUDP         : node; -- initializes UDP (long) Tx_cycle
Ether_TxUDPcycle: node; -- flag: UDP-packet is being transmitted

TxCMD_Rq_StReg  : node; --request for starting a CMD3-Tx_cycle in reply for Link "StartNormal" Commd
TxCMD_Rq_Other  : node; --request for starting a CMD3-Tx_cycle in reply for Link Commd other than "StartNormal"
InitCMD_StReg   : node; -- flag: CMD3 Tx_cycle upon "StartRegular" is to be started
InitCMD_Other   : node; -- flag: CMD3 Tx_cycle upon any other Command is to be started
InitCMD         : node; -- initializes CMD3 Tx_cycle
Ether_TxCMDcycle: node; -- flag : CMD3-Link-Command is being executed
StartEthTx      : PulseShaper with (DurationCode=4);--Start any Ether' Tx_cycle

DBlkLengthRg[11..1] : DFFE; -- "register" contains Length of DataBlock (of UDP and CMD3 packets)
IPlength        : LPM_ADD_SUB with (LPM_width=11,   --\  
                LPM_direction="add",                -- \ This adder is used ..
                LPM_representation="unsigned",      --  > to calculate ..
                ONE_INPUT_IS_CONSTANT="yes",        -- / ..the Length of IP-header, 
                LPM_pipeline=1 );                   --/  ..and hold it
UDP_PackCt      : LPM_COUNTER with (LPM_width=16,   --\_ Counts the Number of UDP-packet ..
        LPM_direction="up", LPM_Svalue=H"0002");    --/ .. to be transmitted

--EthAdrInit      : node; --(Declared in "RECEIVER") Strobe : set the initial addr
EthTxAdrIni2    : node; --\_ 1*Clk100 _/^^\_ pulse, 
EthTxAdrInit    : node; --/ initiates a strobe for loading InitAddr into EtherAdrCt
EthTxAdrIncr    : node; -- initiates increment of EtherAdrCt

TxAdrSet[4..1]  : node; -- logical nodes - conditions for Setting addr. within Tx_cycle
TxAdrSet1a,
TxAdrSet1b      : node; -- flips  0->1, 1->0  when TxAdrSet1 has =garanteedly= settled.
TxAdrSet2a,
TxAdrSet2b      : node; -- flips  0->1, 1->0  when TxAdrSet2 has =garanteedly= settled.
TxAdrSet3a,
TxAdrSet3b      : node; -- flips  0->1, 1->0  when TxAdrSet3 has =garanteedly= settled.
TxAdrSet4a,
TxAdrSet4b      : node; -- flips  0->1, 1->0  when TxAdrSet4 has =garanteedly= settled.

--****  Circuit which calculates the IP-header'CRC :
IPinit_cnt		: node; -- enables [IPinitCt, IPinit2, IPinit1] to count-down 
IPinit[2..1]	: node; -- Prescaler by 4, consist of 2 D-triggers
IPinitCt		: LPM_COUNTER with (LPM_width=4,    --\_ Handles the circuit which..
		LPM_direction="down",  LPM_Svalue=12 );     --/ ..calculates the IP-header' CRC

IPhdCRCadder	: LPM_ADD_SUB with (LPM_width=16,   --\  
				LPM_direction="add",                -- \ This adder is used ..
				LPM_representation="unsigned",      -- / to calculate ..
				LPM_pipeline=1 );                   --/  the CRC of IP-header
IPhdCRCcarry	: LPM_COUNTER with (LPM_width=4,    --\_ Handles the circuit which..
						LPM_direction="up");        --/ ..calculates the IP-header' CRC

IPhdCRC_Cen		: node; -- strobes which cause IPhdCRCadder to perform addition 
IPhdCRCclken	: node; -- same as above, registered

TxDataBus[15..0]: node; -- local bus (formal only) used by Tx_cycle proceeding circuit

--==============================================================================
--******** 9e. Measurement Data transmission via Ethernet
DataTrans		: node;
--CntBoard		: lpm_counter with (lpm_width = NUM_board-1, lpm_direction="up");

--==============================================================================
--******** 10. Test circuitry
TestCt			: LPM_COUNTER with (LPM_width=26,           --\ Test Counter,
									LPM_direction="up");    --/   Blinking counter
TestTrg[4..1]	: node; -- nodes for a =sophisticated= tests
--Test[8..1]		: --declared as outputs

Im_Ram[11..0]	: ImRam;
Im_RamCt[11..0]	: lpm_counter with (lpm_width = 8, lpm_direction="up" ); -- 

TestRAM			: TestRAM_main;
TestRAM_cs		: node;

--============================================================================
BEGIN

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
DEFAULTS

PLLinst_S0	= VCC;  PLLinst_S1	= GND;  PLLinst_EN	= GND;

ADC_SEN[2..0]	= VCC;
ADC_SDATA[2..0]	= GND;
ADC_SCLK		= GND;

WriteDATA.data[] = GND;

ExtRAM_Addr[15..0]		= GND;
ExtRAM_OutEn			= VCC;
ExtRAM_CEn				= VCC;
ExtRAM_WriteEn			= VCC;
ExtRAM_LowerByteControl	= VCC;
ExtRAM_UpByteControl	= VCC;

Compres.buffer_DATA[11..0] = GND;
Compres.reset_n = VCC;
ReadExtMem = VCC;

REN		= GND; -- aee??eou/auee??eou auoiau Deserializer  
DEN		= VCC; -- aee??eou/auee??eou auoiau Serializer
RPWDN	= GND; -- aee??eou/auee??eou Deserializer  
TPWDN	= VCC; -- aee??eou/auee??eou Serializer
FLink_Error = GND;

StProc_Link  = GND; St_ADC_Link = GND; St_One = GND; St_Multi = VCC;

TypeCMD3   = GND;   TypeIP = GND;       TypeARP  = GND; 
RxIPheader.D = GND; RxIP_Saddr.D = GND; RxIP_Daddr.D = GND; RxUDPDBlck = GND;
RxARPheadr.D = GND; RxARPSaddr.D = GND; RxARPDaddr.D = GND; RxARPDadIP = GND;
RxARPDBlck.D = GND;
ProtoNext  = GND;   EthAdrInit   = GND; EthNextAdr[].D = 0;   

--StProc_Ether = GND; StEthTx_Ether=GND;
%Ether.TxLenTyp[]=0;% Ether.TxLength[]=0; 
Eth_WRITE = GND;    

IPhdCRCadder.clken = GND;

END DEFAULTS;

--============================================================================
--******** 1. Reference Clock & Frequency Control ****************************

--============================================================================
--******** 1a. POWER_UP self-Reset pulse *************************************
--PowerUp0= DFF (.d=!(camac_s1 & camac_s2) AND PLL1.locked, .clk=Clk25);
        --               ^^^^^^^^ substituted by (CAMAC_IFace.Reset & CAMAC_IFace.Aout[4])..
        --  .. to provide a possibility to emulate PowerUp situation
PowerUp0 = DFF (.d=PLL.locked, .clk=Clk25); --!ExtReset AND 

PowerUp1 = SRFF(.s=(PowerUp0 AND (TestCt.q25 & TestCt.q0)),--sets 1.0s after PLL1 has locked
				.r=ExtReset, .clk=Clk25);  -- .r never =1
PowerUp2 = SRFF(.s=(PowerUp1 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);  -- .r never =1
PwrUpReset  = PowerUp1 AND !PowerUp2;   -- ONE pulse ~1sec after powering up

--******** 1b. POWER_UP self-Set pulse ***************************************
PowerUp3 = SRFF(.s=(PowerUp2 AND (!TestCt.q20 & !TestCt.q19 &  TestCt.q18)), --sets 0.015s after PwrUpReset
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PowerUp4 = SRFF(.s=(PowerUp3 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PwrUpSet1   = PowerUp3 AND !PowerUp4;       -- ONE pulse ~0.015sec after PwrUpReset

--******** 1c. POWER_UP self-Set pulse ***************************************
PowerUp5 = SRFF(.s=(PowerUp4 AND ( TestCt.q20 & !TestCt.q19 & !TestCt.q18)), --sets 0.060s after PwrUpReset
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PowerUp6 = SRFF(.s=(PowerUp5 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PwrUpSet2 = PowerUp5 AND !PowerUp6;       -- ONE pulse ~0.060sec after PwrUpReset

--**************** Automatic Clock Switch for PLL reference ******************
PhaseSw.clock	= FQuartz ;         -- 25MHz from Quartz
PhaseSw.LinkClk	= LinkClk ;         -- 25MHz from Link
PhaseSw.Reset	= GND  ;
--    Phase25     = PhaseSw.Phase25 ; -- selected clock output to real pin
Sw_LinkClk		= PhaseSw.LinkClk_selected; -- connects Link's Clock to PLL ref.Input
Sw_Quartz		= !PhaseSw.LinkClk_selected; -- connects Quartz to PLL ref.Input

IF (PhaseSw.LinkClk_selected == VCC) Then PLL_res = LinkClk;
									 Else PLL_res = FQuartz;
END IF;

--PLL_res = FQuartz;
--**************** PLL section ***********************************************
PLL.inclk0	= PLL_in;           -- ~25MHz from Link -> Input of PLL
Clk25		= PLL.c0;           --  25MHz = (Fin x 1)    from PLL.c0
Clk100		= GLOBAL(PLL.c1);   -- 100MHz = (Fin x 4)    from PLL.c1
Clk12_5		= GLOBAL(PLL.c2);   -- 150MHz = (Fin x 2)    from PLL.c1
--Clk75		= GLOBAL(PLL.c4);   -- 75MHz = (Fin x 3)    from PLL.c1
Clk300_adc	= GLOBAL(PLL.c4);
PLL_ExtOut	= PLL.c0; --PLL.c3;           --  25MHz -> outside of Altera
--PLL1.pfdena = VCC;--!Reset;
--        = PLL.locked;           -- connected below

--**************** Synchro-signals generation ********************************
--  25MHz Clock ^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^
-- 100MHz Clock _/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\__
--                           ^-this falling edge is selected
--    Clk25Del1 ^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^
--    Clk25Del2 ^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_________
--    Phase12   __________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____synchronized with actual _/ of StartBit
--    Synchro12 _____________/^^^^^^^\__________________________________aligned to actual _/ of StartBit
--    Synchro25 _____________/^^^^^^^\_______________________/^^^^^^^\__aligned to actual _/ of StartBit and to half-PHASE

Clk25Del1	= DFF(.d=Clk25,    .clk=!Clk100); 
Clk25Del2	= DFF(.d=Clk25Del1,.clk=!Clk100); 

PhaseSet	= EdgeSensing(.d=Link_IFace.LinkMessage, -- must be aligned: 
						.clk=Clk100, .reset=RESET); -- 8 or 16 "Clk100"clocks after actual _/ of StartBit
Phase12		= DFFE(.d=!Phase12,.clk=Clk100, .ena=(!Clk25Del1 & !Clk25Del2),
					.prn=!PhaseSet);            -- F = (2*Fphase)/2 , _/ aligned to Phase
                    -- ^^^^ excluded temporary !!

Synchro12	= DFF(.d=(!Clk25Del1 & Clk25Del2 & !Phase12), .clk=!Clk100 );
Synchro25	= DFF(.d=(!Clk25Del1 & Clk25Del2), .clk=!Clk100 );

--============================================================================
-- ******** 2. Indicators section ********************************************
LedG = OPNDRN ( !(((PLL.locked AND  PhaseSw.LinkClk_Selected) --always "ON" => PLL locked to LinkClock
				OR (PLL.locked AND !PhaseSw.LinkClk_Selected AND TestCt.q[25])))); --blinks slowly => PLL locked to Quartz
--LedG = OPNDRN (!(TestCt.q[25]));        -- for TEST
LinkFlash.(clock, event)= (Clk100, Link_IFace.LinkMessage);

LedB = OPNDRN( !(B_Flash.DirOut OR Busy));
--LedB = OPNDRN( !TestCt.q[21] ) ;    -- for TEST Only! - quick blink
B_Flash.(clock, event)  =(Clk100,Busy); -- Busy is defined in Control Unit section

LedR = R_Flash.LightOut;
--LedR = OPNDRN( TC.q[21] ) ;         -- for TEST Only! - quick blink
R_Flash.(clock, event)  =(Clk100,Error);-- Error is defined in Control Unit section

LedTest  = Test_Flash.LightOut;
--Test_Flash.(clock, event)   =(Clk100, Ether_ARPreply); --Indicator of a chosen Event
Test_Flash.(clock, event)   =(Clk100, Ether.TX_EN); --Indicator of a chosen Event

--============================================================================
--******** 3. LINK's Interface ***********************************************
--	Serial Port
%
LinkData    = TRI (!Link_IFace.LinkData_out, Link_IFace.TxRx);-- Output to Pin
Link_IFace.LinkData_in = !LinkData ;                          -- Input from Pin
LinkTxRx    =  ( Link_IFace.TxRx );     -- Tx/Rx control, High => Tx
%
b2v_inst5.(datain, datain_b) = (LinkData_p, LinkData_n);    -- pins LinkData_p -> diffin.datain   \_single-
--														    --      LinkData_n -> diffin.datain_b / -ended
Link_IFace.LinkData_in = (b2v_inst5.dataout AND !Link_IFace.TxRx);  -- RECEIVING data

b2v_inst2.i = Link_IFace.LinkData_out;                     -- pdo
b2v_inst3.(datain, oe) = (b2v_inst2.o,    Link_IFace.TxRx); -- seio - Serial IO ?
b2v_inst4.(datain, oe) = (b2v_inst2.obar, Link_IFace.TxRx); -- seio - Serial IO ?
LinkData_p = b2v_inst3.dataout;
LinkData_n = b2v_inst4.dataout;

-- Project Bus Port
Link_IFace.Clock	=	Clk100 ;

--    = Link_IFace.IORq ;               -- Connected at Processor section
--    = Link_IFace.RdWr_out;            -- Connected at Processor section
--    = Link_IFace.LinkMessage ;        -- connected at "Control Unit" section

Link_IFace.DataBus_in[] = DataBus[] ;
--    = Link_IFace.DataBus_out[] ;      -- connected at "Internal Bus ..." section
Link_IFace.Select       = DevSel[4].q %OR DevSel[5].q% ;
Link_IFace.RdWr_in      = RW ;
Link_IFace.DataStrobe   = DataStrobe ;

Link_IFace.Reset        = RESET ;

--==============================================================================
--********  4. ETHERNET Interface  *********************************************
--==============================================================================

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  RECEIVER section  ************

Ether.RX_CLK = RxClk;   --Ether-Rx Clock: Ether module <- Rx-channel of Eth_Controller
Ether.RX_DV = RxDV;     --"DataValid"   : Ether module <- Rx-channel of Eth_Controller
Ether.COL = Col;        --"Collision"   : Ether module <-     -//-
Ether.CRS = Crs;        --"CarrierSense": Ether module <-     -//-
Ether.RXD[3..0] = RxD[3..0];--Data half-Byte: Ether mod <- Rx-channel of Eth_Controller

--This_Device' address (to be sent at SourceAddr field of the reply packets)
Ether.Saddr[48..1] = ThisDeviceAddr;--for Test: 0110011001100110....1000110011101111

--       = Ether.RxWaitSFD        --connected below Waiting for "StartFrameDelimiter"
--       = Ether.RxDestAddr       --connected below "DestinationAddr" is being received
--       = Ether.RxSourAddr       --connected below "SourceAddr" is being received
--       = Ether.RxPkLenTyp       --connected below "Length/Type" is being received
--       = Ether.RxDataBlck;      --connected below
--       = Ether.RxFrameCRC;      --connected below
--       = Ether.RxEndFrame;      --connected below
--       = Ether.RxLenTyp[16..1]; -- value of the "PkLength/Type" field
--       = Ether.RxLength[12..1]; --for RAW packets - Length(Bytes) of the DataBlock (MSbit always =0 !)
--Ether.RxLengIn[12..1] =         --for other packets - Length(Bytes) of the DataBlock (MSbit always =0 !), 
        -- ^^^^defined in "LENGTH/TYPE  RECOGNITION" sub-section
--       = Ether.TypeRaw;         -- connected "LENGTH/TYPE  RECOGNITION" sub-section
--       = Ether.RxError;         --connected below
--       = Ether.DataBus_out[];   --connected below  

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  TRANSMITTER section  ************

Ether.TX_CLK = TxClk;           -- Ether-Tx Clock: "ETHERNET" <- Tx-chan of Eth_Controller
TxEn = Ether.TX_EN;             -- Initiate a Transmission
TxD[3..0] = Ether.TXD[3..0];    -- half-Bytes of Data -> Eth_Controller

Ether.StTransmit= StartEthTx.q; -- StartEthTx is defined in "Control Unit" section
--Ether.TxLenTyp[16..1] =         -- connected in "Ethernet command proceeding" sub-section
--Ether.TxLength[12..1] =         -- connected in "Ethernet command proceeding" sub-section
--      = Ether.TxStFrmDel
--      = Ether.TxPkLenTyp 
--      = Ether.TxDataBlck        -- connected below
--      = Ether.TxEndFrame;       -- connected in "ETHERNET Cycle proceeding units" section 
--      = Ether.TxError;          --connected in ??
Ether.DataBus_in[15..0] = TxDataBus[15..0]; 


Ether.RESET = RESET # RxStop ; -- reset
--    = Ether.Test[8..1];       -- connected at the "Testing circuitry" section 

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  Data Write/Read to/from the =local= RAM/ROM  :  ****************
--(Data received in the entire DataBlock)/(Data to be transmitted in the entire DataBlock)
--  are written/read by ETHERNET to/from EtherRAM via PortA.

--************  Ethernet Memory (2-port RAM)  **********************************
--EtherRAM.(address_b[9..0],          data_b[],  wren_b  ) =  --\ for reading out 
--        ((B"0000",CtProtoAdr[5..0]), H"0000",          );   -- > sequences of HandlingWords
----            = EtherRAM.q_b[];  -- connected below         --/ for execution of Protocols
--EtherRAM.(clock_b,enable_b) = (RxClk, VCC); 
EtherRAM.(clock_b, enable_b)= (Clk100, VCC); 
If DevSel[9] == VCC Then EtherRAM.(address_b[9..0], data_b[], wren_b) = 		  --\ for common
								  (AddrBus[9..0],   DataBus[],(DataStrobe & RW)); -- > access
					Else EtherRAM.(address_b[9..0], data_b[], wren_b) = 
								  (Write_IntRamCt.q[], ExtRAM_Data[], (Read_time.q));
End if;
--      = EtherRAM.q_b[];     -- connected in DataBus section       --/ (except "Ethernet")

EtherRAM.(clock_a,enable_a) = (Clk100, VCC);
EtherRAM.(address_a[9..0],   data_a[],            wren_a ) =    --\ for local access 
		 (EtherAdrCt.q[9..0], Ether.DataBus_out[], EthWord_Rd);  --/ from inside of "Ethernet" section
--		= EtherRAM.q_a[];     -- connected in "START of an ETHERNET Tx Cycle" sub-section

--************  Counter which contains the Address for Writing/Reading ..
--.. DWords of the DataBlock  to/from EtherRAM
EtherAdrCt.(clock, clk_en)  = (Clk100, VCC);
EtherAdrCt.cnt_en  = (!EthAddrLd2 & EthAdrCt_en); --increments =after= a DWord has been stored
EtherAdrCt.sload   = ( EthAddrLd2 & EthAdrCt_en); --=after= a DWord has been stored, ..
EtherAdrCt.data[]  = (B"0000",EthNextAdr[6..1]);  --.. loads InitAddress for next Stage ..
EtherAdrCt.sclr = DFF(.D=(Ether.RxWaitSFD # Ether.RxEndFrame), .clk=Clk100);

--************ ETHERNET's Bus Port : *******************************************
Ether.Clock = Clk100; -- Clock Frequency MUST BE > 50MHz !!!!

--    = Ether.IORq;             -- Connected at "Bus Handler" sub-section
--    = Ether.RdWr_out;         -- Connected at "Bus Handler" sub-section
--Ether.DataBus_in[15..0] = EtherRAM.q_a[];   -- data:  connected in "START of an ETHERNET Tx Cycle" sub-section
Ether.Select  = Eth_AddrSettled;   -- Ethernet is selected for local data reading/writing
Ether.RdWr_in = RdWr;              -- RdWr=0 => data: EtherRAM <- Ethernet / RdWr=1 => data: EtherRAM -> Ethernet
Ether.DataStrobe = Eth_DataStrobe; -- input data must be latched while DataStrobe=1 
--    = Ether.DataBus_out[];    -- data:  Ethernet -> EtherRAM (connected at "Ethernet Memory" sub-section)

--************ (Local)Bus Handler : ********************************************
Eth_AcsRqDetect = EdgeSensing(.D=Ether.IORq, .clk=Clk100, .reset=RESET);
Eth_AccessGrtd	=SRFF(.S=Eth_AcsRqDetect,.clk=Clk100,.R=Eth_DataStrobe, .clrn=!RESET); --=1 during whole Operation
Eth_AddrSettled=SRFF(.S=(Eth_AccessGrtd & !Eth_AddrSettled),                          --flag; enables "DevSel[]" triggers
                    .clk=Clk100, .R=Eth_DataStrobe, .clrn=!RESET); 
Eth_BusOper1    = DFF(.D=Eth_AddrSettled, .clk=Clk100,.clrn=!(RESET OR Eth_DataStrobe));-- delay by 1 clock
Eth_BusOper2    = DFF(.D=Eth_BusOper1,    .clk=Clk100,.clrn=!(RESET OR Eth_DataStrobe));-- delay by 1 clock
Eth_BusOper3    = DFF(.D=Eth_BusOper2,    .clk=Clk100,.clrn=!(RESET OR Eth_DataStrobe));-- delay by 1 clock
Eth_DataStrobe  = DFF(.D=Eth_BusOper3,    .clk=Clk100,.clrn=!RESET); -- 1-clk pulse

-- Ether.RW_out=0 => Data: MainProj -> Ethernet ("write") => RdWr=1 
-- Ether.RW_out=1 => Data: MainProj <- Ethernet ("read")  => RdWr=0
RdWr   = DFF(.D=!Ether.RdWr_out, .clk=Clk100);  

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--The procedure of receiving of packets other than "Raw" depends crucially on the type ! 
--RxLenType[] has been latched by ETHERNET unit ; 
--RxLenType[] != 0  ONLY if ( Daddr = ThisDeviceAddr  OR  Daddr = Broadcast ) 
--     (see "ETHERNET Interface" section in which all connections of RxLenType[] are defined )

--************ LENGTH/TYPE  RECOGNITION :  *************************************
--  TypeRaw  => Recognized and executed by ETHERNET unit
--  TypeCMD3 => RxLength= 64[Bytes] 
--  TypeIP   => RxLength=IPlength[Bytes]  |  TypeARP => RxLength= 46[Bytes]

TypeRaw = Ether.TypeRaw;                -- RAW packets are recognized by ETHERNET itself
--IF (Ether.RxLenTyp[] >= 1536) Then 
    --CASE Ether.RxLenTyp[] IS 
    --    WHEN  H"CDCC" =>    CMD3-type => according to the Type, length = 64Bytes
    --    WHEN  H"0800" =>    IP     -- Length is defined inside IP-packet
    --End CASE;
IF  (Ether.RxLenTyp[] == H"CDCC") Then  -- IF  CMD3-type, ..
    Typ_CMD3    = VCC;                  -- .. fast flag: Type = CMD3
End IF;
TypeCMD3= DFF(.D=Typ_CMD3, .clk=Clk100);-- registered flag: Type = CMD3

IF  (Ether.RxLenTyp[] == H"0800") Then  -- IF  IP-type, ..
    Typ_IP      = VCC;                  -- .. fast flag: Type = IP
End IF;
TypeIP  = DFF(.D=Typ_IP,  .clk=Clk100);  -- registered flag: Type = IP

IF  (Ether.RxLenTyp[] == H"0806") Then  -- IF  ARP-type, ..
    Typ_ARP     = VCC;                  -- .. fast flag: Type = ARP
End IF;
TypeARP = DFF(.D=Typ_ARP, .clk=Clk100); -- registered flag: Type = ARP

IF    TypeCMD3  Then
    Ether.RxLengIn[]= H"040";           -- .. length of DBlck = 64Bytes (total 82B)
ELSIF TypeIP    Then
    Ether.RxLengIn[]= RxIPleng[12..1];  -- .. length will be extracted from IP-header
ELSIF TypeARP   Then
    Ether.RxLengIn[]= H"02E";           -- .. length of DBlck = 46Bytes (Frame is 64B, MIN)
--ELSIF (RxLenTyp[] <= 1500)     Then     -- IF  this is LENGTH, ..
--    TypeRaw       = VCC;                -- .. flag: Type = Raw
--    RxLength[].d  = RxLenTyp[12..1];    -- .. length => Reg, MSbit always =0 !
ELSE                                    -- IF  an UNKNOWN value, ..
    Ether.RxLengIn[]= H"02E";           --.. set length of DBlck = 46Bytes (Frame is 64B, MIN)
    IF  Ether.RxDataBlck 
      Then  Rx_Err = VCC;               -- set ERROR flag _/^^^^\_
    End IF;
End IF;

--************  PROTOCOL Execution Circuitry :  ********************************
----Signal which initiates execution of a recognized Protocol ( _/^^\_ dur= 1 RxClk ) : 

--Strobe for incrementation EtherRAM' Addr when storing all DWords 
--  of the =entire Frame= (Daddr,Saddr,PkLenType,DataBlock) into EtherRAM
EthWord_Rd  = (!RdWr & Eth_DataStrobe);    -- RdWr=0 => "Read" ETHERNET -> EtherRAM
--Strobe for incrementation EtherRAM' Addr when reading out all DWords requested by ETHERNET
EthWord_Wr  = ( RdWr & Eth_DataStrobe);    -- RdWr=1 => "Write" EtherRAM -> ETHERNET

--Signal for incrementing/setting the EtherAdrCt in the proper time :
EthAdrCt_en = DFF(.clk=Clk100,          --\_strobe for operating EtherAdrCt =after= .. 
        .D=(EthWord_rd                  -- \.. a DWord has been stored into RAM ..
        OR (EthTxAdrInit # EthTxAdrIncr -- /..OR during initializing of Tx_cycle ..
          # EthWord_wr)) );             --/ ..or =after= a DWord has been read out from RAM

--After the entire Ethernet Frame' header (including "PacketLength/Type") has been ..
IF  (Ether.RxDataCt[] == 1 )    --.. stored in RAM (addresses=[0..6]), then ..
  Then  --EthAdrInit    = VCC;    --.. initialize loading of the InitAddr into EtherAdrCt
    IF  (TypeIP ==VCC) Then             --\_IF IP detected, ..
--        EthNextAdr[].D= UDP_InitAddr;   --/ .. set the InitialAddress = UDP_InitAddr
        RxAdrSet1 = VCC;
    End IF;
    IF  (TypeARP==VCC) Then             --\_IF ARP detected, ..
--        EthNextAdr[].D= ARP_InitAddr;   --/ .. set the InitialAddress = ARP_InitAddr
        RxAdrSet2 = VCC;
    End IF;
End IF;
RxAdrSet1a  = DFF (.D=RxAdrSet1,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
RxAdrSet1b  = DFFE(.D=RxAdrSet1a, .clk= Clk100, -- \..RxAdrSet1 has =garanteedly= settled.
            .ena=(!(RxAdrSet1  $ RxAdrSet1a) &  -- / ena:  ( (RxAdrSet1a == RxAdrSet1)
                   (RxAdrSet1a $ RxAdrSet1b)) );--/        & (RxAdrSet1b != RxAdrSet1a) )
RxAdrSet2a  = DFF (.D=RxAdrSet2,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
RxAdrSet2b  = DFFE(.D=RxAdrSet2a, .clk= Clk100, -- \..RxAdrSet2 has =garanteedly= settled.
            .ena=(!(RxAdrSet2  $ RxAdrSet2a) &  -- / ena:  ( (RxAdrSet2a == RxAdrSet2)
                   (RxAdrSet2a $ RxAdrSet2b)) );--/        & (RxAdrSet2b != RxAdrSet2a) )

IF    RxAdrSet1b  Then
    EthAdrInit    = VCC;                -- initiates Loading of the new address
    EthNextAdr[].D= UDP_InitAddr;       --/ .. set the InitialAddress = UDP_InitAddr
End IF;
IF    RxAdrSet2b  Then
    EthAdrInit    = VCC;                -- initiates Loading of the new address
    EthNextAdr[].D= ARP_InitAddr;       --/ .. set the InitialAddress = ARP_InitAddr
End IF;

--EthAddrLd0  = DFF(.D=EthAdrInit,                  --\_ "request" for loading NextAddr, ..
--                .clk=Clk100, .clrn=!EthAddrLd2);  --/ .. aligned to Clk100
--EthAddrLd1  = DFF(.D=EthAddrLd0,--EthAdrInit,                  --\_ "request" for loading NextAddr, ..
EthAddrLd1  = DFF(.D=EthAdrInit,                  --\_ "request" for loading NextAddr, ..
                .clk=Clk100, .clrn=!EthAddrLd2);  --/ .. aligned to Clk100
EthAddrLd2  = SRFF(.S=EthAddrLd1, .R=EthAdrCt_en, --\_resets to =0 just after ..
                .clk=Clk100);                     --/..next addr is loaded into EtherAdrCt

--"Register" containing initial addr for storing data during the next Stage of Rx or Tx :
EthNextAdr[].(clk, ena) = (Clk100, EthAddrLd1); -- .D inputs connected above and below

--Main Protocol Cycle Counter :
CtProto.(clock,clk_en, cnt_en)  = (RxClk, VCC, DFF(.D=(TypeIP # TypeARP), .clk=RxClk) );
CtProto.sclr    = ProtoNext # !(TypeIP # TypeARP);  -- when going to the next Stage

ProtoInited = SRFF(.S=(RxIPheader # RxARPheadr),--flag: IP or ARP =has been= initiated
        .R=(Ether.RxEndFrame # Ether.RxError),  --\_reset after entire Packet has been received ..
        .clk=RxClk);                            --/ ..or if Error of receiving occured

-- Unnecessary trigger, but it helps Quartus to analyze the logics of Stages correctly:
RxDVtrig = DFF(.D=RxDV, .clk=RxClk);
-- Triggers which represent the Stages of execution of the recognized Protocol :
( RxIPheader, RxIP_Saddr, RxIP_Daddr, RxUDPheadr, RxUDPDBlck,
  RxARPheadr, RxARPSaddr, RxARPDaddr, RxARPDadIP, RxARPDBlck).clk   = RxClk; 

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  EXECUTION of IP-Protocol :  receiving of IP-packet  ************
--      TypeIP   => RxLength=IPlength[Bytes], and IP chain of StateMachine is started

IF  (TypeIP & !ProtoInited )    -- IF IP-packet is recognized, .. 
    Then            -- RxIPheader =1,  CtProto  = 0,
                    -- RxIPheader =1,  CtProto  = 1,
                    -- RxIPheader =1,  CtProto  = 2, 
                    -- RxIPheader =1,  CtProto  = 3, Ether.DataBus_out = DWord01
                    --  .  .  .  .  .  .  .  .  .  .  .  .  .  .
                    -- RxIPheader =1,  CtProto  = 7, Ether.DataBus_out = DWord02="IP_Length"  
                    --  .  .  .  .  .  .  .  .  .  .  .  .  .  .
                    -- RxIPheader =1,  CtProto  =19, Ether.DataBus_out = DWord05(MSByte="IPencaps-Proto")
                    --  .  .  .  .  .  .  .  .  .  .  .  .  .  .
    RxIPheader.D  = VCC;            --..then RxIPheader will flip to =1 by next _/RxClk
ELSIF (RxIPheader AND RxDVtrig) Then    -- receiving IP-header (12 Bytes) :
    IF  (CtProto.q[] == 23 ) -- IF it's time to go to receive "IP-SourceAddr", ..
      Then  RxIPheader.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxIP_Saddr.D  = VCC;    -- >.. to receive "IP-SourceAddr", ..
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
    ELSE
            RxIPheader.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the IP-header
ELSE      -- if receiving has crashed, 
    RxIPheader.D  = GND;        --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;        --/ .. to the initial state 
End IF;

IF  (RxIP_Saddr AND RxDVtrig)   -- receiving IP-SourceAddr (4 Bytes) :
    Then            -- RxIP_Saddr =1,  CtProto  = 0, 1, ..
                    -- RxIP_Saddr =1,  CtProto  = 3, Ether.DataBus_out = IP-Saddr[32..17]
                    -- RxIP_Saddr =1,  CtProto  = 7, Ether.DataBus_out = IP-Saddr[16.. 1]
    IF  (CtProto.q[3..0] == 7)  --  IF 4Bytes of "IP-SourceAddr" received, .. 
      Then  RxIP_Saddr.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxIP_Daddr.D  = VCC;    -- > .. to receive "IP-DestinationAddr"
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
    ELSE
            RxIP_Saddr.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the IP-SourceAddr
ELSE      -- if receiving has crashed, 
    RxIP_Saddr.D  = GND;      --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;      --/ .. to the initial state 
End IF;

IF  (RxIP_Daddr AND RxDVtrig)   -- receiving IP-DestinationAddr (4 Bytes) :
    Then            -- RxIP_Saddr =1,  CtProto  = 0, 1, ..
                    -- RxIP_Saddr =1,  CtProto  = 3, Ether.DataBus_out = IP-Daddr[32..17]
                    -- RxIP_Saddr =1,  CtProto  = 7, Ether.DataBus_out = IP-Daddr[16.. 1]
    IF  (CtProto.q[3..0] == 7)  --  IF 4Bytes of "IP-DestinationAddr" received, .. 
      Then  RxIP_Daddr.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxUDPheadr.D  = TypeUDP;-- > .. to receive UDP-header, =IF UDP detected!=
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
    ELSE
            RxIP_Daddr.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the IP-DestinAddr
ELSE      -- if receiving has crashed, 
    RxIP_Daddr.D  = GND;        --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;        --/ .. to the initial state 
End IF;

IF  (RxUDPheadr AND RxDVtrig)   Then    --ANYWAY, begin receiving UDP-header ..
    --..until the moment when the result of comparison of IP-Daddr and ThisDeviceIP is ready
    IF  (DadrIP_cmp AND !ChkIPDaddr)--\_IF this packet is sent NOT to ThisDevice, ..
      Then  RxUDPheadr.D= GND;      -- >..Then STOP execution of Protocol\_(by next _/RxClk)
            RxStop      = VCC;      --/ ..and STOP receiving             /
    ELSIF (CtProto.q[] ==15)   --  IF 8Bytes of "UDP-header" received, .. 
      Then  RxUDPheadr.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxUDPDblck.D  = VCC;    -- >.. to receive UDP-DataBlock, ..
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
    ELSE        -- IF receiving is going OK, 
            RxUDPheadr.D= VCC;      --.. just continue receiving the UDP-header
--        IF(CtProto.q[3..0]==4) Then -- when "UDP-SourPort" received, ..
--            EthAdrCnd7.d  = VCC;    --initiates storing the rest data of UDP-header
--        End IF;
    End IF;
ELSE      -- if receiving has crashed, 
    RxUDPheadr.D  = GND;        --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;        --/ .. to the initial state 
End IF;

IF  ((RxUDPDBlck AND RxDVtrig)  --\_receiving IP-DataBlock..
    AND ChkIPDaddr )  Then  --/ ..ONLY IF This_IP-packet is addressed to ThisDevice ..
    IF  Ether.RxFrameCRC            -- IF receiving of DataBlock has been finished, .. 
      Then  RxUDPDBlck.D= GND;      --.. Then STOP execution of Protocol (by next _/RxClk)
    ELSE
            RxUDPDBlck.D= VCC;      -- IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the IP-DataBlock
ELSE      -- if receiving has crashed, 
    RxUDPDBlck.D  = GND;        --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;        --/ .. to the initial state 
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- Latch the 11-bit value of IP-Packet' length (to be forwarded to ETHERNET) :
RxIPleng[12.. 1].d  = Ether.DataBus_out[11..0]; -- 12bits of the "IPlength" field
RxIPleng[12.. 1].clk= RxClk;        --\_latches in 2*RxClk after receiving "IP-Length", 
RxIPleng[12.. 1].ena= RxIPleng_ld;  --/ .. just ONCE in IP-Cycle.
RxIPleng[12.. 1].clrn = !Ether.RxEndFrame;  -- reset to =0 at the End of Frame

--Strobe for catching the DWord02="IP-Length" :  2*RxClk _/^^^^\_, ..
RxIPleng_ld = RxIPheader AND (CtProto.q[5..0]==8);  --.. appears just ONCE in IP-cycle

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
%-- Latch the 8-bit value of Protocol (UDP?) within IP-Packet :
RxIP_Pro[ 8.. 1].d  = Ether.DataBus_out[ 7..0]; -- 8bits of the "Protocol" field
RxIP_Pro[ 8.. 1].clk= RxClk;            --\ latches in 1 RxClk 
RxIP_Pro[ 8.. 1].ena= RxIPheader AND    -- >  after receiving DWord05(LSByte="USB")
        ( CtProto.q[5..0]==19) ;        --/   just ONCE in IP-Cycle.
RxIP_Pro[ 8.. 1].clrn = !RxEndFrame;        -- reset to =0 at the End of Frame
%
--********  Recognition of the UDP protocol tag  *******************************
IF  ( (CtProto.q[] == 19) AND (Ether.DataBus_out[7..0] == H"11") )
    Then    TypeUDP.S = VCC;
End IF;
TypeUDP.(R,clk) = (Ether.RxEndFrame, RxClk);    --For Test ONLY !

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  EXECUTION of ARP-Protocol :  receiving of ARP-packet  **************
--  TypeARP => RxLength=H"02E"=46[Bytes], and ARP chain of StateMachine is started

IF  (TypeARP & !ProtoInited )   -- IF ARP-packet is recognized, .. 
    Then            -- RxARPheadr =1,  CtProto  = 0,
                    -- RxARPheadr =1,  CtProto  = 1,
                    -- RxARPheadr =1,  CtProto  = 2, 
                    -- RxARPheadr =1,  CtProto  = 3, Ether.DataBus_out = DWord01
                    --  .  .  .  .  .  .  .  .  .  .  .  .  .  .
                    -- RxARPheadr =1,  CtProto  =15, Ether.DataBus_out = DWord04="OpCode"  
    RxARPheadr.D  = VCC;            --..then RxARPheadr will flip to =1 by next _/RxClk
ELSIF (RxARPheadr AND RxDVtrig) Then    -- receiving ARP-header ( 8 Bytes) :
    IF  (CtProto.q[] ==12) Then
--            EthAdrInit    = VCC;                --\_initiates Loading of the new addr, ..
--            EthNextAdr[].D= ARP_InitAd_plus23;  --/ prepare for storing ARP-OpCode
            RxAdrSet3 = VCC;
    End IF;
    IF  (CtProto.q[] ==15 ) -- IF 8Bytes of ARP-header received, ..
      Then  RxARPheadr.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxARPSaddr.D  = VCC;    -- >.. to receive Source' Addr, ..
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
--            EthAdrInit    = VCC;                --\_initiates Loading of the new addr, ..
--            EthNextAdr[].D= ARP_InitAd_plus09;  --/ prepare for storing "SourAddr", to be used as "DestAddr"
            RxAdrSet4 = VCC;
    ELSE
            RxARPheadr.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the IP-header
ELSE      -- if receiving has crashed, 
    RxARPheadr.D  = GND;        --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;        --/ .. to the initial state 
End IF;

IF  (RxARPSaddr AND RxDVtrig)   -- receiving Source' Addr (MAC+IP = 6+4 [Bytes]) :
    Then            -- RxARPSaddr =1,  CtProto  = 0, 1, ..
                    -- RxARPSaddr =1,  CtProto  = 3, Ether.DataBus_out = SourAddr[48..33]
                    -- RxARPSaddr =1,  CtProto  = 7, Ether.DataBus_out = SourAddr[32..17]
                    -- RxARPSaddr =1,  CtProto  =11, Ether.DataBus_out = SourAddr[16.. 1]
                    -- RxARPSaddr =1,  CtProto  =15, Ether.DataBus_out = IP-Saddr[32..17]
                    -- RxARPSaddr =1,  CtProto  =19, Ether.DataBus_out = IP-Saddr[16.. 1]
    IF  (CtProto.q[] ==19)   --  IF (6+4)Bytes of Source' (MAC+IP)addr received, .. 
      Then  RxARPSaddr.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxARPDaddr.D  = VCC;    -- >.. to receive Destination' Addr, ..
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
--            EthAdrInit    = VCC;    -- initiates Loading of the new address
--            EthNextAdr[].D= ARP_InitAd_plus16;  --addr. for storing "DestAddr"=H"00..00", to be IGNORED
            RxAdrSet5 = VCC;
    ELSE
            RxARPSaddr.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the Source' Addr
ELSE      -- if receiving has crashed, 
    RxARPSaddr.D  = GND;      --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;      --/ .. to the initial state 
End IF;

--In ARP-request the Dest-n'Addr (MAC +IP) is ThisDevice'Addr => it is NOT NEEDED.
--Hence, "DestAddr"+"IP-Daddr" are written into the same addresses where the rest part..
--..of ARP-request will be written => "DestAddr"+"IP-Daddr" will be overwritten !
IF  (RxARPDaddr AND RxDVtrig)   -- receiving Destination' Addr (MAC only! = 6[Bytes]) :
    Then            -- RxARPSaddr =1,  CtProto  = 0, 1, ..
                    -- RxARPSaddr =1,  CtProto  = 3, Ether.DataBus_out = DestAddr[48..33]
                    -- RxARPSaddr =1,  CtProto  = 7, Ether.DataBus_out = DestAddr[32..17]
                    -- RxARPSaddr =1,  CtProto  =11, Ether.DataBus_out = DestAddr[16.. 1]
    IF  (CtProto.q[] ==11)   --  IF 6Bytes of Destination' MAC-addr received, .. 
      Then  RxARPDaddr.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxARPDadIP.D  = VCC;    -- >.. to receive Destination' IP-Addr, ..
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
    ELSE
            RxARPDaddr.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the Source' Addr
ELSE      -- if receiving has crashed, 
    RxARPDaddr.D  = GND;      --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;      --/ .. to the initial state 
End IF;

--"RxARPDadIP" in receiving ARP-request is conducted as =separate= Stage so that ..
--everything proceed identically to the "RxIP_Daddr" Stage (particularly, CtProto.q[]=[0..7]).
IF  (RxARPDadIP AND RxDVtrig)   -- receiving DestinationAddr (IP only! = 4[Bytes]) :
    Then            -- RxARPDadIP =1,  CtProto  = 0, 1, ..
                    -- RxARPDadIP =1,  CtProto  = 3, Ether.DataBus_out = IP-Daddr[32..17]
                    -- RxARPDadIP =1,  CtProto  = 7, Ether.DataBus_out = IP-Daddr[16.. 1]
    IF  (CtProto.q[] == 7)   --  IF 4Bytes of Destination' IP-addr received, .. 
      Then  RxARPDadIP.D  = GND;    --\ .. Then  jump (by next _/RxClk) ..
            RxARPDBlck.D  = VCC;    -- >.. to receive the (empty)DataBlock, ..
            ProtoNext     = VCC;    --/ ..and Protocol Circuitry jump to the next Stage
--            EthAdrInit    = VCC;    -- initiates Loading of the new address
--            EthNextAdr[].D= ARP_InitAd_plus14;  --addr. for storing (empty)DataBlock
            RxAdrSet6 = VCC;
    ELSE
            RxARPDadIP.D  = VCC;    --IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the Source' Addr
ELSE      -- if receiving has crashed, 
    RxARPDadIP.D  = GND;      --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;      --/ .. to the initial state 
End IF;

IF  (RxARPDBlck AND RxDVtrig)   Then    --  always begin receiving ARP-DataBlock ..
    --..until the moment when the result of comparison of IP-Daddr and ThisDeviceIP is ready
    IF  (DadrIP_cmp AND !ChkIPDaddr)--\_IF this packet is sent NOT to ThisDevice, ..
      Then  RxARPDBlck.D= GND;      -- >..Then STOP execution of Protocol\_(by next _/RxClk) 
            RxStop      = VCC;      --/ ..and STOP receiving             /
    ELSIF  Ether.RxFrameCRC         --\_ IF receiving of DataBlock has been finished, .. 
      Then  RxARPDBlck.D= GND;      --/ .. Then STOP execution of Protocol (by next _/RxClk)
    ELSE
            RxARPDBlck.D= VCC;      -- IF receiving is going OK, .. 
    End IF;                         --.. just continue receiving the ARP-DataBlock
ELSE      -- if receiving has crashed, 
    RxARPDBlck.D  = GND;        --\_.. STOP (by next _/RxClk) .. 
--    RxLineIdle.D  = VCC;        --/ .. to the initial state 
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--Circuit which handles the Ether'addresses within Rx_Cycle ;
--  Triggers are connected in to decouple stages of big logic.
RxAdrSet3a  = DFF (.D=RxAdrSet3,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
RxAdrSet3b  = DFFE(.D=RxAdrSet3a, .clk= Clk100, -- \..RxAdrSet3 has =garanteedly= settled.
            .ena=(!(RxAdrSet3  $ RxAdrSet3a) &  -- / ena:  ( (RxAdrSet3a == RxAdrSet3)
                   (RxAdrSet3a $ RxAdrSet3b)) );--/        & (RxAdrSet3b != RxAdrSet3a) )

RxAdrSet4a  = DFF (.D=RxAdrSet4,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
RxAdrSet4b  = DFFE(.D=RxAdrSet4a, .clk= Clk100, -- \..RxAdrSet4 has =garanteedly= settled.
            .ena=(!(RxAdrSet4  $ RxAdrSet4a) &  -- / ena:  ( (RxAdrSet4a == RxAdrSet4)
                   (RxAdrSet4a $ RxAdrSet4b)) );--/        & (RxAdrSet4b != RxAdrSet4a) )

RxAdrSet5a  = DFF (.D=RxAdrSet5,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
RxAdrSet5b  = DFFE(.D=RxAdrSet5a, .clk= Clk100, -- \..RxAdrSet5 has =garanteedly= settled.
            .ena=(!(RxAdrSet5  $ RxAdrSet5a) &  -- / ena:  ( (RxAdrSet5a == RxAdrSet5)
                   (RxAdrSet5a $ RxAdrSet5b)) );--/        & (RxAdrSet5b != RxAdrSet5a) )

RxAdrSet6a  = DFF (.D=RxAdrSet6,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
RxAdrSet6b  = DFFE(.D=RxAdrSet6a, .clk= Clk100, -- \..RxAdrSet6 has =garanteedly= settled.
            .ena=(!(RxAdrSet6  $ RxAdrSet6a) &  -- / ena:  ( (RxAdrSet6a == RxAdrSet6)
                   (RxAdrSet6a $ RxAdrSet6b)) );--/        & (RxAdrSet6b != RxAdrSet6a) )

IF    RxAdrSet3b  Then
    EthAdrInit    = VCC;                -- initiates Loading of the new address
    EthNextAdr[].D= ARP_InitAd_plus23;  --addr. for storing ARP-OpCode
End IF;
IF    RxAdrSet4b  Then
    EthAdrInit    = VCC;                -- initiates Loading of the new address
    EthNextAdr[].D= ARP_InitAd_plus09;  --addr. for storing "SourAddr", to be used as "DestAddr"
End IF;
IF    RxAdrSet5b  Then
    EthAdrInit    = VCC;                -- initiates Loading of the new address
    EthNextAdr[].D= ARP_InitAd_plus16;  --addr. for storing "DestAddr"=H"00..00", to be IGNORED
End IF;
IF    RxAdrSet6b  Then
    EthAdrInit    = VCC;                -- initiates Loading of the new address
    EthNextAdr[].D= ARP_InitAd_plus14;  --addr. for storing (empty)DataBlock
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  CHECK-UP of the IP-Daddr :  ****************************************
ThisDeviceIP[32..1] = ThisDeviceIPAddr; -- enter a constant into a =bus=

--Check-up of IP-address in ARP (mandatory!) and in IP (optional) Protocols :
IF  (RxARPDadIP OR RxIP_Daddr)  --\_at 6th period of RxClk ..
    AND (CtProto.q[] == 6) Then --/ .. from the beg-g of "RxARPDadIP" Stage or "RxIP_Daddr" Stage ..
        ChkIPDaddr.d   =        --  .. compare MSWord of IP-Daddr and MSWord of ThisDeviceIP
            ( Ether.DataBus_out[] == ThisDeviceIP[32..17] ) ;
        DadrIP_MSW     = VCC;   -- strobe for checking the MSW of IP-Daddr
        DadrIP_LSW1    = VCC;   --initiate a strobe for checking the LSW of IP-Daddr
End IF;

DadrIP_LSW2 = DFF(.D=DadrIP_LSW1, .clk=RxClk);  --\ DadrIP_LSW1  delayed by 4*RxClk ..
DadrIP_LSW3 = DFF(.D=DadrIP_LSW2, .clk=RxClk);  -- \.. is used as a strobe ..
DadrIP_LSW4 = DFF(.D=DadrIP_LSW3, .clk=RxClk);  -- /..for checkking the LSW of IP-Daddr
DadrIP_LSW  = DFF(.D=DadrIP_LSW4, .clk=RxClk);  --/ ..at 10th RxClk from the beg-g of RxARPDadIP Stage

IF  DadrIP_LSW  Then   --at 10th period of RxClk from the beg-g of RxARPDadIP Stage ..
        ChkIPDaddr.d =      --  .. compare LSWord of IP-Daddr and LSWord of ThisDeviceIP
            ( ( Ether.DataBus_out[] == ThisDeviceIP[16.. 1] ) 
            AND ChkIPDaddr );
End IF;

ChkIPDaddr.(clk, ena)  = (RxClk, (DadrIP_MSW # DadrIP_LSW)); 
ChkIPDaddr.clrn = !Ether.RxWaitSFD;     -- reset to =0 at the beg-g of Frame

DadrIP_cmp = DFF(.D=DadrIP_LSW, .clk=RxClk); -- strobe for using the "ChkIPDaddr"

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  Execution of the TypeCMD3-command (not Protocol!)  *****************

--  Circuit which saves CMD3-OpCode received from Ethernet :
Reg_EthOpCode[8..1].D   = Ether.DataBus_out[15..8]; -- 1st Byte is the MSB of the 1st DWord !
Reg_EthOpCode[8..1].(clk, ena)= (Clk100, CMD3OpCode_save);  -- latch the 1st DWord received
Reg_EthOpCode[8..1].clrn      = !RESET;

CMD3OpCode_save = ( TypeCMD3                    --\  when CMD3 packet is received, get..
            AND (EthWord_Rd & !CMD3command));   --/ ..ONLY the 1st DWord of DataBlock
CMD3command     = SRFF(.S=CMD3OpCode_save, 
               .R=(Ether.TxEndFrame # RESET), .clk=Clk100 );

--============================================================================
--******** 6. Digitizers section *********************************************

--Only for test
--============================================================================
-- Im_ADC - a RAM which contains data substituted for the ADC data
%	Im_ADC.data_a[] = GND;
	Im_ADC.(address_a[], clock_a, wren_a) = (Im_ADCCt.q[7..0], ADC_Clock, GND);
	
--	Im_ADC.(data_b[],address_b[], clock_b)= (DataBus_In[],Im_RAMAddrBus[7..0], Bus_clock);
	Im_ADC.(data_b[],address_b[], clock_b)= (DataBus_In[],AddrBus_In[7..0], Bus_clock);
	Im_ADC.wren_b = DataBusStrobe and  DirectIn AND Select AND Ram_SeL[0];
	
	Im_ADCCt.clock   = ADC_Clock;
	Im_ADCCt.sclr = !Working;
--	Im_ADCCt.clk_en  = VCC;
--	Im_ADCCt.cnt_en = GN;
--	Im_RAMAddrBus[7..0] = AddrBus_In[7..0] + Im_ADCCt.q[7..0]; -- aunoaaeaiea aa?ana a 0 aey oaeouaai iaai?a FOR-ia
%

--******** 6a. SET-UP of the external ADCs ************************************
ADC_Reset		= PwrUpReset;

--Strobe: makes ADCfeed_AddrCt to load InitAddr, and makes ADCfeed_WordCt to load N_of_Words
ADCfeed_Init	= DevSel[8] &(AddrBus[2..0]==2)  --\_AddrBus[] == 2050, ..
				  AND (DataStrobe & RW) ;        --/ ..and "write" is conducted

--Counter: latches the InitAddr and then counts the Addr of the selected portion of data
ADCfeed_AddrCt.data[]	= DataBus[7..0];        -- 8-bit InitAddr is asserted at 8..1 bits 
ADCfeed_AddrCt.(clock, clk_en)	= (Clk100, VCC);
ADCfeed_AddrCt.cnt_en	= EdgeSensing(.D=ADCfeed_NxtB, .clk=Clk100);
ADCfeed_AddrCt.sload	= ADCfeed_Init;         -- loads InitAddr before the Beg_of_Cycle
ADCfeed_AddrCt.sclr		= PwrUpSet1 OR RESET ;  -- at Power-Up self-setting the InitAddr=#0

ADCfeed_Beg1= SRFF(.S=((ADCfeed_Init            --\_When an InitAddr has been written, ..
					OR PwrUpSet1)              --/ .. OR by PwrUpSet1
					 AND !ADCfeed_Cycle1 ),     -- .S=1 until the Cycle has really started
				.R=ADCfeed_Cycle1,              -- reset when the Cycle has really started
				.clk=Clk100, .clrn=!RESET );

ADCfeed_Beg2= DFF(.D=(ADCfeed_Beg1 & !ADCfeed_Cycle1),  --\_    _/^^^^\_ 1*Clk12_5,
				  .clk=!Clk12_5);                         --/ flips by \_ of Clk12_5

ADCfeed_Cycle1 = SRFF(.S=ADCfeed_Beg2, .R=ADCfeed_End, .clrn=!RESET,
					  .clk=Clk12_5 );   -- flips in advance by 1/2 * Clk12_5
ADCfeed_Cycle2 =  DFF(.D=ADCfeed_Cycle1, .clk=!Clk12_5);  -- 

ADCfeed_WordEnd = DFF(.D=(ADCfeed_BitCt.eq0 & !ADCfeed_WordCt.eq0), .clk=!Clk12_5);
ADCfeed_End		= DFF(.D=(ADCfeed_BitCt.eq0 &  ADCfeed_WordCt.eq1), .clk=!Clk12_5);

--Counter counts the bits of each Word being fed ( [from 25 down to 0] = 24bits + 2-clock pause )
ADCfeed_BitCt.sset = (ADCfeed_Beg2 #                       --\_loads #25 before Cycle
--                      (ADCfeed_WordEnd & !ADCfeed_End) );   --/ loads #25 for each [24bits+pause]
					  ADCfeed_WordEnd );                    --/ loads #25 for each [24bits+pause]
ADCfeed_BitCt.cnt_en= (ADCfeed_Cycle2  & !ADCfeed_WordEnd);
ADCfeed_BitCt.(clock, clk_en) = (Clk12_5, VCC);

--Strobe makes the ADCfeed_Reg to load the next DWord, and =then= makes the ADCfeed_AddrCt to increment
ADCfeed_NxtB    =  ADCfeed_BitCt.eq0            --\  1st 8-bit DWord \
                  #(ADCfeed_BitCt.q[]==18)      -- > 2nd 8-bit DWord  >  to be fed 
                  # ADCfeed_BitCt.eq10 ;        --/  3rd 8-bit DWord /  to the ADCs
ADCfeed_NextB   = DFF(.D=ADCfeed_NxtB, .clk=!Clk12_5);  -- strobe, registered

--Counter counts the number of Word being written (from N down to 1)
ADCfeed_WordCt.data[]  = DataBus[11..8];-- N_of_Words is asserted at 12..9 bits 
ADCfeed_WordCt.(clock, clk_en) = (Clk100, VCC); 
ADCfeed_WordCt.cnt_en  = EdgeSensing(.D=    --increments =after= all actions related to current Word
						( ADCfeed_WordEnd & !DFF(.D=ADCfeed_WordEnd, .clk=Clk12_5) ),
						.clk=Clk100); 
ADCfeed_WordCt.sset = PwrUpSet1 ;           -- loads N_of_words at Power-Up self-setting
ADCfeed_WordCt.sload= ADCfeed_Init;     -- loads N_of_words at normal operation

--Reg: latches a 8-bit Data from SetupRAM and outputs the bits serially
ADCfeed_Reg.data[] = SetupRAM.q_a[] ;
ADCfeed_Reg.load= ADCfeed_Beg2 OR ADCfeed_NextB; --initial and regular "load" of ADCfeed_Reg
ADCfeed_Reg.(clock,enable) = (Clk12_5, VCC);

ADCfeed_En = ADCfeed_Cycle2 AND !DFF(.D=(ADCfeed_BitCt.eq1 # ADCfeed_BitCt.eq0), .clk=!Clk12_5);

--Signals which handle the ADC via serial interface :
ADC_SEN[2..0] = !ADCfeed_En ;                   -- active LOW  ^^^^^\______________
ADC_SCLK      = Clk12_5 AND ADCfeed_En ;        --             ________/^^\__/^^\__
ADC_SDATA[0]  = DFF(.D=ADCfeed_Reg.shiftout, .clk=!Clk12_5, .clrn=ADCfeed_Cycle1);

--Registers: load serial data (from ADC' SDOUT) and convert it into a 8-bit DWord :
--For i in 1 to 3  GENERATE
--    ADCdata_Reg[i].shiftin = ADC_SDOUT[i-1] ;
--    ADCdata_Reg[i].(clk,enable,load) = (Clk12_5, ADCfeed_Cycle2, GND);
--End GENERATE;

--============================================================================
ADC_DataClk_Gl[0] = GLOBAL(ADC_DataClk[0]);
ADC_DataClk_Gl[1] = GLOBAL(ADC_DataClk[1]);
ADC_DataClk_Gl[2] = GLOBAL(ADC_DataClk[2]);

ADC_DataClk_D = DFF(.d = ADC_DataClk[0], .clk = (ADC_DataClk_Gl[0] XOR ADC_DataClk_D)); --lcell(ADC_DataClk[0]);

FOR i IN 0 TO 1 GENERATE
	FOR j in 0 to 1 GENERATE

		DDR_InLVDS[i][j].(datain, inclock%, aclr%) = (ADC_In_Data[i][j], ADC_DataClk_Gl[0]%, RESET%);
		DDR_Reg_pos[i][j].(shiftin, clock, enable, load) = (DDR_InLVDS[i][j].dataout_h, ADC_DataClk_Gl[0], VCC, GND);
		DDR_Reg_neg[i][j].(shiftin, clock, enable, load) = (DDR_InLVDS[i][j].dataout_l, !ADC_DataClk_Gl[0], VCC, GND);

	END GENERATE;
END GENERATE;

FOR i IN 2 TO 3 GENERATE
	FOR j in 0 to 1 GENERATE

		DDR_InLVDS[i][j].(datain, inclock%, aclr%) = (ADC_In_Data[i][j], ADC_DataClk_Gl[0]%, RESET%);
		DDR_Reg_pos[i][j].(shiftin, clock, enable, load) = (DDR_InLVDS[i][j].dataout_h, ADC_DataClk_Gl[0], VCC, GND);
		DDR_Reg_neg[i][j].(shiftin, clock, enable, load) = (DDR_InLVDS[i][j].dataout_l, !ADC_DataClk_Gl[0], VCC, GND);

	END GENERATE;
END GENERATE;

-- Защелкивание битов в определенной последовательности.
	InData_RegMix[0].data[11..0] = (DDR_Reg_neg[0][1].q[2],DDR_Reg_pos[0][1].q[2],DDR_Reg_neg[0][1].q[1],DDR_Reg_pos[0][1].q[1],DDR_Reg_neg[0][1].q[0],DDR_Reg_pos[0][1].q[0],
									DDR_Reg_neg[0][0].q[2],DDR_Reg_pos[0][0].q[2],DDR_Reg_neg[0][0].q[1],DDR_Reg_pos[0][0].q[1],DDR_Reg_neg[0][0].q[0],DDR_Reg_pos[0][0].q[0]);
	InData_RegMix[1].data[11..0] = (DDR_Reg_neg[1][1].q[2],DDR_Reg_pos[1][1].q[2],DDR_Reg_neg[1][1].q[1],DDR_Reg_pos[1][1].q[1],DDR_Reg_neg[1][1].q[0],DDR_Reg_pos[1][1].q[0],
									DDR_Reg_neg[1][0].q[2],DDR_Reg_pos[1][0].q[2],DDR_Reg_neg[1][0].q[1],DDR_Reg_pos[1][0].q[1],DDR_Reg_neg[1][0].q[0],DDR_Reg_pos[1][0].q[0]);
	InData_RegMix[2].data[11..0] = (DDR_Reg_neg[2][1].q[2],DDR_Reg_pos[2][1].q[2],DDR_Reg_neg[2][1].q[1],DDR_Reg_pos[2][1].q[1],DDR_Reg_neg[2][1].q[0],DDR_Reg_pos[2][1].q[0],
									DDR_Reg_neg[2][0].q[2],DDR_Reg_pos[2][0].q[2],DDR_Reg_neg[2][0].q[1],DDR_Reg_pos[2][0].q[1],DDR_Reg_neg[2][0].q[0],DDR_Reg_pos[2][0].q[0]);
	InData_RegMix[3].data[11..0] = (DDR_Reg_neg[3][1].q[2],DDR_Reg_pos[3][1].q[2],DDR_Reg_neg[3][1].q[1],DDR_Reg_pos[3][1].q[1],DDR_Reg_neg[3][1].q[0],DDR_Reg_pos[3][1].q[0],
									DDR_Reg_neg[3][0].q[2],DDR_Reg_pos[3][0].q[2],DDR_Reg_neg[3][0].q[1],DDR_Reg_pos[3][0].q[1],DDR_Reg_neg[3][0].q[0],DDR_Reg_pos[3][0].q[0]);
-- Защелкивание битов в определенной последовательности.
	InData_Reg[0].data[11..0] = (InData_RegMix[0].q[7],InData_RegMix[0].q[6],InData_RegMix[0].q[9],InData_RegMix[0].q[8],InData_RegMix[0].q[11],InData_RegMix[0].q[10],
								 InData_RegMix[0].q[0],InData_RegMix[0].q[3],InData_RegMix[0].q[2],InData_RegMix[0].q[5],InData_RegMix[0].q[4],InData_RegMix[0].q[1]);
	InData_Reg[1].data[11..0] = (InData_RegMix[1].q[6],InData_RegMix[1].q[9],InData_RegMix[1].q[8],InData_RegMix[1].q[11],InData_RegMix[1].q[10],InData_RegMix[1].q[7],
								 InData_RegMix[1].q[0],InData_RegMix[1].q[3],InData_RegMix[1].q[2],InData_RegMix[1].q[5],InData_RegMix[1].q[4],InData_RegMix[1].q[1]);
	InData_Reg[2].data[11..0] = (InData_RegMix[2].q[7],InData_RegMix[2].q[6],InData_RegMix[2].q[9],InData_RegMix[2].q[8],InData_RegMix[2].q[11],InData_RegMix[2].q[10],
								 InData_RegMix[2].q[0],InData_RegMix[2].q[3],InData_RegMix[2].q[2],InData_RegMix[2].q[5],InData_RegMix[2].q[4],InData_RegMix[2].q[1]);
	InData_Reg[3].data[11..0] = (InData_RegMix[3].q[6],InData_RegMix[3].q[9],InData_RegMix[3].q[8],InData_RegMix[3].q[11],InData_RegMix[3].q[10],InData_RegMix[3].q[7],
								 InData_RegMix[3].q[0],InData_RegMix[3].q[3],InData_RegMix[3].q[2],InData_RegMix[3].q[5],InData_RegMix[3].q[4],InData_RegMix[3].q[1]);

FOR i IN 0 TO (NUM_CH-1) GENERATE

	InData_RegMix[i].(clock, enable, load) = (!ADC_FrameClk[0], VCC, VCC);
	InData_Reg[i].(clock, enable, load) = (Clk100, VCC, VCC);

	TA12Channel[i].Bus_Clock		= Clk100; -- Clock 100MHz
	TA12Channel[i].ADC_Clock		= Clk100; -- Clock 100MHz
	TA12Channel[i].Flink_clock		= Clk25;

	TA12Channel[i].DigitInit		= StartADC_Link;--PwrUpSet1;-- initiates Cycle: Digitizing and store the results in ADC_RAM
	TA12Channel[i].RegInit			= PwrUpSet1;
	TA12Channel[i].Reset			= RESET; -- reset by MainRESET

	TA12Channel[i].ADCdata[]		 = InData_Reg[i].q[];--(GND,GND,GND,GND,GND,WriteWFCt.q);--
	TA12Channel[i].DataBus_In[15..0] = DataBus[15..0];
	TA12Channel[i].AddrBus_In[9..0]  = AddrBus[9..0] ;

	TA12Channel[i].DataBusStrobe	= DataStrobe ;
	TA12Channel[i].DirectIn			= RW;
	TA12Channel[i].Select			= DevSel[11+i].q ;
	TA12Channel[i].LinkMessage		= Link_IFace.LinkMessage;-- OR Test_in[0];--St_ADC_Link;--
	TA12Channel[i].WriteRAM			= VCC;--SelCommdList_Trig.q;--SelCommdList_Count.q;

END GENERATE;
--Working,        -- connected in "Control Unit" section
--Error,          -- connected in "Control Unit" section

--******** 6a. Ethernet WF_HIST Tx to DAQ *************************************

Eth_Reg_LinkOpCode.data[(CommandSize+Pause-1)..0]= Link_IFace.OpCode_out[(CommandSize+Pause-1)..0];
Eth_Reg_LinkOpCode.(clock, enable, load)= (Clk100, Link_IFace.RxOpCode_ld, VCC); -- catch data when RxOpCodeReload=1 
Eth_Reg_LinkOpCode.(aclr, sclr)			= (RESET OR !Link_IFace.LinkMessage, GND);

Eth_Reg_LinkEvNumber.data[] = Link_IFace.InData_out[];
Eth_Reg_LinkEvNumber.(clock, enable, load)= (Clk100, Link_IFace.RxInData_ld, VCC); -- catch data when RxOpCodeReload=1 
Eth_Reg_LinkEvNumber.(aclr, sclr)		  = (RESET OR !Link_IFace.LinkMessage, GND);

CASE Eth_Reg_LinkOpCode.q[7..0] is -- recognizing the particular Operation :
	WHEN StartRegul		 =>     -- #193-"START_Regular"        (+?oyoo Lst0)
		 StartWFTx_Eth	 = VCC;	--Start up Ethernet transmition with waveforms
	WHEN Others => 	
		 StartWFTx_Eth	 = GND;	--Start up Ethernet transmition without waveforms
End CASE;

For i in 0 to 11 generate
	Im_Ram[i].data[] = GND;
	Im_Ram[i].(clock) = (Clk100);

	Im_RamCt[i].clock = Clk100;
	Im_RamCt[i].clk_en  = VCC;
End generate;

--Compres.(trigger, CLOCK_100) = (Test_in%Link_IFace.LinkMessage%, Clk100); -- Iiniio?aou eeie aiaoiae iaiyoe ii aieoiaioo!!!

WriteWFCt.(clock,cnt_en,clk_en,sclr) = (Clk100, (!WriteWFEnd AND StartWFTx_Eth), VCC, !StartWFTx_Eth); -- sets to #00 in the Beg-g_of_Cycle

--IF (TA12Channel[0].Working OR TA12Channel[1].Working) 
--	Then 
--		IF ((WriteWFCt.q[] >= WriteWFDelayTime) AND (TA12Channel[0].WriteWFEnd == VCC OR TA12Channel[1].WriteWFEnd == VCC))   -- 
--			Then WriteWFEnd = VCC;     --
--			Else WriteWFEnd = GND;     --
--		END IF;
--	Else 
--		IF (WriteWFCt.q[] >= WriteWFDelayTime)
--			Then WriteWFEnd = VCC;     --
--			Else WriteWFEnd = GND;     --
--		END IF;
--End IF;
IF ((WriteWFCt.q[] == WriteWFDelayTime) %AND (LinkMessage == GND )%)   -- 
	Then WriteWFEnd = VCC;     --
	Else WriteWFEnd = GND;     --
End IF;

--DelayWriteWFEnd.(d,clk) = (WriteWFEnd, Clk100);

EnWriteWFHist.(S, clk, R) = (!WriteWFEnd, Clk100, WriteWFEnd);

FOR i IN 0 TO (NUM_CH-1) GENERATE
	TA12Channel[i].WriteWFhist_Eth = EnWriteWFHist.q;
END GENERATE;

--DelayWriteWFhist_Eth.(D,clk,reset) = (!EnWriteWFHist.q, Clk100, Reset);
Delay_EthMessage.(D,clk) = (!EnWriteWFHist.q%DelayWriteWFhist_Eth.q%, Clk100);
TxWFhist_Eth.(S, clk, R, clrn) = (!EnWriteWFHist.q%DelayWriteWFhist_Eth.q% AND !Delay_EthMessage.q, Clk100, GND, !StopCount_Eth);

DataCount_Eth.(clock, cnt_en, sclr) = (Clk100, TxWFhist_Eth.q, OutData_rdy.q%!EnWriteWFHist.q AND !Delay_EthMessage.q%%!DelayWriteWFhist_Eth.q%);
ChannelCount_Eth.(clock, cnt_en, sclr) = (Clk100, DataCount_Eth.cout AND !StopCount_Eth, OutData_rdy.q%!EnWriteWFHist.q AND !Delay_EthMessage.q% %DelayWriteWFhist_Eth.q%);
IF (ChannelCount_Eth.q[] == b"11" AND DataCount_Eth.q[] == VCC)
	THEN StopCount_Eth = VCC;
	ELSE StopCount_Eth = GND;
END IF;

WriteDATA.(clock, enable, load) = (Clk100, VCC, VCC);
%
CASE ChannelCount_Eth.q[] IS
	When b"00" =>	Im_Ram[0].address[] = DataCount_Eth.q[];--Compres.buffer_ADDR[7..0];
					WriteDATA.data[11..0] = Im_Ram[0].q[11..0];
					Im_RamCt[0].cnt_en = VCC;
					Im_RamCt[0].sclr = GND;
	When b"01" =>	Im_Ram[1].address[] = DataCount_Eth.q[];--Compres.buffer_ADDR[7..0];
					WriteDATA.data[11..0] = Im_Ram[1].q[11..0];
					Im_RamCt[1].cnt_en = VCC;
					Im_RamCt[1].sclr = GND;
	When b"10" =>	Im_Ram[2].address[] = DataCount_Eth.q[];--Compres.buffer_ADDR[7..0];
					WriteDATA.data[11..0] = Im_Ram[2].q[11..0];
					Im_RamCt[2].cnt_en = VCC;
					Im_RamCt[2].sclr = GND;
	When b"11" =>	Im_Ram[3].address[] = DataCount_Eth.q[];--Compres.buffer_ADDR[7..0];
					WriteDATA.data[11..0] = Im_Ram[3].q[11..0];
					Im_RamCt[3].cnt_en = VCC;
					Im_RamCt[3].sclr = GND;
	When others =>	Im_RamCt[0].cnt_en = GND;
					Im_RamCt[0].sclr = VCC;
					Im_RamCt[1].cnt_en = GND;
					Im_RamCt[1].sclr = VCC;
					Im_RamCt[2].cnt_en = GND;
					Im_RamCt[2].sclr = VCC;
					Im_RamCt[3].cnt_en = GND;
					Im_RamCt[3].sclr = VCC;
END Case;
%
CASE ChannelCount_Eth.q[] IS 
	When b"00" => -- Channel 1
					CASE DataCount_Eth.q[] is
						When 0 => WriteDATA.data[15..0] = (ChannelCount_Eth.q[],b"000000",Eth_Reg_LinkOpCode.q[7..0]);
						When 1 => WriteDATA.data[15..0] = Eth_Reg_LinkEvNumber.q[];
						When others => WriteDATA.data[11..0] = TA12Channel[0].DAQDataBusOut_Eth[11..0];
									   WriteDATA.data[15..12] = GND;
					End case;
					TA12Channel[0].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[0].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[0].ReadWFhist_Eth			= TxWFhist_Eth.q;
	When b"01" => -- Channel 2
					CASE DataCount_Eth.q[] is
						When 0 => WriteDATA.data[15..0] = (ChannelCount_Eth.q[],b"000000",Eth_Reg_LinkOpCode.q[7..0]);
						When 1 => WriteDATA.data[15..0] = Eth_Reg_LinkEvNumber.q[];
						When others => WriteDATA.data[11..0] = TA12Channel[1].DAQDataBusOut_Eth[11..0];
									   WriteDATA.data[15..12] = GND;
					End case;
					TA12Channel[1].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[1].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[1].ReadWFhist_Eth			= TxWFhist_Eth.q;
	When b"10" => -- Channel 3
					CASE DataCount_Eth.q[] is
						When 0 => WriteDATA.data[15..0] = (ChannelCount_Eth.q[],b"000000",Eth_Reg_LinkOpCode.q[7..0]);
						When 1 => WriteDATA.data[15..0] = Eth_Reg_LinkEvNumber.q[];
						When others => WriteDATA.data[11..0] = TA12Channel[2].DAQDataBusOut_Eth[11..0];
									   WriteDATA.data[15..12] = GND;
					End case;
					TA12Channel[2].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[2].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[2].ReadWFhist_Eth			= TxWFhist_Eth.q;
	When b"11" => -- Channel 4
					CASE DataCount_Eth.q[] is
						When 0 => WriteDATA.data[15..0] = (ChannelCount_Eth.q[],b"000000",Eth_Reg_LinkOpCode.q[7..0]);
						When 1 => WriteDATA.data[15..0] = Eth_Reg_LinkEvNumber.q[];
						When others => WriteDATA.data[11..0] = TA12Channel[3].DAQDataBusOut_Eth[11..0];
									   WriteDATA.data[15..12] = GND;
					End case;
					TA12Channel[3].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[3].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[3].ReadWFhist_Eth			= TxWFhist_Eth.q;
--	When b"0100" => TA12Channel[4].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[4].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[4].ReadWFhist_Eth			= TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[4].DAQDataBusOut_Eth[11..0];
--	When b"0101" => TA12Channel[5].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[5].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[5].ReadWFhist_Eth			= TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[5].DAQDataBusOut_Eth[11..0];
--	When b"0110" => TA12Channel[6].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[6].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[6].ReadWFhist_Eth		  = TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[6].DAQDataBusOut_Eth[11..0];
--	When b"0111" => TA12Channel[7].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[7].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[7].ReadWFhist_Eth		  = TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[7].DAQDataBusOut_Eth[11..0];
--	When b"1000" => TA12Channel[8].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[8].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[8].ReadWFhist_Eth		  = TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[8].DAQDataBusOut_Eth[11..0];
--	When b"1001" => TA12Channel[9].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[9].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[9].ReadWFhist_Eth		  = TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[9].DAQDataBusOut_Eth[11..0];
--	When b"1010" => TA12Channel[10].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[10].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[10].ReadWFhist_Eth		  = TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[10].DAQDataBusOut_Eth[11..0];
--	When b"1011" => TA12Channel[11].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
--					TA12Channel[11].DAQAddrBus_Eth_In[8] = GND;
--					TA12Channel[11].ReadWFhist_Eth		  = TxWFhist_Eth.q;
--					TAWF_HistRAM.data_a[11..0] = TA12Channel[11].DAQDataBusOut_Eth[11..0];
	When others =>
					FOR i IN 0 TO (NUM_CH-1) GENERATE 
						TA12Channel[i].ReadWFhist_Eth = GND; 
						TA12Channel[i].DAQAddrBus_Eth_In[8..0] = GND;
					end generate; 
END Case;

DelayWorkTime[1..0].(clk) = Clk100;
DelayWorkTime0.d = TxWFhist_Eth.q;
DelayWorkTime1.d = DelayWorkTime0.q;

OutData_rdy.(d,clk) = ((DelayWorkTime1.q AND !DelayWorkTime0.q), Clk100);

--Addr_Ram.clock = Clk100;
--Addr_Ram.(wren, wraddress[], data[15..0]) = ((DelayWorkTime0.q AND TxWFhist_Eth.q), WrAddrCnt.q[], Write_ExtRamCt.q[15..0]);
--Addr_Ram.(rden, rdaddress[]) = ((Read_time.q AND !ReadExtMem), ReadAddrCnt.q[]);
--
--WrAddrCnt.(clock, clk_en, cnt_en) = (Clk100, VCC, (DelayWorkTime0.q AND !TxWFhist_Eth.q));
--ReadAddrCnt.(clock, clk_en, cnt_en) = (Clk100, VCC, (Read_time.q AND ReadExtMem));

Write_ExtRamCt.(clock, clk_en, cnt_en, aclr) = (Clk100, VCC, TxWFhist_Eth.q OR DelayWorkTime0.q, PwrUpSet2 # Reset);

WrRdExtRAMAddr.(clock, enable, load) = (Clk100, VCC, VCC);

If	(TxWFhist_Eth.q OR DelayWorkTime0.q) == VCC Then 
	WrRdExtRAMAddr.data[15..0]	= Write_ExtRamCt.q[15..0];
	ExtRAM_OutEn				= GND;
	ExtRAM_CEn					= GND;
	ExtRAM_WriteEn				= GND;
	ExtRAM_LowerByteControl		= GND;--Clk50;--
	ExtRAM_UpByteControl		= GND;--Clk50;--
Elsif ((Read_time.q == VCC) and (EtherLinkMessage.q == GND)) Then 
	WrRdExtRAMAddr.data[15..0]	= EnRead_ExtRamCt.q[];
	ExtRAM_OutEn				= GND;
	ExtRAM_CEn					= GND;
	ExtRAM_WriteEn				= VCC;
	ExtRAM_LowerByteControl		= GND;--Clk50;--
	ExtRAM_UpByteControl		= GND;--Clk50;--
							Else
	ExtRAM_OutEn				= VCC;
	ExtRAM_CEn					= VCC;
	ExtRAM_WriteEn				= VCC;
	ExtRAM_LowerByteControl		= VCC;
	ExtRAM_UpByteControl		= VCC;
	WriteDATA.aclr				= VCC;
	WrRdExtRAMAddr.aclr			= VCC;
End IF;

	ExtRAM_Addr[] = WrRdExtRAMAddr.q[];
For i in 0 to 15 generate
	ExtRAM_Data[i] = TRI (WriteDATA.q[i],TxWFhist_Eth.q);
End generate;

ReadCnt.(clock, clk_en, cnt_en) = (Clk100, VCC, (DelayReadTime0.q and !Read_time.q));

Read_time.(S, clk, R) = (Tx_Rq_StReg.q, Clk100, !ReadExtMem); -- чтение внешней памяти по команде готовности передачи в изернет
--ReadExtMem_Rq.(S, clk, R) = (Tx_Rq_StReg.q, Clk100, !ReadExtMem); -- ?oaiea aiaoiae iaiyoe ii eiiaiaa aioiaiinoe ia?aaa?e a eca?iao
--Read_time.(S, clk, R) = ((ReadExtMem_Rq.q AND !(TxWFhist_Eth.q OR DelayWorkTime0.q)), Clk100, !ReadExtMem); -- ?oaiea aiaoiae iaiyoe ii eiiaiaa aioiaiinoe ia?aaa?e a eca?iao

DelayReadTime[1..0].(clk) = Clk100;
DelayReadTime0.d = Read_time.q;
DelayReadTime1.d = DelayReadTime0.q;

Read_ExtRamCt.clock = Clk100;
Read_ExtRamCt.clk_en  = VCC;
Read_ExtRamCt.cnt_en = DelayReadTime0.q AND ReadExtMem;
Read_ExtRamCt.sclr = DelayReadTime1.q AND !DelayReadTime0.q;
Read_ExtRamCt.aclr = PwrUpSet2 # Reset;

IF ((Read_ExtRamCt.q[] == VCC)) Then --StopRead_ExtRam = VCC;
									 ReadExtMem = GND;
								Else --StopRead_ExtRam = GND;
									 ReadExtMem = VCC;
END IF;

WrRdAddr_Reg.(data[], clock, enable, load, aclr) = (Write_ExtRamCt.q, Clk100, (DelayWorkTime1.q AND !DelayWorkTime0.q), VCC, PwrUpSet2 # Reset);

EnRead_ExtRamCt.clock = Clk100;
EnRead_ExtRamCt.clk_en  = VCC;
EnRead_ExtRamCt.cnt_en = Read_time.q AND !StopRead_ExtRam AND ReadExtMem;
EnRead_ExtRamCt.aclr  = PwrUpSet2 # Reset;

IF ((EnRead_ExtRamCt.q[] == WrRdAddr_Reg.q[15..0])) Then StopRead_ExtRam = VCC;
														 --ReadExtMem = GND;
													Else StopRead_ExtRam = GND;
														 --ReadExtMem = VCC;
END IF;

--OutData_rdy.(d,clk) = (!StopRead_ExtRam AND !ReadExtMem AND (DelayReadTime1.q AND !DelayReadTime0.q), Clk100);

Write_IntRamCt.clock = Clk100;
Write_IntRamCt.clk_en  = VCC;
Write_IntRamCt.sload = Tx_Rq_StReg.q;--OutData_rdy.q OR !ReadExtMem%!TxWFhist_Eth.q AND DelayWorkTime0.q%;
Write_IntRamCt.data = EtherRam_DataAddr;
Write_IntRamCt.cnt_en = DelayReadTime1.q AND !Write_IntRamCt.cout;
--Write_IntRamCt.sclr = !Read_time.q;


--============================================================================
--******** 7. Fast LINK's Interface *******************************************

FLink_Reg_LinkOpCode.data[(CommandSize+Pause-1)..0]= Link_IFace.OpCode_out[(CommandSize+Pause-1)..0];
FLink_Reg_LinkOpCode.(clock, enable, load)= (Clk100, Link_IFace.RxOpCode_ld, VCC); -- catch data when RxOpCodeReload=1 
FLink_Reg_LinkOpCode.(aclr, sclr)			= (StopCount, GND);

CASE FLink_Reg_LinkOpCode.q[7..0] is -- recognizing the particular Operation :
	WHEN StartRegul		 =>     -- #193-"START_Regular"        (+?oyoo Lst0)
		 StartWFTx	 = VCC;	--Start up Ethernet transmition with waveforms
	WHEN Others => 	
		 StartWFTx	 = GND;	--Start up Ethernet transmition with waveforms
End CASE;

--Clk37_5 = DFF (.d = !Clk37_5, .clk = Clk75);
SerClk = Clk25;--Clk50;--Clk37_5;--
DelayWriteWFhist.(D,clk,reset) = (StartWFTx, Clk100, Reset);
Delay_LinkMessage.(D,clk) = (DelayWriteWFhist.q, Clk100);
TxWFhist.(S, clk, R, clrn) = (DelayWriteWFhist.q AND !Delay_LinkMessage.q, Clk100, GND, !StopCount);
TAWF_DataStrobe = TxWFhist.q;

FOR i IN 0 TO (NUM_CH-1) GENERATE
	TA12Channel[i].WriteWFhist = !TxWFhist.q;--TestLinkCt.q[11];--Link_IFace.LinkMessage;
END GENERATE;

--DataCount.(clock, cnt_en, sclr) = (Clk25, Link_IFace.LinkMessage, !Link_IFace.LinkMessage);
--ChannelCount.(clock, cnt_en, sclr) = (Clk25, DataCount.cout, !Link_IFace.LinkMessage);
DataCount.(clock, cnt_en, sclr) = (Clk25, TxWFhist.q, StopCount);
ChannelCount.(clock, cnt_en, sclr) = (Clk25, DataCount.cout, StopCount);
IF (ChannelCount.q[] == b"0101" AND DataCount.q[] == VCC )
	THEN StopCount = VCC;
	ELSE StopCount = GND;
END IF;

NWordCount.(clock, cnt_en) = (Clk25, VCC);
FLink_Data_BUS.data[11..10] = NWordCount.q[];
FLink_Data_BUS.clock = Clk25;
SerDataOut[13..10] = b"1010";
IF (TxWFhist.q == GND) Then --Link_IFace.LinkMessage == GND Then
	--FLink_Data_BUS.data[5..0]	= (VCC,GND,VCC,GND,VCC,GND);--TA12Channel[5..0].EventFound;	-- Trigger efficiency check
	--FLink_Data_BUS.data[9..6]	= (VCC,GND,VCC,GND);--TA12Channel[4..0].EventFound;
	SerDataOut[9..0] = (VCC,GND,VCC,GND,VCC,GND,VCC,GND,VCC,GND);
	NWordFLink[] = NWordCount.q[];
Else 
--	SerDataOut[9..0] = (ChannelCount.q[1..0],DataCount.q[]);--TestLinkCt.q[9..0];--
--	NWordFLink[] = (GND,ChannelCount.q[2]);
	CASE ChannelCount.q[] IS 
		 When b"0000" => TA12Channel[0].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[0].DAQAddrBus_In[8] = GND;
						TA12Channel[0].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[0].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[0].DAQDataBusOut[11..10];
		 When b"0001" => TA12Channel[1].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[1].DAQAddrBus_In[8] = GND;
						TA12Channel[1].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[1].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[1].DAQDataBusOut[11..10];
		 When b"0010" => TA12Channel[2].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[2].DAQAddrBus_In[8] = GND;
						TA12Channel[2].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[2].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[2].DAQDataBusOut[11..10];
		 When b"0011" => TA12Channel[3].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[3].DAQAddrBus_In[8] = GND;
						TA12Channel[3].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[3].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[3].DAQDataBusOut[11..10];
--		 When b"0100" => TA12Channel[4].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[4].DAQAddrBus_In[8] = GND;
--						TA12Channel[4].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[4].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[4].DAQDataBusOut[11..10];
--		 When b"0101" => TA12Channel[5].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[5].DAQAddrBus_In[8] = GND;
--						TA12Channel[5].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[5].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[5].DAQDataBusOut[11..10];
--		 When b"0110" => TA12Channel[6].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[6].DAQAddrBus_In[8] = GND;
--						TA12Channel[6].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[6].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[6].DAQDataBusOut[11..10];
--		 When b"0111" => TA12Channel[7].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[7].DAQAddrBus_In[8] = GND;
--						TA12Channel[7].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[7].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[7].DAQDataBusOut[11..10];
--		 When b"1000" => TA12Channel[8].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[8].DAQAddrBus_In[8] = GND;
--						TA12Channel[8].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[8].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[8].DAQDataBusOut[11..10];
--		 When b"1001" => TA12Channel[9].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[9].DAQAddrBus_In[8] = GND;
--						TA12Channel[9].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[9].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[9].DAQDataBusOut[11..10];
--		 When b"1010" => TA12Channel[10].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[10].DAQAddrBus_In[8] = GND;
--						TA12Channel[10].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[10].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[10].DAQDataBusOut[11..10];
--		 When b"1011" => TA12Channel[11].DAQAddrBus_In[7..0] = DataCount.q[];
--						TA12Channel[11].DAQAddrBus_In[8] = GND;
--						TA12Channel[11].ReadWFhist		  = TxWFhist.q;
--						SerDataOut[9..0] = TA12Channel[11].DAQDataBusOut[9..0];
--						NWordFLink[] = TA12Channel[11].DAQDataBusOut[11..10];
		 WHEN OTHERS => FLink_Error = VCC;
						FOR i IN 0 TO (NUM_CH-1) GENERATE
							TA12Channel[i].ReadWFhist		  = GND;
							TA12Channel[i].DAQAddrBus_In[8..0] = GND;
						end generate;
	END CASE;
END IF;

--FLink_Data_BUS.data[11..0] = (!ADC_In_Data[1][11],ADC_In_Data[1][10..0]);

--SerDataOut[9..0] = FLink_Data_BUS.q[9..0]; --TestLinkCt.q[9..0];--
--FLink_Data_BUS.q[11..10];--

TestLinkCt.(clock, clk_en)	= (Clk25, VCC); -- Test Counter, can be used to drive LED blinking
TestLinkCt.cnt_en			= PowerUp0;
TestLinkCt.aclr				= !PowerUp0;    -- even if NO clock - Reset does occur
----------For tests with Ser/Deser
%
IF (TestLinkCt.q[18] == VCC) 
	THEN SerDataOut[3..0] = VCC;--TestLinkCt.q[7];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[7..4] = VCC;--TestLinkCt.q[8];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[9..8] = GND;--TestLinkCt.q[9];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 NWordFLink[] = GND;--TestLinkCt.q[9];--(VCC,GND);--FLink_Data_BUS.q[11..10];
	ELSE SerDataOut[3..0] = GND;--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[7..4] = TestLinkCt.q[8];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[9..8] = TestLinkCt.q[9];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 NWordFLink[] = TestLinkCt.q[9];--(VCC,GND);--FLink_Data_BUS.q[11..10];
END IF;
%
%
OutData.(tx_in[], tx_inclock) = (FLink_Data_BUS.q[11..0], Clk25);
DataOutLVDS_TA = OutData.tx_out[];
%
--============================================================================
--******** 8. Processor ******************************************************
CPU.Clock   = Clk100;   CPU.Sync    = Synchro25; 
CPU.ProgInit        = StartProc ; 
CPU.BaseAddr[7..0]  = BaseAddr[7..0];
--CPU.Int[4..1]       = 
CPU.int1            = Link_IFace.IORq;
CPU.int4            = TestCt.q[25];

CPU.DataIn[]        = DataBus[];        -- Data Bus - input
--            = CPU.AddrOut[15..0]        -- \ connected in "Internal Bus"
--            = CPU.DataOut[15..0]        -- /                       section

--            = CPU.AccessReq ;           -- connected in "Internal Bus" section
--            = CPU.RdWr;                 -- connected in "Internal Bus" section
CPU.AccessGranted   = AccessGrtd;       -- issued by "BusHandler" upon every "AccessReq"
CPU.DataStrobe      = DataStrobe;       -- issued by "BusHandler"

--            = CPU.Working;      -- connected below, in "Control Unit" section
--            = CPU.Error;        -- connected below, in "Control Unit" section
CPU.Reset   = RESET;            -- reset by MainRESET

-- Direct access to ProgRAM as to a part of common RAM
CPU.(ProgRAM_addr[ 7..0],ProgRAM_data[15..0]) = (AddrBus[7..0], DataBus[]);
CPU.ProgRAM_we  = DataStrobe & DevSel[2] & RW;
--            = CPU.ProgRAM_q[];  -- connected in "Internal Bus" section

--============================================================================
-- RAM blocks, Registers

--************ Main general-purpose Memory ***********************************
MainRAM.(address[7..0], data[],    clock,    wren                     ) =
        (AddrBus[7..0], DataBus[], Clk100,(DataStrobe & DevSel[1] & RW)); 

--ProgRAM belongs to "Processor"unit, and is defined there

--************ CommandList RAM ***********************************************
CommandRAM.(address[9..0], data[], clock,    wren                     ) =
        (AddrBus[9..0], DataBus[], Clk100,(DataStrobe & DevSel[3] & RW)); 

--************ SetupRAM contains data for ADCs setup *************************
SetupRAM.(clock_a)  = Clk100 ;
SetupRAM.(address_a[7..0],       data_a[],        wren_a )= --\ for local access 
		 (ADCfeed_AddrCt.q[7..0],B"00000000",      GND   ); --/ from inside of "SET-UP of.." sub-section
--		 (ADCfeed_AddrCt.q[7..0],ADCdata_reg1.q[],  GND   ); --/ from inside of "SET-UP of.." sub-section
--		= SetupRAM.q_a[];     -- connected in "SET-UP of the external ADCs" sub-section
SetupRAM.(clock_b) = Clk100 ;
SetupRAM.(address_b[7..0],data_b[],      wren_b                      )=--\ for access 
		 (AddrBus[7..0],  DataBus[7..0],(DataStrobe & DevSel[7] & RW));--/ from the MainProject
--		= SetupRAM.q_b[];     -- connected in "Internal Bus of Project .." sub-section

--Ethernet Memory is for use by Ethernet Section ONLY, and is defined there

Reg_BaseAddr.data[7..0] = DataBus[7..0];
Reg_BaseAddr.clock      = Clk100;
Reg_BaseAddr.enable     = ( DevSel[8] & (AddrBus[2..0]==1)  --AddrBus[]== Addr_of_thisReg
                        AND (DataStrobe & RW) );            --.. and "write" is conducted
Reg_BaseAddr.(load, aclr)   = (VCC, RESET);

--============================================================================
--******** 9. Control Unit section *******************************************

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--**************** LINK Cycle proceeding units *******************************

--When there is NO Link_cycle in progress, Link_IFace.OpCode_out[]=00 ;  
--Link_IFace.OpCode_out[] changes from =00 to valid OpCode simultaneously with _/ of LinkMessage
IF (Link_IFace.LinkMessage == VCC)  then -- If VALID command received, 
    CASE  Link_IFace.OpCode_out[(CommandSize+Pause-1)..0] is -- recognizing the particular Operation :
        WHEN  Read   => BaseAd[]        = 50;   --#145-"Read" (=<8words) from Objects 
                        StProc_Link     = VCC;
        WHEN  Write  => BaseAd[]        =126;   --#154-"Write"(=<4words) to Objects
                        StProc_Link     = VCC;
        WHEN  Read62 => BaseAd[]        =158;   --#130-"Read62": Read 62words from Object(s)
                        StProc_Link     = VCC;
        WHEN  Write8 => BaseAd[]        =174;   --#137-"Write8": Write 8 words  to Object(s)
                        StProc_Link     = VCC;

        WHEN  StartRegul     =>     -- #193-"START_Regular"        (Read   Lst0)
                        BaseAd[]        =  2;           --Program: CommdList_Rd000
                        StProc_Link     = VCC;          --Start up the Program
                        St_ADC_Link     = VCC;          --Start up ADC
        WHEN  CommdLst_Wr001 =>     -- #202-"Blocking_Begin"       (Write  Lst1)
                        BaseAd[]        = 72;           --Program: CommdList_Wr001
                        StProc_Link     = VCC;          --Start up the Program

        WHEN  StartAlter     =>     -- #210-"START_Alternative"    (Read   Lst2)
                        BaseAd[]        =  6;           --Program: CommdList_Rd010
                        StProc_Link     = VCC;          --Start up the Program
                        --St_ADC_Link     = VCC;          --Start up ADC
        WHEN  CommdLst_Wr011 =>     -- #217-"Blocking_End"         (Write  Lst3)
                        BaseAd[]        = 78;           --Program: CommdList_Wr011
                        StProc_Link     = VCC;          --Start up the Program

        WHEN  CommdLst_Rd100 =>     -- #226-"Read  by CommdLst100" (Read   Lst4)
                        BaseAd[]        = 10;           --Program: CommdList_Rd100
                        StProc_Link     = VCC;          --Start up the Program
        WHEN  CommdLst_Wr101 =>     -- #233-"Write by CommdLst101" (Write  Lst5)
                        BaseAd[]        = 84;           --Program: CommdList_Wr101
                        StProc_Link     = VCC;          --Start up the Program

        WHEN  CommdLst_Rd110 =>     -- #241-"Read  by CommdLst110" (Read   Lst6)
                        BaseAd[]        = 14;           --Program: CommdList_Rd110;
                        StProc_Link     = VCC;          --Start up the Program
        WHEN  CommdLst_Wr111 =>     -- #250-"Write by CommdLst111" (Write  Lst7)
                        BaseAd[]        = 90;           --Program: CommdList_Wr111
                        StProc_Link     = VCC;          --Start up the Program

        WHEN  Rd_SelCommdLst =>     -- #198-"Read  by CommdLst_selected_by_InData"
                        BaseAd[]        = 72;           --Program: Rd_SelCommdList
                        StProc_Link     = VCC;          --Start up the Program
        WHEN  Wr_SelCommdLst =>     -- #205-"Write by CommdLst_selected_by_InData"
                        BaseAd[]        =153;           --Program: Wr_SelCommdList
                        StProc_Link     = VCC;          --Start up the Program

        WHEN OTHERS            => StProc_Link  = GND;
                                  St_ADC_Link  = GND;
    End CASE;
End IF ;

--**** Start an Action by Link command  (generate a 4-clock pulse)
Start_Link1 = DFF(.D=Link_IFace.LinkMessage, .clk=Clk100);
Start_Link2 = DFF(.D=Start_Link1,            .clk=Clk100);
Start_Link3 = DFF(.D=Start_Link2,            .clk=Clk100);
Start_Link4 = DFF(.D=Start_Link3,            .clk=Clk100);

StartProc_Link  = DFF(.D=(StProc_Link & !Start_Link4), .clk=Clk100);--4*Clk100 _/^^^\_
StartADC_Link   = DFF(.D=(St_ADC_Link & !Start_Link4), .clk=Clk100);--4*Clk100 _/^^^\_


--************ Circuit which handles execution of the Link-Commands ************
--IF "StartRegul", then its [OPCode, InData] is to be be entered into FIFO .. 
--    ..when the OutData is ready for Tranfer from external RAM into EtherRAM (indicated by OutData_rdy) ;
--IF any other Commd, then its [OPCode, InData] is to be entered into FIFO .. 
--    ..when Link_IFace.InData_out[] is asserted (indicated by Link_IFace.RxInData_ld).

--OutData_rdy.(D, clk,reset)=(Link_IFace.LinkMessage, --\_Emulation of "OutData_Rdy" - 
--                 Clk25, (RESET # Reset2));          --/ - for TEST ONLY !

CommdStReg_Ini  = SRFF(.S= StartADC_Link,
--!!!!For the SERIES-SENDING_TEST, comment the statement above and uncomment the statement below ;  
--CommdStReg_Ini  = SRFF(.S=(StartADC_Link AND UDPtstSeries),
                       .R=OutData_rdy.q,
  --For NORMAL operation, remove ".q"^^
                       .clrn=!(RESET # Reset2), .clk=Clk100);
CommdOther_Ini  = SRFF(.S=(StartProc_Link & !StartADC_Link),--set by any Commd except "StartRegul"
                       .R=Link_IFace.RxInData_ld,
                       .clrn=!(RESET # Reset2), .clk=Clk100);
--Select the Strobe, correspondent to the Command; 2*Clk100 pulse, NOT longer!
CommdPut_en =( (CommdStReg_Ini & OutData_rdy.q)            --to put "StartRegul" into FIFO
  --For NORMAL operation, remove ".q"-------^^
            OR (CommdOther_Ini & Link_IFace.RxInData_ld) ) --to put any other Commd into FIFO
           AND (StartOne # StartMulti); --IF allowed (can be commented for specific TEST)

CommdMov_int= SRFF(.S=((Ether_TxUDPcycle # Ether_TxCMDcycle)--IF a (UDP or CMD3)-Tx_cycle is performed, ..
                   AND EtherPauseCt.eq4),           --\_4*Clk100 interval before..
                   .R=CommdMov_en, .clk=Clk100);    --/ ..moving the FIFO
CommdMov_en  = DFF(.D=((CommdMov_int & !Contin1)    --\ shift occurs only when execution ..
                   AND EtherPauseCt.eq2),           -- >..of =this= Commd has been completed, ..
                   .clk=Clk100 ) ;                  --/ .. 1*Clk100 _/^^\_

--IF CommdPut_en and CommdMov_en arrived simultaneously, 
--  then MOVE is accomplished =first=, and PUT must wait until MOVing is done.
CommdPut_wait   = SRFF(.S=( CommdMov_int AND CommdPut_en),
                       .R=CommdMov_en, 
                       .clrn=!(RESET # Reset2), .clk=Clk100);

CommdPut_init   = SRFF(.S=((!CommdMov_int AND CommdPut_en)  --if NO collision with GETting a Commd.
                       OR  (CommdPut_wait AND CommdMov_en)),--if waited until GETting a Commd is done
                       .R=CommdPut_ld, .clk=Clk100);
CommdPut_ld= DFF(.D=(CommdPut_init & !CommdPut_ld), .clk=Clk100);   -- 1*Clk100 _/^^\_

--Strobes for writing the current_Command's attributes 
--    ..into the closest =free= cell of FIFO (pointed to by StackCt) :
Commd_ld1 = DFF(.D=((CommdPut_init & StackCt.eq0)& !CommdPut_ld), .clk=Clk100);
Commd_ld2 = DFF(.D=((CommdPut_init & StackCt.eq1)& !CommdPut_ld), .clk=Clk100);
Commd_ld3 = DFF(.D=((CommdPut_init & StackCt.eq2)& !CommdPut_ld), .clk=Clk100);
Commd_ld4 = DFF(.D=((CommdPut_init & StackCt.eq3)& !CommdPut_ld), .clk=Clk100);

--Stack Counter :  points to the nearest free cell of FIFO
StackCt.(clock, clk_en) = (Clk100, VCC);
StackCt.updown  = CommdPut_init;        -- if a new Commd is entered into Stack => UP
StackCt.cnt_en  = CommdPut_ld OR (CommdMov_en & !StackCt.eq0);
--StackCt.cnt_en  = ((CommdPut_ld & !StackCt.eq3)  --to count above =3 is forbidden!
--                OR (CommdMov_en & !StackCt.eq0));
StackCt.sclr    = RESET # Reset2;

-- FIFO of length=4 : each "cell" consists of 
--  8-bit "reg" for "OpCode", 16-bit "reg" for "InData", + 1 trigger for sending 2 packets per "StartNorm"
FOR i in 1 to 8 GENERATE
    OpCode1_bit[i].D= ( CommdPut_init & Link_IFace.OpCode_out[i-1]) -- get a new Command
                    OR(!CommdPut_init & OpCode2_bit[i] ) ;          -- shift previous Command
    OpCode1_bit[i].ena  = Commd_ld1 # CommdMov_en ;
    OpCode1_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );

    OpCode2_bit[i].D= ( CommdPut_init & Link_IFace.OpCode_out[i-1]) -- get a new Command
                    OR(!CommdPut_init & OpCode3_bit[i] ) ;          -- shift previous Command
    OpCode2_bit[i].ena  = Commd_ld2 # CommdMov_en ;
    OpCode2_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );

    OpCode3_bit[i].D= ( CommdPut_init & Link_IFace.OpCode_out[i-1]) -- get a new Command
                    OR(!CommdPut_init & OpCode4_bit[i] ) ;          -- shift previous Command
    OpCode3_bit[i].ena  = Commd_ld3 # CommdMov_en ;
    OpCode3_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );

    OpCode4_bit[i].D= ( CommdPut_init & Link_IFace.OpCode_out[i-1]);-- get a new Command
    OpCode4_bit[i].ena  = Commd_ld4 # CommdMov_en ;
    OpCode4_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );
End GENERATE;

FOR i in 1 to 16 GENERATE
    InData1_bit[i].D= ( CommdPut_init & Link_IFace.InData_out[i-1]) -- get a new Command
                    OR(!CommdPut_init & InData2_bit[i] ) ;          -- shift Commands sequence 
    InData1_bit[i].ena  = Commd_ld1 # CommdMov_en ;
    InData1_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );

    InData2_bit[i].D= ( CommdPut_init & Link_IFace.InData_out[i-1]) -- get a new Command
                    OR(!CommdPut_init & InData3_bit[i] ) ;          -- shift Commands sequence
    InData2_bit[i].ena  = Commd_ld2 # (CommdMov_en & !Contin1) ;
    InData2_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );

    InData3_bit[i].D= ( CommdPut_init & Link_IFace.InData_out[i-1]) -- get a new Command
                    OR(!CommdPut_init & InData4_bit[i] ) ;          -- shift Commands sequence
    InData3_bit[i].ena  = Commd_ld3 # (CommdMov_en & !Contin1) ;
    InData3_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );

    InData4_bit[i].D= ( CommdPut_init & Link_IFace.InData_out[i-1]);-- get a new Command
    InData4_bit[i].ena  = Commd_ld4 # (CommdMov_en & !Contin1) ;
    InData4_bit[i].(clk, clrn) = (Clk100, !(RESET # Reset2) );
End GENERATE;

--Triggers: =1 => Continue to send Packets, when executing "StartRegular" Command.
    Contin1.D  = ( CommdPut_init & St_ADC_Link)         --Get "=1" @"StartRegular" / "=0" @ Others
               OR(!CommdPut_init & Contin2 ) ;          --Shift the "Contin" sequence
    Contin1.ena= Commd_ld1 OR                           --enables Getting "=1" / "=0"
         DFF(.D=(CommdMov_int AND EtherPauseCt.eq2),--\_enables [Shift "Contin" sequence] / ..
             .clk=Clk100 ) ;                        --/../ [flip to =0 after sending 1st Packet @ "StartReg"]

    Contin2.D  = ( CommdPut_init & St_ADC_Link)         --Get "=1" @"StartRegular" / "=0" @ Others
               OR(!CommdPut_init & Contin3 ) ;          --Shift the "Contin" sequence
    Contin2.ena= Commd_ld2 # CommdMov_en ;              --enables Getting "=1" / "=0"

    Contin3.D  = ( CommdPut_init & St_ADC_Link)         --Get "=1" @"StartRegular" / "=0" @ Others
               OR(!CommdPut_init & Contin4 ) ;          --Shift the "Contin" sequence
    Contin3.ena= Commd_ld2 # CommdMov_en ;              --enables Getting "=1" / "=0"

    Contin4.D  = ( CommdPut_init & St_ADC_Link) ;       --Get "=1" @"StartRegular" / "=0" @ Others
    Contin4.ena= Commd_ld2 # CommdMov_en ;              --enables Getting "=1" / "=0"

    Contin[4..1].(clk, clrn) = (Clk100, !(RESET # Reset2) );

--**** Request for initializing a Tx_cycle correspondent to the Link-Command.. 
--..which is currently asserted at the outputs of FIFO' cell#1 :
EtherTxRq_Link  = DFF(.D=(CommdPut_ld # EthBusyEnd), .clk=Clk100);  -- 1*Clk100 _/^^\_

-- Circuitry for sending 124 DataWords related to 1 event in 2 consecutive LinkCycles (Temporary)
--SelCommdList_Reg.(data[15..8],data[7],data[6..0]) = (B"00001100",SelCommdList_Count.q,B"0000000");
--SelCommdList_Reg.(clock,load,enable) = (Clk100,VCC,VCC);
--SelCommdList_Count.cnt_en = EdgeSensing(.D= !Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);
--SelCommdList_Count.(clock,clk_en) = (Clk100, VCC);

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--****************  ETHERNET Commands proceeding unit  *************************

--****  1. Execution of ARP-reply 
--ARP-Reply Transmission is initiated AUTOMATICALLY ONLY !
Ether_ARPreply  = SRFF(.S=(RxARPDBlck AND       --\_Sets when ARP-request ..
                  (ChkIPDaddr & DadrIP_cmp) ),  --/ ..sent to ThisDevice is received
    .R=(Ether.TxEndFrame # RESET # Reset2),     --the =next= Tx_cycle must be ARP-reply => 
    .clk=Clk100);   -- => Ether_ARPreply can be reset directly by the end of that Tx_cycle.

TxARPrepl_Rq= SRFF(.S=(Ether_ARPreply & Ether.RxEndFrame),
                .R=InitARP, .clk=Clk100);       --flips to =0 when ARP-reply Tx has started

--****  2. Execution of UDP command
--For TEST ONLY !  Transmission of UDP packet is initiated upon receiving a UDP packet
UDPtestDel  = SRFF(.S=(RxUDPDBlck AND           --\_Sets when a UDP packet ..
                                ChkIPDaddr),    --/ ..sent to ThisDevice is received
        .R=(TxUDP_Rq_UDP                        --\_R = 1*Clk25 _/^^\_ after the 7us Delay
            # RESET # Reset2), .clk=Clk25 );    --/ .. OR RESET

UDPtstDelCt.(clock, clk_en) = (TestCt.q7, VCC); -- Fclock=(Fquartz/256) => Tclock = ~10us
UDPtstDelCt.cnt_en  =  UDPtestDel & !UDPtstDelCt.eq0 ; 
UDPtstDelCt.sset    = !UDPtestDel ;             -- counts down from =7 to =0

TxUDP_Rq_UDP    = EdgeSensing(.D=UDPtstDelCt.eq0, .clk=Clk25);

--!!!!For the SERIES-SENDING_TEST ONLY !  
--1st Request for UDP-Tx_cycle is issued upon receiving a UDP packet (see above), ..
--    .. the rest 11 Requests are issued upon Link commands.
UDPtstSeries= SRFF(.S=(RxUDPDBlck AND           --\_Sets when a UDP packet ..
                                ChkIPDaddr),    --/ ..sent to ThisDevice is received
        .R=(UDPtstSerCt.eq0                     --\_Reset after issuing 12th Request 
            # RESET # Reset2), .clk=Clk25 );    --/ .. OR RESET

UDPtstSerCt.(clock, clk_en) = (Clk25, VCC);     -- 
UDPtstSerCt.cnt_en  = (UDPtstSeries & !UDPtstSerCt.eq0) 
            AND EdgeSensing(.D=(Ether_TxUDPcycle # Ether_TxCMDcycle), .clk=Clk25) ; 
UDPtstSerCt.sset    = !UDPtstSeries ;           -- counts down from =12 to =0


--****  3. Execution of CMD3 command
IF CMD3command  Then
--    Ether.TxLenTyp[]= H"CDCC";      -- "PacketLength/Type" value to be transmitted
    CASE  Reg_EthOpCode[8..1]   is  -- recognizing the particular Operation :
        WHEN  H"01" =>  -- "PING" command
            StEthTx_Ether   = VCC;  -- Start up the Transmit
            Ether.TxLength[]=  64;  -- DataBlock length = 64Bytes
--            EthNextAdr[].D  = 128;  -- initial addr of data to be transmitted 

        --WHEN  H"03" =>  -- "StartMulti" for sending Ethernet' frames" 
        --WHEN  H"04" =>  -- "STOP sending Ethernet' frames" 

        WHEN  H"05" =>  -- "Set LinkMask and TimeGap" 
            Eth_WRITE       = VCC;  -- Ethernet' "Write" Command received 
            --St_EthTx_Ether  = GND;  -- NO Transmit 

        WHEN  H"08" =>  -- "Write" data to TestRAM
            Eth_WRITE       = VCC;  -- Ethernet' "Write" Command received 
            --St_EthTx_Ether  = GND;  -- NO Transmit 

        WHEN  H"09" =>  -- "Read" data from TestRAM
            StEthTx_Ether   = VCC;  -- Start up the Transmit
            --Ether.TxLength[]= 255;  -- DataBlock length = 256Bytes
            Ether.TxLength[]=  64;  -- DataBlock length - temporary
--            EthNextAdr[].D  = 128;  -- initial addr of data to be transmitted 

        WHEN OTHERS => StEthTx_Ether    = GND;
            Ether.TxLength[]=   46;  -- DataBlock length = 46Bytes (Frame is 64B, MIN)
    End CASE;
End IF;

--When CMD3-Type "WRITE" command => EtherWRITE=1 => write to EtherRAM enabled 
EtherWRITE  = DFF(.D=Eth_WRITE, .clk=Clk100, .clrn=!(Ether.RxEndFrame # RESET)); 
--EtherWR_we  = EtherWRITE    -- Upon "CMD3"-type "WRITE" command, enables ETHERNET -> TestRAM
--            AND(Eth_AddrSettled & !RdWr & Eth_DataStrobe);-- RdWr=0 => "Read" from ETHERNET

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--****************  ENABLING of Action_Initializing  ***************************

StartOne    = SRFF(.clk=Clk100,                 --<< One-shot Start >>
        .S=( DataBus[0] AND                                 -- by 1st_bit=1
             DevSel[8] & (AddrBus[2..0]==0) AND             --\_AddrBus[]== Addr_of_thisReg
             DataStrobe & RW ),                             --/ ..and "write" is conducted
        .R=(%Digitizer.Working OR%                          -- Reset by actual start, or..
           Ether.TX_EN  OR                                  -- by ETNERNET' TX Cycle 
          (%St_Compuls #% St_Multi) OR                      -- by other Mode of Start 
          (!DataBus[0] AND                                  -- by 1st_bit=0
             DevSel[8] & (AddrBus[2..0]==0) AND             --\_AddrBus[]== Addr_of_thisReg
             DataStrobe & RW) OR                            --/ ..and "write" is conducted
          RESET),                                           -- by RESET command 
        .clrn= !(RESET # PwrUpSet2) );						-- by default =0

St_One  = StartOne & !DFF(.D=StartOne, .clk=Clk100);        -- _/^^\_ for resetting StartMulti

StartMulti  = SRFF(.clk=Clk100,                 --<< Multi-shot Start >>
        .S=( DataBus[1] AND                                 -- by 2nd_bit=1
             DevSel[8] & (AddrBus[2..0]==0) AND             --\_AddrBus[]== Addr_of_thisReg
             DataStrobe & RW ),                             --/ ..and "write" is conducted
        .R=(%Digitizer.Working OR%                          -- NO Reset by actual start 
          (%St_Compuls #% St_One) OR                        -- by other Mode of Start, or.. 
           (!DataBus[1] AND                                 -- by 2nd_bit=0
             DevSel[8] & (AddrBus[2..0]==0) AND             --\_AddrBus[]== Addr_of_thisReg
             DataStrobe & RW) OR                            --/ ..and "write" is conducted
          RESET),                                           -- by RESET command 
        .prn =!(RESET # PwrUpSet2) );           			-- by default =1);
St_Multi= StartMulti & !DFF(.D=StartMulti, .clk=Clk100);    -- _/^^\_ for resetting StartOne

EtherCMD3mode   = DFFE(.D=DataBus[2], .clk=Clk100,          -- 3rd_bit, "CMD3_Mode"
                    .ena= ( DevSel[8] & (AddrBus[2..0]==0)  --\_AddrBus[]== Addr_of_thisReg
                    AND (DataStrobe & RW) ),                --/ ..and "write" is conducted
                    --.prn =!(RESET # PwrUpSet2) );            -- by default =1
                    .clrn=!(RESET # PwrUpSet2) );            -- by default =0
EtherUDPmode    = DFFE(.D=DataBus[3], .clk=Clk100,          -- 4th_bit, "UDP_Mode"
                    .ena= ( DevSel[8] & (AddrBus[2..0]==0)  --\_AddrBus[]== Addr_of_thisReg
                    AND (DataStrobe & RW) ),                --/ ..and "write" is conducted
                    .prn = !(RESET # PwrUpSet2) );          -- by default =1
                    --.clrn= !(RESET # PwrUpSet2) );          -- by default =0

Reset2  = SRFF(.clk=Clk100,                 --<< Partial Reset >>
        .S=( DataBus[10] AND                                -- by 11th_bit=1
             DevSel[8] & (AddrBus[2..0]==0) AND             --\_AddrBus[]== Addr_of_thisReg
             DataStrobe & RW ),                             --/ ..and "write" is conducted
        .R=DFF(.D=RSTdel, .clk=Clk100));                    -- 4*Clk100 _/^^^^\_
RESET   = SRFF(.clk=Clk100,                 --<< FULL RESET >>
        .S=( DataBus[11] AND                                -- by 12th_bit=1
             DevSel[8] & (AddrBus[2..0]==0) AND             --\_AddrBus[]== Addr_of_thisReg
             DataStrobe & RW ),                             --/ ..and "write" is conducted
        .R=DFF(.D=RSTdel, .clk=Clk100));                    -- 4*Clk100 _/^^^^\_
RSTdel  = DFF(.D=DFF(.D=(RESET # Reset2), .clk=Clk100), .clk=Clk100);  -- delay


----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--**************** START of a PROCESSOR operation ******************************

For i in 0 to 7  GENERATE
BaseAddr[i] = DFF(.D=BaseAd[i], .clk=Clk100);
End GENERATE;

StartProc   = StartProc_Link  -- .. or Start by Link, if allowed
    AND !CPU.Working                    -- if Processor is NOT working
    %AND !Digitizer.Working%;           -- if Digitizing is NOT in progress 

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--***************  START of an ETHERNET Tx Cycle  ******************************

--****A PAUSE must be done between a completed Ethernet' Operation and the next Tx cycle !
--"Register" which contains the value of Ethernet' PAUSE (in 10ns units) :
EtherPauseRg[10..1].D   = DataBus[ 9..0];
EtherPauseRg[10..1].ena =( DevSel[8] & (AddrBus[2..0]==6)   -- AddrBus[]== Addr_of_thisReg
                        AND (DataStrobe & RW) );            --.. and "write" is conducted
EtherPauseRg[10..1].clk = Clk100;
EtherPauseRg[10].clrn   = !(RESET);         --\  Default value = 400 = 
EtherPauseRg[ 9..8].prn = !(RESET);         -- \  = B"01 1001 0000", ..
EtherPauseRg[ 7..6].clrn= !(RESET);         --  > .. so that the PAUSE..
EtherPauseRg[ 5].prn    = !(RESET);         -- / ..between Ethernet' oper-s.. 
EtherPauseRg[ 4..1].clrn= !(RESET);         --/  ..is 4.0us

--Counter which counts down the Ethernet' PAUSE (in 10ns units) :
EtherPauseCt.(clock,clk_en) = (Clk100, VCC);
EtherPauseCt.sload  = DFF(.D=(Ether.RxEndFrame # Ether.TxEndFrame), .clk=Clk100);
EtherPauseCt.data[] = EtherPauseRg[].q;     -- loads the value of Pause time
EtherPauseCt.cnt_en = !EtherPauseCt.eq0;    -- after having loaded, counts down
--EtherPauseCt.sclr   = Reset # Reset2;       -- in principle, not needed

EtherBusy   = SRFF(.S=((RxDV & !EtherBusy)      --\_A.S.A.P. after beg-g of Rx cycle, ..
                    OR StartEthTx.q),           --/ ..OR simultaneously with Tx cycle 
    .R=((EtherPauseCt.eq0 &                     --\_after the PAUSE .. 
        !DFF(.D=EtherPauseCt.eq0, .clk=Clk100)) --/ ..after the previous Eth' Operation, ..
        AND !RxDV ),                            --..AND if NO Rx_cycle is in progress
    .clk=Clk100, .clrn=!(RESET # Reset2) );
--                    OR  Ether_ARPreply;         -- OR [ARPreply is in progress]
EthBusyEnd  = !EtherBusy & DFF(.D=EtherBusy, .clk=Clk100);  -- 1*Clk100 _/^^\_

--****Deriving a Request for Start of (UDP or CMD3)-Tx_cycle in reply for a Link Commd : 
--1) Gather all Requests for sending a reply for a Link Command : 
EtherTx_Rq  = EdgeSensing(.D=(                  -- 1*Clk100 _/^^\_
    ( (EtherTxRq_Link &(StartOne # StartMulti)) --Start upon Link Commd, IF allowed, ..
    ) AND !(EtherBusy # Ether_ARPreply)         -- ..AND IF Ethernet is NOT busy
                            ), .clk=Clk100);    --

--2) When a Request is =1, check IF there is any Commd asserted at the FIFO' output :
IF  (EtherTx_Rq & (OpCode1_bit[8..3]==48)) Then --IF OpCode=193, ..
    Tx_Rq_StReg.D = VCC;
ELSIF (EtherTx_Rq & (OpCode1_bit[8]==VCC)) Then --IF there is =any= Command present, ..
    Tx_Rq_Other.D = VCC;
End IF;
(Tx_Rq_StReg, Tx_Rq_Other).clk  = Clk100; 
(Tx_Rq_StReg, Tx_Rq_Other).clrn = !(RESET # Reset2);

--****Start of ARP-reply Tx_cycle (initiated by ARP-request only!): 
--              HIGH-priority, immediately after the PAUSE..
InitARP = SRFF(.S=(EthBusyEnd & TxARPrepl_Rq),  --..after the ARP-request
                .R=Ether.TX_EN, .clk=Clk100, .clrn=!(RESET # Reset2));  

--****Start of UDP Tx_cycle (by Link, or by receiving UDP, or (for Test: by CAMAC)): 
--1) Gather all Requests for sending a LONG =UDP= packet : 
TxUDP_Rq_Long   = EdgeSensing(.D=(      -- 1*Clk100 _/^^\_
    ( Tx_Rq_StReg.q                     -- Start upon Link "StartNormal" Commd, ..
    OR( TxUDP_Rq_UDP &(StartOne # StartMulti) ) --..OR Start upon UDP, IF allowed..
    --OR Delay_EthTxRq_CAMAC.q          -- ..OR =unconditional= Start by CAMAC.. 
    --OR( (TestCt.q[25..4]==H"3FFF0")&(StartOne # StartMulti) ) -- For TEST ONLY !!
    ) AND EtherUDPmode      ), .clk=Clk100);

--In future, The following sub-sub-section is to be uncommented :
----2) Gather all Requests for sending a SHORT =UDP= packet : 
--TxUDP_Rq_Short  = EdgeSensing(.D=(      -- 1*Clk100 _/^^\_
--    ( Tx_Rq_Other.q                     --Start upon Link Commd other than "StartNormal" ..
--    --OR( TxUDP_Rq_UDP &(StartOne # StartMulti) ) --..OR Start upon UDP, IF allowed..
--    ) AND EtherUDPmode      ), .clk=Clk100);

--In future, 2 following sub-sub-sections are to be incorporated into DISPATCHING circuit :
--3) IF TxUDP_Rq has appeared when [EtherBusy=1 OR if ARP-reply is requested], ..
--   ..then TxUDP_Rq must be put on WaitList :
TxUDPwait   = SRFF(.S=(TxUDP_Rq_Long AND (EtherBusy # Ether_ARPreply)), --"put on WaitList"
                .R=InitUDP,                 --flips to =0 when UDP Tx_cycle has started
                .clrn=!(RESET # Reset2), .clk=Clk100);

--Start of UDP long Tx_cycle :  [immediate, IF possible] / [after the end of EtherBusy]
InitUDP =SRFF(.S=(( (TxUDP_Rq_Long & !EtherBusy)--\ Start immediately ..
                OR (EthBusyEnd & TxUDPwait ))   -- >..OR Start after PAUSE,
               AND !Ether_ARPreply ),           --/ ..AND if ARP-reply is NOT requested
                .R=Ether.TX_EN, .clk=Clk100, .clrn=!(RESET # Reset2));  

Ether_TxUDPcycle= SRFF(.S=InitUDP,              --\_flag: UDP packet ..
                       --.R=Ether.TxEndFrame,     --/    .. is being transmitted
                       .R=CommdMov_en,          --/    .. is being transmitted
                       .clk=Clk100, .clrn=!(RESET # Reset2) );

--****Start of CMD3 Tx_cycle  (upon Link Command, or (for Test: by CAMAC)): 
--1) Request for sending a =CMD3= packet in reply for Link Command "StartNormal":
TxCMD_Rq_StReg  = Tx_Rq_StReg.q AND EtherCMD3mode ; -- 1*Clk100 _/^^\_

--2) Request for sending a =CMD3= packet in reply for Link Commd other than "StartNormal": 
TxCMD_Rq_Other  = Tx_Rq_Other.q AND EtherCMD3mode ; -- 1*Clk100 _/^^\_

InitCMD_StReg   = SRFF(.S=TxCMD_Rq_StReg, 
                       .R=Ether.TX_EN,
                       .clk=Clk100, .clrn=!(RESET # Reset2) ) ;

InitCMD_Other   = SRFF(.S=TxCMD_Rq_Other, 
                       .R=Ether.TX_EN,
                       .clk=Clk100, .clrn=!(RESET # Reset2) ) ;

InitCMD = InitCMD_StReg # InitCMD_Other;

Ether_TxCMDcycle= SRFF(.S=InitCMD,              --\_flag: CMD3-packet ..
                       .R=CommdMov_en,          --/    .. is being transmitted
                       .clk=Clk100, .clrn=!(RESET # Reset2) );
              
--When starting the ARP-reply Tx_cycle :
IF  InitARP  Then
    Ether.TxLenTyp[16..1]  = H"0806";   -- Type="ARP", value to be transmitted
    Ether.TxLength[12..1]  = 46;    -- DataBlock length = 46Bytes (Frame is 64B, MIN)
    EthNextAdr[].D  = ARP_InitAddr; -- DataBlock will be read out starting from addr=8
End IF; 

--When starting a UDP Tx_cycle :
IF  InitUDP  Then
    Ether.TxLenTyp[16..1]  = H"0800";   -- Type="IP", value to be transmitted
    --Length of DataBlock = ( (UDP-header+UDP-data)+20B ), and..
    Ether.TxLength[12..1]  = (B"0", IPlength.result[10..0]);--.. Frame=(DataBlock+18B)
    EthNextAdr[].D  = ARP_InitAd_plus07;-- InitAddr for calculating IP-header' CRC
----****For TEST :  send  THE SAME UDP-packet  back to Comp
--    EthNextAdr[].D  = 48;   --(IP-headr + UDP-headr) will be composed from that of received UDP-packet
End IF;

--When starting a CMD3 Tx_cycle :
IF    InitCMD_StReg  Then  -- IF OpCode=193, ..
    Ether.TxLenTyp[16..1]  = H"CDCC";   -- Type="CMD3", value to be transmitted
    --Length of DataBlock = DBlkLengthRg.q[], and ..
    Ether.TxLength[12..1]  = (B"0", DBlkLengthRg[11..1].q); --.. Frame=(DataBlock+18B)
    -- Init.addr=60 => after sending OpCode and InData, the addr will be =62 =>
    EthNextAdr[].D=  60;    -- .. => entire DataBlock (Event' data) will be sent
ELSIF InitCMD_Other  Then -- IF there is any other Command present, ..
    Ether.TxLenTyp[16..1]  = H"CDCC";   -- Type="CMD3", value to be transmitted
    Ether.TxLength[12..1]  = 46;        -- Length of DBlock, Frame=(DBlock+18B)
    -- Init.addr=42 => after sending OpCode and InData, the addr will be =44 =>
    EthNextAdr[].D=  42;    -- .. => starting from addr=44, fixed test data will be sent
End IF;

StartEthTx.D= InitARP # InitUDP # InitCMD;      -- Start pulse for all Tx cycles
        --AND !Ether.TX_EN ) );                   -- if a Transmit is NOT in progress
StartEthTx.(clk,reset)= (Clk100, RESET);        -- PulseShaper, _/^^^\_ 4*Clk100

--When starting any Tx_cycle, initiate setting of the InitAddr :
--  _/^^\_ not longer than 4*Clk100 !
EthAdrInit  = StartEthTx.q; --and several terms OR'ed to EthAdrInit below

--ONLY when starting Tx cycle, one extra strobe for loading InitAddr into EthAdrCt is added :
EthTxAdrIni2= DFF(.D=EthAddrLd2, .clk=Clk100);          --
EthTxAdrInit= DFF(.D=(StartEthTx.q AND                  --\_ 1*Clk100 _/^^\_ pulse, .. 
            (EthAddrLd2 & !EthTxAdrIni2)), .clk=Clk100);--/ .. appears =after= EthAddrLd2

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--***************  PROCEEDING of an ETHERNET IP Tx_Cycle  **********************

--"Register" which contains Length of UDP DataBlock to be transmitted :
DBlkLengthRg[11..1].D   = DataBus[10..0];
DBlkLengthRg[11..1].ena =( DevSel[8] & (AddrBus[2..0]==4)   -- AddrBus[]== Addr_of_thisReg
                        AND (DataStrobe & RW) );            --.. and "write" is conducted
DBlkLengthRg[11..1].clk = Clk100;
--DBlkLengthRg[11..6].clrn= !(RESET);-- # Reset2);    --\  For Mode = "UDP" :
--DBlkLengthRg[ 5..4].prn = !(RESET);-- # Reset2);    -- \  Default value = 26, ..
--DBlkLengthRg[ 3].clrn   = !(RESET);-- # Reset2);    --  > .. so that ..
--DBlkLengthRg[ 2].prn    = !(RESET);-- # Reset2);    -- / ..the total length .. 
--DBlkLengthRg[ 1].clrn   = !(RESET);-- # Reset2);    --/  ..of Frame is 64B (MIN)

--DBlkLengthRg[11..7].clrn= !(RESET);-- # Reset2);    --\  For Mode = "CMD3" :
--DBlkLengthRg[ 6].prn    = !(RESET);-- # Reset2);    -- \  Default value = 46, ..
--DBlkLengthRg[ 5].clrn   = !(RESET);-- # Reset2);    --  > .. so that ..
--DBlkLengthRg[ 4..2].prn = !(RESET);-- # Reset2);    -- / ..the total length .. 
--DBlkLengthRg[ 1].clrn   = !(RESET);-- # Reset2);    --/  ..of Frame is 64B (MIN)

DBlkLengthRg[11].prn	 = !(RESET);-- # Reset2);    --\  For Mode = "CMD3" :
--DBlkLengthRg[11].clrn = !(RESET);-- # Reset2);    -- \  Default value = 46, ..
--DBlkLengthRg[10].prn	 = !(RESET);-- # Reset2);    --  > .. so that ..
DBlkLengthRg[10..1].clrn = !(RESET);-- # Reset2);    -- / ..the total length .. 

--Adder which calculates and holds the Length of IP DataBlock to be transmitted :
IPlength.dataa[10..0]   = DBlkLengthRg[11..1].q;
IPlength.datab[10..0]   =   20;
IPlength.(clock, clken) = (Clk100, InitUDP);    --operates at the beg-g of any UDP Tx_cycle
--        = IPlength.result[10..0];     --used elsewhere

--Counter which counts the Number of UDP-packets transmitted
UDP_PackCt.(clock, clk_en)  = (Clk100, VCC);
UDP_PackCt.cnt_en  = EthTxAdrInit;      --increments =after= a DWord has been stored
UDP_PackCt.sload   = ( DevSel[8] & (AddrBus[2..0]==5)   --\_AddrBus[]== Addr_of_thisCounter
                   AND DataStrobe & RW );               --/ ..and "write" is conducted
UDP_PackCt.data[]  = DataBus[];                         --
UDP_PackCt.sset    = RESET # Reset2 ;                   -- reset to =1
--UDP_PackCt.sclr    = RESET # Reset2 ;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  Circuit which calculates the IP-header' CRC  ***********************
IPinit_cnt = DFF(.D=(Ether_TxUDPcycle AND               --\_In UDP Tx_cycle, 
                   (Ether.TxDestAddr & !IPinitCt.eq0)), -- >enables counting after beg-g of "TxDestAddr",
                .clk=Clk100);                           --/ .. stops at IPinitCt.q[]=0

IPinit1 = DFF(.D=( !IPinit1 AND IPinit_cnt), .clk=Clk100);      --\  Prescaler :
IPinit2 = DFF(.D=((!IPinit2 & IPinit1) # (IPinit2 & !IPinit1)   -- > divider..
              AND IPinit_cnt ), .clk=Clk100 );                  --/  .. by 4

IPinitCt.(clock, clk_en)  = (Clk100, VCC);
IPinitCt.cnt_en = IPinit_cnt & (IPinit1 & IPinit2) ;-- increments each 4th Clk
IPinitCt.sload  = InitUDP;                          --\_ONLY in the beg-g of UDP packet: 
IPinitCt.data[] = 12;                               --/ counts down from =12 to =0

--Handling the EtherRAM address during calculation of the IP-header'CRC :
--             Initially the Address =15,  then :   IPinitCt.q[]  EtherAdrCt.q[]
EthTxAdrIncr= ( IPinitCt.eq11                   --\    11              15
              # IPinitCt.eq10                   -- |   10              16
      --(IPinitCt.eq9 & !(IPinit1 & IPinit2))   -- |   09(see below) 17, 18,19 
              # IPinitCt.eq8                    -- \   08              20
      --      # IPinitCt.eq7   no need to decr  -- /   07              21
              # IPinitCt.eq6                    -- |   06  strobe for loading addr=35
              # IPinitCt.eq5                    -- |   05              35
              # IPinitCt.eq3 )                  -- |   03  strobe for loading addr=32
            AND (!IPinit1 &  IPinit2 )          -- |4*(1*Clk100) pulses by IPinit[2..1]=2
     # (IPinitCt.eq9 & !(IPinit1 & IPinit2));   --/  3*Clk100 pulse by IPinit[2..1]=1,2,3

IF  IPinitCt.eq6   Then         -- 
    EthAdrInit  = VCC;          --\_jump to Addr=35, 
    EthNextAdr[].D  = 35;       --/ .. to add H"4000"
End IF;
IF  IPinitCt.eq3   Then         -- 
    EthAdrInit  = VCC;          --\_(IP-header + UDP-header) will be composed..
    EthNextAdr[].D  = 32;       --/ .. starting from addr=32(=8224)
End IF;

--Strobes for adding DWords to IP-header'CRC :
IPhdCRC_Cen = ( IPinitCt.eq11 # IPinitCt.eq10  --\_4 * (1*Clk100) pulses ..
              # IPinitCt.eq8  # IPinitCt.eq7   --/ .. by IPinit[2..1]=3
              # IPinitCt.eq5  # IPinitCt.eq4   -- 2pulses after Addr is set =35, ..
              # IPinitCt.eq2                 ) -- 1pulse  after Addr is set =32, ..
              AND ( IPinit1 &  IPinit2 ) ;     -- (1*Clk100) pulses by IPinit[2..1]=3
              --OR  3 more terms defined below in "CASE  Ether.TxCount[11..2]" statement
IPhdCRCclken= DFF(.D=IPhdCRC_Cen, .clk=Clk100);

--Adder which accumulates IP-header' CRC :
IPhdCRCadder.(clock, clken) = ( Clk100, IPhdCRCclken ); 
IF  ( Ether_TxUDPcycle & Ether.TxDataBlck 
    & (Ether.TxCount[11..2]==2) )  Then                         --\_adding ..
    IPhdCRCadder.dataa[15.. 0] = (H"000", IPhdCRCcarry.q[3..0]);--/ .. CARRY bits
ELSE
    IPhdCRCadder.dataa[15.. 0] = TxDataBus[15..0];
End IF;
IPhdCRCadder.datab[15.. 0] = IPhdCRCadder.result[15..0]; 
IPhdCRCadder.aclr   = InitUDP;          -- reset to =0 at the very beginning of Tx cycle

--Counter which counts CARRY bits :
IPhdCRCcarry.(clock,clk_en) = (Clk100, VCC);
IPhdCRCcarry.cnt_en = DFF(.D=( IPhdCRCadder.cout &  --\ IPhdCRCadder.cout & 1*Clk pulse..
            DFF(.D=IPhdCRCclken,.clk=Clk100) ),     -- >..delayed by 1*Clk..
                          .clk=Clk100);             --/   ..after IPhdCRCclken
--Test6 = DFF(.D=( IPhdCRCadder.cout &  --\ IPhdCRCadder.cout & 1*Clk pulse..
--            DFF(.D=IPhdCRCclken,.clk=Clk100) ),     -- >..delayed by 1*Clk..
--                          .clk=Clk100);             --/   ..after IPhdCRCclken
--IPhdCRCcarry.cnt_en = Test6;
IPhdCRCcarry.data[] = 0;
IPhdCRCcarry.sclr   = InitUDP;          -- reset to =0 at the very beginning of Tx cycle

--Selector of data sources for composing the UDP-header of transmitted UDP-packet :
--TxDataBus - local bus (formal only) used by Tx_cycle proceeding circuit
IF  (Ether_TxUDPcycle & Ether.TxDataBlck)  Then
    CASE  Ether.TxCount[11..2]  is
      WHEN  0 => TxDataBus[] = (B"00000", IPlength.result[10..0] ); -- IP-Length
                 IPhdCRC_Cen = EthWord_Wr;      -- add IP-Length to IP-header'CRC
      WHEN  1 => TxDataBus[] = UDP_PackCt.q[];  -- Num of UDP-packet
                 --TxDataBus[] = EtherRAM.q_a[];  --For TEST! get =constant= value from addr=34
                 IPhdCRC_Cen = EthWord_Wr;      -- add Num_of_UDP-Packet to IP-header'CRC
      WHEN  2 => TxDataBus[] = EtherRAM.q_a[];  -- normal connection
                 IPhdCRC_Cen = EthWord_Wr;      -- add 4bits of "CARRY" to IP-header'CRC
      WHEN  4 => TxDataBus[] = !IPhdCRCadder.result[];  -- IP-header' CRC, =inverted=
      WHEN  6 => TxDataBus[] = EtherRAM.q_a[];  -- normal connection
        IF ( Ether.TxCount[1..0] == 0 ) Then
--          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
--          EthNextAdr[].D= ARP_InitAd_plus12 ;   --/ .. "IP-Daddr" (Comp's IP)
          TxAdrSet1 = VCC;
        End IF;
      WHEN  8 => TxDataBus[] = EtherRAM.q_a[];  -- normal connection
        IF ( Ether.TxCount[1..0] == 0 ) Then
--          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
--      --    EthNextAdr[].D= 59;                   --/ .. "UDP-SourPort"
--          EthNextAdr[].D= 58;                   --/ .. "UDP-SourPort", "UDP-DestPort", etc.
          TxAdrSet2 = VCC;
        End IF;
      WHEN 11 => TxDataBus[] = (B"00000",DBlkLengthRg[11..1].q);-- DataBlock_Length (UDP and CMD3)
        IF ( Ether.TxCount[1..0] == 0 ) Then
--          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
--          EthNextAdr[].D= 43 ;                  --/ .. "UDP-header'CRC" = 0
          TxAdrSet3= VCC;
        End IF;
      WHEN 12 => TxDataBus[] = EtherRAM.q_a[];  -- normal connection
        IF ( Ether.TxCount[1..0] == 0 ) Then
--          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
--          EthNextAdr[].D= 62 ;                  --/ .. UDP-DataBlock
          TxAdrSet4= VCC;
        End IF;
      WHEN OTHERS  => TxDataBus[15..0] = EtherRAM.q_a[15..0];
                      IPhdCRC_Cen      = GND;
    End CASE;
ELSE
    TxDataBus[15..0] = EtherRAM.q_a[15..0]; 
End IF;

TxAdrSet1a  = DFF (.D=TxAdrSet1,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
TxAdrSet1b  = DFFE(.D=TxAdrSet1a, .clk= Clk100, -- \..TxAdrSet1 has =garanteedly= settled.
            .ena=(!(TxAdrSet1  $ TxAdrSet1a) &  -- / ena:  ( (TxAdrSet1a == TxAdrSet1)
                   (TxAdrSet1a $ TxAdrSet1b)) );--/        & (TxAdrSet1b != TxAdrSet1a) )

TxAdrSet2a  = DFF (.D=TxAdrSet2,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
TxAdrSet2b  = DFFE(.D=TxAdrSet2a, .clk= Clk100, -- \..TxAdrSet2 has =garanteedly= settled.
            .ena=(!(TxAdrSet2  $ TxAdrSet2a) &  -- / ena:  ( (TxAdrSet2a == TxAdrSet2)
                   (TxAdrSet2a $ TxAdrSet2b)) );--/        & (TxAdrSet2b != TxAdrSet2a) )

TxAdrSet3a  = DFF (.D=TxAdrSet3,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
TxAdrSet3b  = DFFE(.D=TxAdrSet3a, .clk= Clk100, -- \..TxAdrSet3 has =garanteedly= settled.
            .ena=(!(TxAdrSet3  $ TxAdrSet3a) &  -- / ena:  ( (TxAdrSet3a == TxAdrSet3)
                   (TxAdrSet3a $ TxAdrSet3b)) );--/        & (TxAdrSet3b != TxAdrSet3a) )

TxAdrSet4a  = DFF (.D=TxAdrSet4,  .clk=!Clk100);--\ Flips  0->1  and  1->0  when ..
TxAdrSet4b  = DFFE(.D=TxAdrSet4a, .clk= Clk100, -- \..TxAdrSet4 has =garanteedly= settled.
            .ena=(!(TxAdrSet4  $ TxAdrSet4a) &  -- / ena:  ( (TxAdrSet4a == TxAdrSet4)
                   (TxAdrSet4a $ TxAdrSet4b)) );--/        & (TxAdrSet4b != TxAdrSet4a) )

IF    TxAdrSet1b  Then
    EthAdrInit    = VCC;                --\_prepare for transmitting ..
    EthNextAdr[].D= ARP_InitAd_plus12;  --/ .. "IP-Daddr" (Comp's IP)
End IF;
IF    TxAdrSet2b  Then
    EthAdrInit    = VCC;                --\_prepare for transmitting ..
    --EthNextAdr[].D= 59;                 --/ .. "UDP-SourPort"
    EthNextAdr[].D= 58;                 --/ .. "UDP-SourPort", "UDP-DestPort", etc.
End IF;
IF    TxAdrSet3b  Then
    EthAdrInit    = VCC;                --\_prepare for transmitting ..
    EthNextAdr[].D= 43 ;                --/ .. "UDP-header'CRC" = 0
End IF;
IF    TxAdrSet4b  Then
    EthAdrInit    = VCC;                --\_prepare for transmitting ..
    EthNextAdr[].D= 62 ;                --/ .. UDP-DataBlock
End IF;

%
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  For TEST :  send  THE SAME UDP-packet  back to Comp  ***************
--    Don't forget to change the InitAddr in "IF  StartEthTx_CAMAC" statement above !
Ether.DataBus_in[15..0] = EtherRAM.q_a[];    
IF  (Ether_TxUDPcycle & Ether.TxDataBlck)  Then
    CASE  Ether.TxCount[11..2]  is
--      WHEN  0 => Ether.DataBus_in[] = (B"00000",(DBlkLengthRg[11..1]+20));  --IP-Length
--      WHEN  1 => Ether.DataBus_in[] = UDP_PackCt.q[];           --Num of UDP-packet
      WHEN  4 =>
        IF ( Ether.TxCount[1..0] == 0 ) Then
          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
          EthNextAdr[].D= 38;                   --/ .. "IP-Saddr" (ThisDevice' IP)
        End IF;
      WHEN  6 =>
        IF ( Ether.TxCount[1..0] == 0 ) Then
          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
          EthNextAdr[].D= ARP_InitAd_plus12 ;   --/ .. "IP-Daddr" (Comp's IP)
        End IF;
      WHEN  8 =>
        IF ( Ether.TxCount[1..0] == 0 ) Then
          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
          EthNextAdr[].D= 59;                   --/ .. "UDP-SourPort"(="UDP-DestPort" in Test)
        End IF;
      WHEN  9 =>
        IF ( Ether.TxCount[1..0] == 0 ) Then
          EthAdrInit    = VCC;                  --\_prepare for transmitting ..
          EthNextAdr[].D= 59;                   --/ .. "UDP-DestPort", etc.
        End IF;
    End CASE;
End IF;%

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--***************  PROCEEDING of an ETHERNET CMD3 Tx_Cycle  ********************

--Selector of data sources for composing the Beginning of transmitted CMD3-packet :
--TxDataBus - local bus (formal only) used by Tx_cycle proceeding circuit
IF (Ether_TxCMDcycle==VCC) Then
    IF    (Ether.TxPkLenTyp==VCC)  Then             --\_ 1st DWord will be..
      TxDataBus[] = ( H"00", OpCode1_bit[8..1].q);  --/  .. = OpCode
    ELSIF (Ether.TxDataBlck                         --\  2nd DWord
          & (Ether.TxCount[11..2]==0) )  Then       -- > will be..
    TxDataBus[] = InData1_bit[16..1].q;             --/  .. = InData (EvtNum)
    ELSE
      TxDataBus[15..0] = EtherRAM.q_a[15..0]; 
    End IF;
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************** Busy Flag, Error Flag *****************************************
Busy	= Link_IFace.LinkMessage OR CPU.Working --OR Ether.RxDataBlck ;
        OR ( TypeRaw # TypeCMD3 # TypeIP # TypeARP );   -- =recognized= Ethernet frame
Error	= Link_IFace.Error OR CPU.Error OR Ether.RxError;--OR Ether.TxError ;
RESET	= DFF(.D=(PwrUpReset OR ExtReset), .clk=Clk100) ;
--============================================================================
--******** 10. Error counter ******************************************************

-- Project Bus Port, common
	ErrorCounters_IFace.clock 			=	CLK100;
	ErrorCounters_IFace.AddrBusIn[2..0]	=	AddrBus[2..0];
	ErrorCounters_IFace.DataBusStrobe	=	DataStrobe ;
-- Project Bus Port, Slave
	--ErrorCounters_IFace.DirectIn		= 	RW;
	ErrorCounters_IFace.Select			= 	DevSel[10].q;

	ErrorCounters_IFace.ErrorInputs[0]	=	CPU.Error;--Bus_Arbiter.ErrorLight;
	ErrorCounters_IFace.ErrorInputs[1]	=	GND;--Bus_Arbiter.Error;
	ErrorCounters_IFace.ErrorInputs[2]	=	TA12Channel[0].Error OR TA12Channel[1].Error OR TA12Channel[2].Error OR TA12Channel[3].Error;
	ErrorCounters_IFace.ErrorInputs[3]	=	Link_IFace.Error;
    ErrorCounters_IFace.ErrorInputs[4]	=	Ether.TxError;
    ErrorCounters_IFace.ErrorInputs[5]	=	Ether.RxError;
--    ErrorCounters_IFace.ErrorInputs[6]  =   Ether.Error;--Sync_ES.q;
    ErrorCounters_IFace.ErrorInputs[6]	=   Error;--Sync_ES.q;

--============================================================================
-- 11. Internal Bus of Project & Data transfer control ************************

AddrBus[15..0]		= CPU.AddrOut[15..0];   -- CPU is the only Master, rules forever
RW					= CPU.RdWr ;        -- 0=[Read: Object->CPU] / 1=[Write: CPU->Object]
--CPU.AccessGranted   = AccessGrtd;       -- connected in "8. Processor" section
--CPU.DataStrobe      = DataStrobe;       -- connected in "8. Processor" section

-- Bus Handler : 
AcsRqDetect	= EdgeSensing(.D=CPU.AccessReq, .clk=Clk100, .reset=RESET);
AccessGrtd	=SRFF(.S=AcsRqDetect,.clk=Clk100, .r=DataStrobe, .clrn=!RESET); --=1 during whole Operation
AddrSettled =SRFF(.S=(AccessGrtd & !AddrSettled),                           --flag; enables "DevSel[]" triggers
						.clk=Clk100, .r=DataStrobe, .clrn=!RESET); 
BusOper1	= DFF(.D=AddrSettled,.clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
BusOper2	= DFF(.D=BusOper1,   .clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
BusOper3	= DFF(.D=BusOper2,   .clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
DataStrobe	= DFF(.D=BusOper3,   .clk=Clk100,.clrn=!RESET); -- 1-clk pulse

-- When Address from Master is set on the Address Bus, ...
-- DEVICE SELECTION - the Slave-device is identified by its Address 

--1) Main RAM, Program RAM, CommandList RAM
IF ((AddrBus[15..0] >=  MainRAM_Offset ) AND 
	(AddrBus[15..0] <= (MainRAM_Offset + MainRAM_Size - 1))) 
	Then  MainRAM_cs    = VCC;          -- Address belongs to MainRAM
	Else  MainRAM_cs    = GND;
End IF;
IF ((AddrBus[15..0] >=  ProgRAM_Offset ) AND 
    (AddrBus[15..0] <= (ProgRAM_Offset + ProgRAM_Size - 1))) 
    Then  ProgRAM_cs    = VCC;          -- Address belongs to ProgRAM
    Else  ProgRAM_cs    = GND;
End IF;
IF ((AddrBus[15..0] >=  CommdList_Offset ) AND 
    (AddrBus[15..0] <= (CommdList_Offset + CommdList_Size - 1))) 
    then  CommandRAM_cs = VCC;          -- Address belongs to CommandRAM
    else  CommandRAM_cs = GND;
End IF;
IF ((AddrBus[15..0] >=  SetupRAM_Offset ) AND 
    (AddrBus[15..0] <= (SetupRAM_Offset + SetupRam_Size - 1))) 
    then  SetupRAM_cs   = VCC;          -- Address belongs to SetupRAM
    else  SetupRAM_cs   = GND;
End IF;

-- 2) Registers and similar objects
IF ((AddrBus[15..0] >= Servo_offset) AND            --\_(#[2048..(2048+7)]
    (AddrBus[15..0] <= Servo_offset+Servo_size-1 )) --/ addr range for various Reg-s
    Then Servo_CS   = VCC;
    Else Servo_CS   = GND ;
End IF ;
IF (AddrBus[15..0] == FIFO_OpCode_offset)   -- FIFO-Cell#1 :  OpCode reg (Read only)
	Then FIFO_OpCode_cs = VCC;
	Else FIFO_OpCode_cs = GND;
End IF ;
IF (AddrBus[15..0] == FIFO_InData_offset)   -- FIFO-Cell#1 :  InData reg (Read only)
	Then FIFO_InData_cs = VCC;
	Else FIFO_InData_cs = GND;
End IF ;

--3) Link: InData, DataBus_in / DataBus_out
IF (AddrBus[15..2] == Link_IFace_Offs )     -- Init.addr of Link's registers
    Then Link_cs = VCC ;
    Else Link_cs = GND ;
End IF ;

--4) Ethernet Section RAM
IF ((AddrBus[15..0] >= EtherRAM_Offset ) AND 
	(AddrBus[15..0] <= (EtherRAM_Offset + EtherRAM_Size - 1)))
	Then EtherRAM_cs    = VCC ;
	Else EtherRAM_cs    = GND ;
End IF ;

--5) Data TA12
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] >= (ADC_RAM_Offset + i*ADC_RAM_Size)) AND
		(AddrBus[15..0] <= (ADC_RAM_Offset + (i+1)*(ADC_RAM_Size - 1))) ) 
		THEN 	TA12Channel_cs[i]   = VCC;
		ELSE 	TA12Channel_cs[i]   = GND;
	END IF;
END GENERATE;

IF ((AddrBus[15..0] >=  Compres_Offset) AND 
	(AddrBus[15..0] <= (Compres_Offset + 1))) 
	then  Compres_cs = VCC;          -- Address belongs to CommandRAM
	else  Compres_cs = GND;
End IF;

--6) Error counter
IF ((AddrBus[15..0] >= ErrorCounters_Offset) AND ((ErrorCounters_Offset + ErrorCounters_Size) > AddrBus[15..0]) ) 
	THEN ErrorCounters_IFace_CS = VCC ; 
	ELSE ErrorCounters_IFace_CS = GND ; 
END IF ;

-- 7) Test
IF ((AddrBus[15..0] >=  TestRAM_Offset ) AND 
	(AddrBus[15..0] <= (TestRAM_Offset + TestRAM_Size - 1))) 
	Then TestRAM_cs = VCC;          -- Address belongs to MainRAM
	Else TestRAM_cs = GND;
End IF;

-- 8) ZERO: fictive object, always replies B"0000000000000000" word
IF ( AddrBus[15..0] == B"1111111111111111" )
	Then ZERO_cs = VCC ;         -- Address of ZERO word
	Else ZERO_cs = GND ;
End IF ;

DevSel[ 1].d    = MainRAM_cs ;
DevSel[ 2].d    = ProgRAM_cs ;
DevSel[ 3].d    = CommandRAM_cs ;
DevSel[ 4].d    = Link_cs ;             -- Link's I/O port, InData_out, OpCode_out
DevSel[ 5].d    = FIFO_OpCode_cs ;      -- FIFO-Cell#1 :  OpCode reg
DevSel[ 6].d    = FIFO_InData_cs ;      -- FIFO-Cell#1 :  InData reg
DevSel[ 7].d    = SetupRAM_cs ;
DevSel[ 8].d    = Servo_cs ;            -- ServoMUX for several Registers
DevSel[ 9].d    = EtherRAM_cs ;         -- EtherRAM
--DevSel[10].d	= EthOpCode_cs ;        -- Reg_EthOpCode
DevSel[10].d    = Servo_cs ;    -- added just to prevent Quartus from deleting DevSel[10]
FOR i IN 0 TO (NUM_CH-1) GENERATE
	DevSel[11+i].d  = TA12Channel_cs[i];	-- ADC channel data
END GENERATE;
DevSel[15].d	= ErrorCounters_IFace_CS;	-- Error Counters
DevSel[16].d	= TestRAM_cs;				-- Test RAM
DevSel[17].d	= ZERO_cs;					-- ZERO word

FOR i in 1 to 17 % with ErCount must be 28 % GENERATE
	DevSel[i].clrn = AddrSettled;   -- DevSel[] are enabled while Addr. is settled
	DevSel[i].clk  = Clk100;
END GENERATE; 

AddrValid = DevSel[ 1].q OR  -- MainRAM
            DevSel[ 2].q OR  -- ProgRAM
            DevSel[ 3].q OR  -- CommandRAM
            DevSel[ 4].q OR  -- Link's I/O port, InData_out, OpCode out
            DevSel[ 5].q OR  -- FIFO-Cell#1 :  OpCode reg
            DevSel[ 6].q OR  -- FIFO-Cell#1 :  InData reg
            DevSel[ 7].q OR  -- SetupRAM
            DevSel[ 8].q OR  -- ServoMUX for several Registers
            DevSel[ 9].q OR  -- EtherRAM
--            DevSel[10].q OR  -- Reg_EthOpCode
            DevSel[11].q OR DevSel[12].q OR DevSel[13].q OR DevSel[14].q OR DevSel[15].q OR DevSel[16].q OR --\ [1-6] ADC channels
            DevSel[17].q %OR DevSel[18].q OR DevSel[19].q OR DevSel[20].q OR DevSel[21].q OR DevSel[22].q OR --/ [7-12] ADC channels
            DevSel[23].q OR
            DevSel[24].q OR
            DevSel[25].q%;   -- Something?? :  ZERO word

--AddrSettled = Bus_Arbiter.AddressSettled; --In 1clock after "AccessGranted"..
	-- ..address is expected to be set on the Addr.bus, and Arbiter produces 
	-- "AddrSettled" signal, which enables DevSel[] triggers 
--Bus_Arbiter.AddressValid= AddrValid;    -- Address recognized, and correspondent device selected
--DataStrobe  = Bus_Arbiter.DataStrobe ;  --in 2clocks after "TargetReady"

-- Multiplexer of Data Bus among "Servo" Registers
CASE  AddrBus[2..0] is
	When 0  => Servo_Mux[16..1] = (H"000", EtherUDPmode,EtherCMD3mode, StartMulti,StartOne);
	When 1  => Servo_Mux[16..1] = (B"00000000", Reg_BaseAddr.q[7..0]);
	When 2  => Servo_Mux[16..1] = (B"0000", ADCfeed_WordCt.q[3..0], ADCfeed_AddrCt.q[7..0]);
	When 4  => Servo_Mux[16..1] = (B"00000",  DBlkLengthRg[11..1].q);
	When 5  => Servo_Mux[16..1] = (UDP_PackCt.q[15..0]);
	When 6  => Servo_Mux[16..1] = (B"000000", EtherPauseRg[10..1].q); 
	When 7  => Servo_Mux[16..1] = (B"00000000", Reg_EthOpCode[8..1].q);
	When OTHERS => Servo_MUX[16..1] = H"FFFF"; -- indication of a wrong address
END CASE;

-- FINAL Multiplexer of Data Bus sources
IF (RW == VCC) Then		-- Master will write to
	DataBus[] = CPU.DataOut[] ;
Else					-- Master will read from
	CASE DevSel[].q IS     -- DataBus' MUX for Target drivers
        WHEN b"00000000000000001" => DataBus[]		= MainRAM.q[];
        WHEN b"00000000000000010" => DataBus[]		= CPU.ProgRAM_q[];
        WHEN b"00000000000000100" => DataBus[]		= CommandRAM.q[];
        WHEN b"00000000000001000" => CASE  AddrBus[1..0] is
            When 0 => DataBus[]    = Link_IFace.InData_out[];
            When 1 => DataBus[]    = Link_IFace.DataBus_out[];
            When 2 => DataBus[7..0]= Link_IFace.OpCode_out[];
            End CASE;
        WHEN b"00000000000010000" => DataBus[ 7..0] = OpCode1_bit[ 8..1].q;-- FIFO Cell#1' OpCode
        WHEN b"00000000000100000" => DataBus[15..0] = InData1_bit[16..1].q;-- FIFO Cell#1' InData
        WHEN b"00000000001000000" => DataBus[ 7..0] = SetupRAM.q_b[];
        WHEN b"00000001010000000" => DataBus[]      = Servo_Mux[16..1];     -- various Reg-s
                  -- ^^^^- DevSel[10] is made SAME as DevSel[8] !
		WHEN b"00000000100000000" => DataBus[]      = EtherRAM.q_b[];       --MainProj <- EtherRAM 
--		WHEN b"0000000000000001000000000" => DataBus[7..0]	= Reg_EthOpCode[8..1];				--Ether's OpCode
		WHEN b"00000010000000000" => DataBus[]		= TA12Channel[0].DataBusOut[];
		WHEN b"00000100000000000" => DataBus[]		= TA12Channel[1].DataBusOut[];
		WHEN b"00001000000000000" => DataBus[]		= TA12Channel[2].DataBusOut[];
		WHEN b"00010000000000000" => DataBus[]		= TA12Channel[3].DataBusOut[];
		WHEN b"00100000000000000" => DataBus[]		= ErrorCounters_IFace.DataBusOut[];
		WHEN b"01000000000000000" => DataBus[]		= TestRAM.q[];						-- MainProj <- TestRAM 
		WHEN b"10000000000000000" => DataBus[]		= 0; 								-- ZERO word temporary ?
--		WHEN b"0000000000100000000000000" => DataBus[]		= TA12Channel[4].DataBusOut[];
--		WHEN b"0000000001000000000000000" => DataBus[]		= TA12Channel[5].DataBusOut[];
--		WHEN b"0000000010000000000000000" => DataBus[]		= TA12Channel[6].DataBusOut[];
--		WHEN b"0000000100000000000000000" => DataBus[]		= TA12Channel[7].DataBusOut[];
--		WHEN b"0000001000000000000000000" => DataBus[]		= TA12Channel[8].DataBusOut[];
--		WHEN b"0000010000000000000000000" => DataBus[]		= TA12Channel[9].DataBusOut[];
--		WHEN b"0000100000000000000000000" => DataBus[]		= TA12Channel[10].DataBusOut[];
--		WHEN b"0001000000000000000000000" => DataBus[]		= TA12Channel[11].DataBusOut[];
--		WHEN b"0010000000000000000000000" => DataBus[]		= ErrorCounters_IFace.DataBusOut[];	--
--		WHEN b"0100000000000000000000000" => DataBus[]		= TestRAM.q[];						-- MainProj <- TestRAM 
--		WHEN b"1000000000000000000000000" => DataBus[]		= 0; 								-- ZERO word temporary ?
		WHEN OTHERS => DataBus[] = 0;
	End CASE;
End IF;

--============================================================================
-- 8. Testing circuitry ******************************************************
--TestCt.(clock, clk_en)  = (LinkClk, VCC); -- Test Counter, can be used to drive LED blinking
TestCt.(clock, clk_en)	= (FQuartz, VCC); -- Test Counter, can be used to drive LED blinking
TestCt.cnt_en			= PowerUp0;
TestCt.aclr				= !PowerUp0;    -- even if NO clock - Reset does occur

TestRAM.(address[7..0], data[],    clock,    wren                     ) =
        (AddrBus[7..0], DataBus[], Clk100,(DataStrobe & DevSel[16] & RW)); 

--    TestTrg1 = SRFF(.S=DFF(.D=(TypeIP & (Ether.RxDataCt[] == 6)), .clk=Clk100), 
--                    .R=Ether.RxEndFrame, .clk=Clk100) ;
    TestTrg2 = DFF(.D=(AddrBus[]==2080), .clk=Clk100);
    TestTrg3 = DFF(.D=(AddrBus[]==2081), .clk=Clk100);
--    TestTrg4 = DFF(.D=((Ether.RxDestAddr # Ether.RxSourAddr) 
--                    & (EtherAdrCt.q[9..0] > 8)), .clk=RxClk);

--Test1 = TxPreamble;                                                     --Ether.TX_EN;      -- Pin236
Test2 = InData_Reg[3].q[3];	--DDR_Reg_neg[1][0].q[1]; --StartProc;  --DDR_InLVDS[1][1].dataout_l;   --EthAddrLd2;       --Ether.test[1];    -- Pin238
Test3 = InData_Reg[3].q[4];	--DDR_Reg_pos[1][0].q[2]; --Link_IFace.IOrq;        --ADCfeed_Beg1;     --TxUDP_Rq;         --Ether.RxSourAddr; -- Pin239
Test4 = InData_Reg[3].q[5];	--DDR_Reg_neg[1][0].q[2];	--CPU.AccessReq;          --TxWFhist_Eth.q;   --InitUDP;          --Ether.RxPkLenTyp; -- Pin240
Test5 = InData_Reg[3].q[6];	--DDR_Reg_pos[1][1].q[0];	--DevSel[ 1].q;           --ReadExtMem;       --EtherBusy;        --Ether.test[6];    -- Pin__4
Test6 = InData_Reg[3].q[7];	--DDR_Reg_neg[1][1].q[0];	--DevSel[ 4].q;           --Ether.IORq;       --EtherPauseCt.eq0; --Ether.test[7];    -- Pin__5
Test7 = InData_Reg[3].q[8];	--DDR_Reg_pos[1][1].q[1];	--ADCfeed_Beg2;           --Ether_TxCMDcycle; --EthBusyEnd;       --Ether.test[8];    -- Pin__6
Test8 = InData_Reg[3].q[9];	--DDR_Reg_neg[1][1].q[1];	--ADCfeed_Cycle1;         --CommdPut_ld;
Test9 = InData_Reg[3].q[10];	--DDR_Reg_pos[1][1].q[2];	--ADCfeed_NextB;          --OutData_rdy.q;                        -- Pin__9
Test10= InData_Reg[3].q[11];	--DDR_Reg_neg[1][1].q[2];	--ADCfeed_WordEnd;        --Contin1.q;        --DataStrobe;       --DataIn_TA[0][9];  -- Pin

END;