Title "TA12 Module for LXeTower";
-- v1.0  : The project of digitizing module for LXe-calorimeter

INCLUDE "lpm_compare.inc" ;
INCLUDE "lpm_ff.inc";
INCLUDE "lpm_shiftreg.inc" ;
INCLUDE "lpm_counter.inc" ;
INCLUDE "lpm_add_sub.inc";
INCLUDE "lpm_divide.inc";
INCLUDE "pdo.inc";
INCLUDE "seio.inc";
INCLUDE "diffin.inc";

INCLUDE "EdgeSensing.inc";
INCLUDE "LevelSensing.inc" ;
INCLUDE "LightPulser.inc";
INCLUDE "DelayLine.inc" ;
INCLUDE "PulseShaper.inc" ;
INCLUDE "PhaseSwitch.inc";
--INCLUDE "LVDS_Out.inc";

INCLUDE "PLL_TA6.inc";
INCLUDE "DDR_in.inc";
INCLUDE "Digitizer_TA6.inc";
INCLUDE "WFTA_HistRAM.inc";
INCLUDE "PD_upgrade.inc";
INCLUDE "UpLink.inc";
INCLUDE "Fast_Link.inc";
INCLUDE "Ethernet.inc";
INCLUDE "RAMmain_TA6.inc" ;     -- general purpose RAM
INCLUDE "RAMcommd_TA6.inc" ;    -- CommandList RAM
INCLUDE "PROCESSOR.inc" ;

INCLUDE "TestRAM_main.inc";

--INCLUDE "RAMdigit_TA6.inc";     -- RAM of Digitizer, declared in Digitizer
--INCLUDE "RAMhist_TA6.inc";      -- RAM of Digitizer, declared in Digitizer
--INCLUDE "im_ram.inc";           -- RAM of Digitizer, declared in Digitizer

INCLUDE "Bunch_Crossing_adjust.inc";
INCLUDE "ErrorCounters.inc";

Constant MainRAM_Offset 		= H"0300";	-- main RAM block, 256words * 16bits
Constant MainRAM_Size			= 256;		-- #768..#1023
Constant ProgRAM_Offset 		= H"0400";	-- Program RAM block, 256words * 16bits
Constant ProgRAM_Size			= 256;		-- #1024..#1279
Constant CommdList_Offset		= H"0C00";	-- #3072  RAM block containing the Command Lists
Constant CommdList_Size			= 1024;		-- #3072..#4095
Constant BaseAddr_offset		= H"0802";	-- #2050  Base Address of Program to be started
Constant Link_IFace_Offset		= H"0820";	-- #2080 - Link's InData_Port
											-- #2081 - Link's Data_Port
Constant OpCode_offset			= H"0822";	-- #2082 - OpCode (read-only register)

Constant SelCommdList			= H"0BB8";	-- #3000 - Select the CommandList (read-only register)

Constant ADC_RAM_Offset 		= H"1000";	-- #4096 RAM of ADC1 #5120 RAM of ADC2 #6144 RAM of ADC3
											-- #7168 RAM of ADC4 #8192 RAM of ADC5 #9216 RAM of ADC6
Constant ADC_RAM_Size			= 1024;		-- ?acia? iaeanoe iia ea?aue eaiae
Constant Compres_Offset			= H"4000";
Constant WF_RAM_Offset			= H"6000";	-- 24576
Constant WF_RAM_Size			= 768;
Constant WF_RAM_SE_Ctrl			= H"6800";	-- 26624
--Constant DDREqu_Offset 			= H"2900";	-- #10496
--Constant DDREqu_Size 			= 1;
--Constant DDRNEqu_Offset			= H"2910";	-- #10512
--Constant DDRNEqu_Size			= 1;

Constant ErrorCounters_Offset	= H"6900" ;	-- #26880
Constant ErrorCounters_Size		= 16;

--Constant Bunch_Crossing_12_5_T0_Offset	= H"3100";	-- 12544
--Constant Bunch_Crossing_12_5_DS_Offset	= H"3108";	-- 12552
--Constant Bunch_Crossing_12_5_FLS_Offset	= H"3110";	-- 12560

Constant TestRAM_Offset 		= H"7000";	-- 28672, Test RAM block
Constant TestRAM_Size			= 256;		-- 256words * 16bits

Constant ThisDeviceAddr			= H"055555555521"; 

CONSTANT ADC_Bits				= 12;	-- Number of ADC bits
CONSTANT NUM_CH					= 12;	-- Number of channels on the board
CONSTANT TA_Bits				= 10;	-- Number of transfered bits to IPT_LXe

SUBDESIGN TA12_Digitizer
(
-- 1. Reference Clock's & Frequency Control I/O
FQuartz			: input;	-- 25MHz clock from Quartz oscillator       <- Pin46
-- In TA6 module Link's Clock is checked inside Altera but switched outside 
Sw_Quartz		: output;	-- connects Quartz to PLL ref.Input         -> Pin45
Sw_LinkClk		: output;	-- connects Link's Clock to PLL ref.Input   -> Pin49

PLL_res			: output;	-- Ref.clock for PLL (dedicated)            <- Pin31
PLL_in			: input;	-- Ref.clock for PLL (dedicated)            <- Pin31
PLL_ExtOut		: output;	-- Output of PLL.e0 to outside              -> Pin69

-- 1.1 PLL Installation

PLLinst_S0		: output;
PLLinst_S1		: output;
PLLinst_EN		: output;

-- Outputs for Indicators on LED's
LedR			: output;   -- drives the Red LED                       -> Pin63
LedG			: output;   -- drives the Green LED                     -> Pin64
LedB			: output;   -- drives the Blue(Yellow) LED              -> Pin65
EtherLed		: output;

-- 2. Data transfer signals 
-- 2a. UpLink signals 
LinkClk			: input;    -- Clock from Link's ClockLine              <- Pin 
LinkData_p		: bidir;    -- Data <-> Link's DataLine                 <->Pin 
LinkData_n		: bidir;    -- Data <-> Link's DataLine                 <->Pin 
--LinkTxRx		: output;   -- iai?aaeaiea ia?aaa?e a "DataLine"        -> Pin 

-- 2b. FastLink signals 
SerDataOut[13..0]			: output;  -- aaiiua aey ia?aaa?e n iiiiuu? Serializer-a a EIO
NWordFLink[1..0]			: output;  -- iiia? neiaa a aaiiuo aey ia?aaa?e n iiiiuu? Serializer-a a EIO
RPWDN						: output;  -- aee/auee Serializer-a
TPWDN						: output;  -- aee/auee Deserializer part
REN							: output;  -- aee/auee Serializer-a
DEN							: output;  -- aee/auee Serializer-a
SerClk						: output;  -- oaeoiaue neaiae Serializer-a
FLink_Sync					: input;  -- neaiae neio?iiecaoee Serializer-a/Deserializer-a
TAWF_DataStrobe				: output;

-- 2c. Ethernet Phy device ports     LXT972
RxClk			: input;        --                                <- Pin137
CRS				: input;        -- Carrier_Sense                  <- Pin126
RxDV			: input;        -- Data_Valid                     <- Pin139
RxD[3..0]		: input; 
RxEr			: input;        -- RxEr not in use!!!! pin109-corner

TxClk			: input;
TxEn			: output;
TxD[3..0]		: output;
COL				: input;        -- Collision_Detect not used

-- 3. Digitizers  
ADC_In_Data[NUM_CH-1..0][1..0]	: input;    -- input of data from ADC Pin197..219, Pin110..123,...
ADC_FrameClk[2..0]				: input;
ADC_DataClk[2..0]				: input;
ADC_SEN[2..0]					: output;
ADC_SDATA[2..0]					: output;
ADC_SDOUT[2..0]					: input;
ADC_SCLK						: output;

-- 4. Ext RAM  

ExtRAM_Addr[15..0]		: output;
ExtRAM_Data[15..0]		: bidir;
ExtRAM_OutEn			: output;
ExtRAM_InEn				: output;
ExtRAM_WriteEn			: output;
ExtRAM_LowerByteControl	: output;
ExtRAM_UpByteControl	: output;

ExtReset			: input = GND;  -- external Reset (tied to GND --VCC)   <- Pin

Test_in				: input;
Test[10..1]			: output;
)

VARIABLE
--============================================================================
--******** 1. Reference clock's & Frequency Control **************************
PLL				: Pll_TA6;  -- PLL:  Fin=25MHz, PLL.c0=(25MHz shift=0), PLL.c1=(100MHz shift=0)
Clk25			: node; -- This is Global Node 
Clk37_5			: node; -- This is Global Node 
Clk75			: node; -- This is Global Node
Clk100			: node; -- This is Global Node
Clk300_adc		: node; -- This is Global Node
Clk50			: node; -- This is Global Node

-- Automatic Clock Switch: if External_Clock frequency (kHz) is in specified 
--   range, PhaseSwitch transfers the External_Clock to PLL1's reference input, 
--   thus all PLL's output clocks are locked to the External_Clock. 
PhaseSw			: PhaseSwitch with (FmaxThresh=26000, FminThresh=23000, RefClock=25000);

Clk25del1,
Clk25del2			: node;
PhaseSet,					-- _/^^\_ pulse aligned to _/ front of StartBit
Phase12,
Synchro12,					-- 1-clock _/^\_ pulse aligned to _/ front of PHASE
Synchro25			: node; -- 1-clock _/^\_ pulse aligned to PHASE and half-PHASE
 
--******** Power-up self-Reset and self-Set pulses ***************************
PowerUp0,					--\   Circuit 
PowerUp1, PowerUp2,			-- \  which generates 
PowerUp3, PowerUp4,			--  \ a pulse 
PowerUp5, PowerUp6,			--  / for power-up Reset  \  many milliseconds apart 
PwrUpReset,					-- /  and then few pulses  > from each other
PwrUpSet1,PwrUpSet2			: node;	--/ for power-up Set    /  

--============================================================================
--******** 2. Timers for Indicators on LED's (Duration in ms, RefClock in kHz)
B_Flash				: LightPulser with (Duration = 20, RefClock = 100000); -- Blue
R_Flash				: LightPulser with (Duration = 20, RefClock = 100000); -- Red
LinkFlash			: LightPulser with (Duration = 50, RefClock = 100000); -- Green
EtherTx_Flash		: LightPulser with (Duration = 16, RefClock = 100000); -- Blue

--============================================================================
--******** 3a. Up_Link
Link_IFace			: UpLink with (RefClock = 100);
Delay_LinkMessage	: DFF;

b2v_inst2			: pdo;
b2v_inst3			: seio;
b2v_inst4			: seio;
b2v_inst5			: diffin;

--============================================================================
--******** 3b. Fast_Link TA6/12->IPT

FLink_Data_BUS				: lpm_shiftreg with (lpm_width=12, lpm_direction="unused");
--FLink_cnt					: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- n?ao?ee a?aiaie aey neio?iiecaoee

FLink_Reg_LinkOpCode		: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
												 lpm_direction="unused"); -- not important
TxWFhist					: SRFF;
DelayWriteWFhist			: DelayLine with (DelayCode = 90,  -- to delay the real END of Write WFHist
								  DurationCode= 2); --  after LinkMessage-cycle
DataCount					: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- n?ao?ee aaiiuo ec iaiyoe eaiaea aey ia?aaa?e ii eeieo a EIO
ChannelCount				: lpm_counter with (lpm_width = 4, lpm_direction="up"); -- n?ao?ee eaiaeia aey ia?aaa?e ii eeieo a EIO
StopCount					: node;
NWordCount					: lpm_counter with (lpm_width = 2, lpm_direction="up"); -- n?ao?ee iiia?a neiaa ia?aaaaaaiiai ii eeieo a EIO

%
OutData						: LVDS_Out;
--OutData[TA_Bits-1..0]		: node;
OutData_Reg					: lpm_shiftreg with (lpm_width=14, lpm_DIRECTION="unused"); -- 
%
TestLinkCt					: lpm_counter with (lpm_width = 20, lpm_direction="up"); -- oanoiaue n?ao?ee aey i?iaa?ee ia?aaa?e aaiiuo

FLink_Error					: node;

-- 4. iauee NOII
-- LinkMessage_DFF               : DFF;
--
--Event_ES_Beg				: EdgeSensing;
--Event_ES_End				: EdgeSensing; 
--Event_Trig					: SRFF;
--LinkMsg_Trig				: DFF;
--
--Event_ES_Beg_				: EdgeSensing;
--Event_ES_End_				: EdgeSensing; 
--Event_Trig_					: SRFF;
--LinkMsg_Trig_				: DFF;

--============================================================================
--******** 4. ETHERNET ****************************************************** 
Ether			: Ethernet;

--Подготовка данных для Ethernet

TxWFhist_Eth			: SRFF;
Delay_EthMessage		: DFF;
DelayWriteWFhist_Eth	: DelayLine with (DelayCode = 90,  -- to delay the real END of Write WFHist
									DurationCode= 2); --  after LinkMessage-cycle
DataCount_Eth			: lpm_counter with (lpm_width = 8, lpm_direction="up"); -- n?ao?ee aaiiuo ec iaiyoe eaiaea aey ia?aaa?e ii eeieo a EIO
ChannelCount_Eth		: lpm_counter with (lpm_width = 4, lpm_direction="up"); -- n?ao?ee eaiaeia aey ia?aaa?e ii eeieo a EIO
StopCount_Eth			: node;

EthWord_Rd		: node; -- strobe at "Read"  operation, read 1 DWord from ETHERNET
EthWord_Wr		: node; -- strobe at "Write" operation, write 1 DWord to ETHERNET

-- Circuitry which latches the 1st Byte received, as it is a COMMAND
RxDBlkDel[4..1]	: node; --delay of the "RxDataBlck" by 2 RxClocks and a little more
EthOpCode_save	: node; -- strobe for latching the =1st= Ethernet' DataWord (OpCode)
EthOpCode_saved	: node; -- =1 when Ethernet' OpCode is saved, till the End of Frame
Reg_EthOpCode	: LPM_SHIFTREG with (lpm_width=8,  -- contains Command received from Ethernet
										lpm_direction="unused"); -- not important
Eth_Reg_LinkOpCode		: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
											 lpm_direction="unused"); -- not important
Eth_Reg_LinkEvNumber	: lpm_shiftreg with (lpm_width=16, lpm_direction="unused");

Delay_St_Ether_Link		: SRFF;
EtherLinkMessage		: SRFF;
EtherLinkTimeCt			: lpm_counter with (lpm_width = 11, lpm_direction="up");

EndEtherTx		: node;
EtherBank_1,
EtherBank_2,
EtherBank_3		: SRFF;
EtherPause1,
EtherPause2,
EtherPause3		: SRFF;
EtherBankDelay	: lpm_counter with (lpm_width = 12, lpm_direction="up");

StartEthTx_Cnt	: lpm_counter with (lpm_width = 8, lpm_direction="up");
StatusPack		: lpm_shiftreg with (lpm_width=16, lpm_direction="unused");

-- Counter which contains address for exchange between ETHERNET and TestRAM
EthAddrCt		: lpm_counter with (lpm_width = 11, lpm_direction="up");
Eth_InitAddr[10..0] : node; -- initial address of data to be Transmitted

DataTrans		: node;
--CntBoard		: lpm_counter with (lpm_width = NUM_board-1, lpm_direction="up");

--============================================================================
--******** 4. Control Unit  
Start_Link		: PulseShaper with (DurationCode=4);--Start whatever by Link command

StartProc_Link	: node;
--StartProc       : node;         -- all sources of Start_Processor combined

StartADC_Link	: node;
--StartADC        : PulseShaper with (DurationCode=4);-- all sources of Start ADC combined
StartWFTx		: node;

OpCode_load		: node; -- puts Reg_OpCode into "load" mode
--    InDataSave, InDataSaved : node; -- for TEST Only!!

LinkMsg_beg     : node;
SelCommdList_Reg: lpm_shiftreg with (lpm_width=16, lpm_direction="unused");
SelCommdList_Count: lpm_counter with (lpm_width = 1, lpm_direction="up");
SelCommdList_Trig:	SRFF;
SelCommdList_Trig2:	DFF;
SelCommdList_Trig3:	SRFF;
SelCommdList_cs	: node;

StartOne		: node;         -- Trigger of One-Shot_Start
StartOne_En		: EdgeSensing;  -- _/~\_ sets StartOne to =1
StartMulti		: node;         -- Trigger of Multiple_Start
StartMulti_En	: EdgeSensing;  -- _/~\_ sets StartMulti to =1

StartWFTx_Eth	:node;
St_EthTx_Ether	: node;
St_Ether_Link	: node;
Delay_StEthTx	: DelayLine with (DelayCode = 200,  -- to delay the real start of Processor 
                                  DurationCode= 4); --  after CAMAC-cycle
--StartEthTx_Ether: PulseShaper with (DurationCode=4);--Start Ethernet' Transmit by Ethernet command
StartEthTx_Link	: PulseShaper with (DurationCode= 8); --Start Ethernet' Transmit by end of Link command
EmptyMess		: node;
StartEthTx		: node; -- all sources of Start_EthernetTx combined
Eth_WRITE,				-- flag: Ethernet' "Write" command is received 
EtherWRITE		: node; -- flag: Ethernet' "Write" command is received, registered 
--EtherWR_we		: node; -- Upon Ether' "WRITE" command, enables ETHERNET -> TestRAM

Reg_Block		: lpm_shiftreg with (lpm_width=1, lpm_direction="unused", lpm_svalue = b"0");

--PhSwErr_Ct      : lpm_counter with (lpm_width=16, lpm_direction="up") ; -- counts PhaseSwitch's flips
--LinkErr_Ct      : lpm_counter with (lpm_width=16, lpm_direction="up") ; -- counts Link's errors
--Servo_Mux[15..0]: node; -- additional "multiplexor" of DataBus among servo_objects

Busy			: node; -- flag: Action in progress (Digitizing, Link cycle, ...)
Error			: node;
RESET, 
Reset2			: node;

--============================================================================
--******** 5. Processor, RAM blocks and registers ****************************
CPU				: Processor ;
BaseAddr[7..0]	: node; -- address of the beginning of selected Program

--ADC_RAM belongs to "Digitizer_TA6" unit, and is defined there
MainRAM			: RAMmain_TA6;  -- RAM  256words * 16bits, 1-port
--ProgRAM belongs to "Processor" unit, and is defined there
CommandRAM		: RAMcommd_TA6; -- RAM 1024words * 16bits, 1-port

-- Register contains Base Address of Program to be started
Reg_BaseAddr	: LPM_SHIFTREG with (lpm_width=8, lpm_direction="left");
Reg_OpCode		: LPM_SHIFTREG with (lpm_width=(CommandSize+Pause), -- contains Command
									 lpm_direction="unused"); -- not important

--============================================================================
--******** 6. Digitizing data / Processing ******************************************************
ADCtest_bit_count	: lpm_counter with (lpm_width=6, lpm_direction="up" );
ADCtest_Bit_write	: node;
ADCtest_CSB_trig	: DFFE;
ADCtest_SDIO_trig	: DFFE;
ADCtest_reg			: lpm_shiftreg with (lpm_width=50,
						lpm_svalue = b"00000000000011010000110000000000001111111100000001",lpm_DIRECTION="left"); -- 
--									  "set	addr	 	data   set	addr		  data "
--									   3bit 13bit	 	8bit   3bit	13bit		  8bit

TA12Channel[NUM_CH-1..0]			: Digitizer_TA6;
DDR_InLVDS[NUM_CH-1..0][1..0]		: DDR_In;
DDR_Reg_pos[NUM_CH-1..0][1..0]		: lpm_shiftreg with (lpm_width=3,lpm_DIRECTION="left");
DDR_Reg_neg[NUM_CH-1..0][1..0]		: lpm_shiftreg with (lpm_width=3,lpm_DIRECTION="left");
InData[NUM_CH-1..0]			: node;
InData_RegMix[NUM_CH-1..0]	: lpm_shiftreg with (lpm_width=ADC_Bits,lpm_DIRECTION="unused"); -- 
InData_Reg[NUM_CH-1..0]		: lpm_shiftreg with (lpm_width=ADC_Bits,lpm_DIRECTION="unused"); -- 

TAWF_HistRAM				: WFTA_HistRAM;
TAWF_RAM_cs					: node;
TAWF_HistRAM_Cnt			: lpm_counter with (lpm_width = 11, lpm_direction="up");

Compres						: PD_upgrade;

--============================================================================
--******** 7. Internal Bus of Project; "Bus Handler";
--    Address recognition and devise selection
RW				: node; -- RW=1 - a (master)unit will output data 
AddrBus[15..0]	: NODE; -- 16 bit address
DataBus[15..0]	: NODE; -- 16 bit bidir Data Line
--Data[15..0]		: NODE; -- 16 bit bidir Data Line

--Bus_Arbiter     : Arbiter with (DeviceMaxNumber=2%,TimeOut=6%);
--  ^^^^ zdes' nafig ne nuzhen, "Bus Handler" circuit is used instead :
AcsRqDetect		: node; -- =new= "AccessReq" detected
AccessGrtd		: node; -- by 1clk after AccessReq, =1 during whole Operation
AddrSettled		: node; -- Flag: Address is (reliably) settled at AddrBus
--Target_Ready    : node; -- "OR" of all Addr.Comparators' registered outputs
BusOper1,
BusOper2,
BusOper3		: node; -- delay by 3 clocks
DataStrobe		: node; --Strobe: latch data into the destination object, and finish the Bus Oper-n

--******** =Local= bus for the ETHETNET module, "Bus Handler"
RdWr            : node; -- RdWr=1 ("Write") => Data: MainProj -> Ethernet
Addr_Settled    : node; -- Flag: Address is (reliably) settled at AddrBus
Data_Strobe	    : node; -- Strobe: latch data into the destination object, and finish the Bus Oper-n

--  signals of Address Comparators
DevSel[17..1]   : DFF ; -- Registered Addr_Comparator outputs for Selection

MainRAM_cs		: node; -- select for Rd/Wr from/to MainRAM
ProgRAM_cs		: node; -- ProgRAM is declared in Processor module 
CommandRAM_cs	: node; -- select for Rd/Wr from/to CommandList

Link_cs			: node;
OpCode_cs		: node;
--EvtNum_cs       : node;
TA12Channel_cs[NUM_CH-1..0]   : node;
Compres_cs		: node; 
DDREqu_cs[NUM_CH-1..0]		: node;
DDRNEqu_cs[NUM_CH-1..0]		: node;
BaseAddr_cs		: node;

--GateDur_cs		: node;
--GateDel_cs		: node;

ZERO_cs         : node; 

-- 10. Error counter

ErrorCounters_IFace			: ErrorCounters with (Width = 8);
ErrorCounters_IFace_CS		: node;
Sync_ES						: EdgeSensing;
PLL_PS						: PulseShaper;

--============================================================================
--******** 8. Test circuitry
TestCt			: lpm_counter WITH (LPM_width=26,           --\ Test Counter,
									LPM_direction="up");    --/   Blinking counter
--    TestCt_rst1 : node; --\ Cirquit for generating a _/^^\_ ,
--   TestCt_rst2 : node; --/   duration >=(1/2)Tquartz

TestRAM			: TestRAM_main;
TestRAM_cs		: node;
--============================================================================
BEGIN
DEFAULTS

PLLinst_S0	= VCC;
PLLinst_S1	= GND;
PLLinst_EN	= GND;

ADC_SEN[2..0]	= VCC;
ADC_SDATA[2..0]	= GND;
ADC_SCLK		= GND;

ExtRAM_Addr[15..0]		= GND;
ExtRAM_Data[15..0]		= GND;
ExtRAM_OutEn			= GND;
ExtRAM_InEn				= GND;
ExtRAM_WriteEn			= GND;
ExtRAM_LowerByteControl	= GND;
ExtRAM_UpByteControl	= GND;

REN		= GND; -- aee??eou/auee??eou auoiau Deserializer  
DEN		= VCC; -- aee??eou/auee??eou auoiau Serializer
RPWDN	= GND; -- aee??eou/auee??eou Deserializer  
TPWDN	= VCC; -- aee??eou/auee??eou Serializer

StartProc_Link  = GND;  StartADC_Link   = GND;
StopCount = GND;
St_Ether_Link = GND; EmptyMess = GND; Eth_WRITE = GND; St_EthTx_Ether  = GND;
Ether.TxLength[]= 0; Eth_InitAddr[] = 0;  

FLink_Error = GND;

END DEFAULTS;

--============================================================================
--******** 1. Reference Clock & Frequency Control ****************************

--============================================================================
--******** 1a. POWER_UP self-Reset pulse *************************************
--PowerUp0= DFF (.d=!(camac_s1 & camac_s2) AND PLL1.locked, .clk=Clk25);
        --               ^^^^^^^^ substituted by (CAMAC_IFace.Reset & CAMAC_IFace.Aout[4])..
        --  .. to provide a possibility to emulate PowerUp situation
PowerUp0 = DFF (.d=PLL.locked, .clk=Clk25); --!ExtReset AND 

PowerUp1 = SRFF(.s=(PowerUp0 AND (TestCt.q25 & TestCt.q0)),--sets 1.0s after PLL1 has locked
				.r=ExtReset, .clk=Clk25);  -- .r never =1
PowerUp2 = SRFF(.s=(PowerUp1 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);  -- .r never =1
PwrUpReset  = PowerUp1 AND !PowerUp2;   -- ONE pulse ~1sec after powering up

--******** 1b. POWER_UP self-Set pulse ***************************************
PowerUp3 = SRFF(.s=(PowerUp2 AND (!TestCt.q20 & !TestCt.q19 &  TestCt.q18)), --sets 0.015s after PwrUpReset
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PowerUp4 = SRFF(.s=(PowerUp3 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PwrUpSet1   = PowerUp3 AND !PowerUp4;       -- ONE pulse ~0.06sec after PwrUpReset

--******** 1c. POWER_UP self-Set pulse ***************************************
PowerUp5 = SRFF(.s=(PowerUp4 AND ( TestCt.q20 & !TestCt.q19 & !TestCt.q18)), --sets 0.060s after PwrUpReset
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PowerUp6 = SRFF(.s=(PowerUp5 AND TestCt.q2),             -- _/^^^^\_ 3clocks
				.r=ExtReset, .clk=Clk25);      -- .r never =1
PwrUpSet2 = PowerUp3 AND !PowerUp4;       -- ONE pulse ~0.06sec after PwrUpReset

--**************** Automatic Clock Switch for PLL reference ******************
PhaseSw.clock	= FQuartz ;         -- 25MHz from Quartz
PhaseSw.LinkClk	= LinkClk ;         -- 25MHz from Link
PhaseSw.Reset	= GND  ;
--    Phase25     = PhaseSw.Phase25 ; -- selected clock output to real pin
Sw_LinkClk		= !PhaseSw.LinkClk_selected; -- connects Link's Clock to PLL ref.Input
Sw_Quartz		= PhaseSw.LinkClk_selected; -- connects Quartz to PLL ref.Input

IF (PhaseSw.LinkClk_selected == VCC) Then PLL_res = FQuartz;
									 Else PLL_res = LinkClk;
END IF;

--**************** PLL section ***********************************************
PLL.inclk0	= PLL_in;           -- ~25MHz from Link -> Input of PLL
Clk25		= PLL.c0;           --  25MHz = (Fin x 1)    from PLL.c0
Clk100		= GLOBAL(PLL.c1);   -- 100MHz = (Fin x 4)    from PLL.c1
Clk50		= GLOBAL(PLL.c2);   -- 150MHz = (Fin x 2)    from PLL.c1
--Clk75		= GLOBAL(PLL.c4);   -- 75MHz = (Fin x 3)    from PLL.c1
Clk300_adc	= GLOBAL(PLL.c4);
PLL_ExtOut	= PLL.c3;           --  25MHz -> outside of Altera
--PLL1.pfdena = VCC;--!Reset;
--        = PLL.locked;           -- connected below

--**************** Synchro-signals generation ********************************
--  25MHz Clock ^\_______________/^^^^^^^^^^^^^^^\_______________/^^^^^^
-- 100MHz Clock _/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\___/^^^\__
--                           ^-this falling edge is selected
--    Clk25Del1 ^^^^^^\_______________/^^^^^^^^^^^^^^^\_______________/^
--    Clk25Del2 ^^^^^^^^^^^^^^\_______________/^^^^^^^^^^^^^^^\_________
--    Phase12   __________________/^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\_____synchronized with actual _/ of StartBit
--    Synchro12 _____________/^^^^^^^\__________________________________aligned to actual _/ of StartBit
--    Synchro25 _____________/^^^^^^^\_______________________/^^^^^^^\__aligned to actual _/ of StartBit and to half-PHASE

Clk25Del1	= DFF(.d=Clk25,    .clk=!Clk100); 
Clk25Del2	= DFF(.d=Clk25Del1,.clk=!Clk100); 

PhaseSet	= EdgeSensing(.d=Link_IFace.LinkMessage, -- must be aligned: 
						.clk=Clk100, .reset=RESET); -- 8 or 16 "Clk100"clocks after actual _/ of StartBit
Phase12		= DFFE(.d=!Phase12,.clk=Clk100, .ena=(!Clk25Del1 & !Clk25Del2),
					.prn=!PhaseSet);            -- F = (2*Fphase)/2 , _/ aligned to Phase
                    -- ^^^^ excluded temporary !!

Synchro12	= DFF(.d=(!Clk25Del1 & Clk25Del2 & !Phase12), .clk=!Clk100 );
Synchro25	= DFF(.d=(!Clk25Del1 & Clk25Del2), .clk=!Clk100 );

--********************************** Iauee noii ***********************************	
--Event_ES_Beg.(d,clk)  = (!LinkData%ia?aue aeo aoiaiie iinueee, io?ii eni?aaeou% AND !Event_Trig.q, CLK100); -- Ii?aaaeaiea noa?oiaiai aeoa
--LinkMsg_Trig.(d,clk)  = (!Link_IFace.LinkMessage, CLK100);    
--Event_ES_End.(d,clk)  = (LinkMsg_Trig.q, CLK100);
--Event_Trig.(S,clk,R)  = (Event_ES_Beg.q, CLK100, Event_ES_End.q);

--Event_ES_Beg_.(d,clk) = (!LinkData%ia?aue aeo aoiaiie iinueee, io?ii eni?aaeou% AND !Event_Trig_.q, CLK50); -- Ii?aaaeaiea noa?oiaiai aeoa
--LinkMsg_Trig_.(d,clk) = (!Link_IFace.LinkMessage, CLK50);    
--Event_ES_End_.(d,clk) = (LinkMsg_Trig_.q, CLK50);
--Event_Trig_.(S,clk,R) = (Event_ES_Beg_.q, CLK50, Event_ES_End_.q);

--============================================================================
-- ******** 2. Indicators section ********************************************
--LedG = OPNDRN ( !( PLL.locked       --always "ON" => PLL locked to LinkClock
--    OR (!PLL.locked AND TestCt.q[25]) --blinks slowly => PLL locked to Quartz
--   %XOR LinkFlash.DirOut%) );       --short blinks by Link cycles
LedG = OPNDRN ( !(((PLL.locked AND  PhaseSw.LinkClk_Selected) --always "ON" => PLL locked to LinkClock
				OR (PLL.locked AND !PhaseSw.LinkClk_Selected AND TestCt.q[25])))); --blinks slowly => PLL locked to Quartz
--LedG = OPNDRN (!(TestCt.q[25]));
LinkFlash.(clock, event)= (CLK100, Link_IFace.LinkMessage);

LedB = OPNDRN( !(B_Flash.DirOut OR Busy));
--LedB = OPNDRN( !StopCount) ;    -- for TEST Only! - quick blink
B_Flash.(clock, event)  =(Clk100,Busy); -- Busy is defined in Control Unit section

EtherLed = OPNDRN( !(EtherTx_Flash.DirOut OR Ether.TxDataBlck));
EtherTx_Flash.(clock, event)  =(Clk100,Ether.TxDataBlck); -- Busy is defined in Control Unit section

LedR = R_Flash.LightOut;
--LedR = OPNDRN( TC.q[21] ) ;         -- for TEST Only! - quick blink
R_Flash.(clock, event)  =(Clk100,Error);-- Error is defined in Control Unit section
									
--============================================================================
--******** 3. LINK's Interface ***********************************************
%
LinkData    = TRI (!Link_IFace.LinkData_out, Link_IFace.TxRx);-- Output to Pin
Link_IFace.LinkData_in = !LinkData ;                          -- Input from Pin
LinkTxRx    =  ( Link_IFace.TxRx );     -- Tx/Rx control, High => Tx
%
Link_IFace.LinkData_in = (b2v_inst5.dataout AND !Link_IFace.TxRx);

b2v_inst2.i = !Link_IFace.LinkData_out;
b2v_inst3.(datain, oe) = (b2v_inst2.o, Link_IFace.TxRx);
b2v_inst4.(datain,oe) = (b2v_inst2.obar, Link_IFace.TxRx);
b2v_inst5.(datain, datain_b) = (LinkData_p, LinkData_n);

LinkData_p = b2v_inst3.dataout;
LinkData_n = b2v_inst4.dataout;

-- Project Bus Port
Link_IFace.Clock	=	Clk100 ;

--    = Link_IFace.IORq ;               -- Connected at Processor section
--    = Link_IFace.RdWr_out;            -- Connected at Processor section
--    = Link_IFace.LinkMessage ;        -- connected at "Control Unit" section

Link_IFace.DataBus_in[] = DataBus[] ;
--    = Link_IFace.DataBus_out[] ;      -- connected at "Internal Bus ..." section
Link_IFace.Select       = DevSel[4].q %OR DevSel[5].q% ;
Link_IFace.RdWr_in      = RW ;
Link_IFace.DataStrobe   = DataStrobe ;

Link_IFace.Reset        = RESET ;

--**** For TEST ONLY !! - temporary :
--IF ((Link_IFace.LinkMessage == VCC) AND 
--    (OpCodeSaved == GND) AND
--    (Link_IFace.IORq AND Link_IFace.RdWr_out) )
--    Then  DataBus[7..0]     = Link_IFace.OpCode_out[7..0] ;
--End IF;

--============================================================================
--******** 4. Control Unit section *******************************************

--**************** LINK Cycle proceeding units *******************************
--LinkCycleBeg= EdgeSensing(.D= Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);
--LinkCycleEnd= EdgeSensing(.D=!Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);

-- OpCode is stored into OpCode_Reg by any LinkOperation :
OpCode_load = LevelSensing(.D=Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);

-- Start an Action by Link command  (4-clock pulse)
Start_Link.(D, clk, reset)  = (Link_IFace.LinkMessage, Clk100, RESET);

IF (Link_IFace.LinkMessage == VCC)  then -- If VALID command received, 
	CASE  Link_IFace.OpCode_out[(CommandSize+Pause-1)..0] is -- recognizing the particular Operation :
		--WHEN  Read1  => BaseAddr[] = 24;        -- Read  1 word from Object
		--                StartProc_Link  = Start_Link.q;
		--WHEN  Write1 => BaseAddr[] = 88;        -- Write 1 word  to Object
		--                StartProc_Link  = Start_Link.q;
		WHEN  Read		=> BaseAddr[]	= 80;   --#145-"Read" (=<8words) from Objects 
						StartProc_Link	= Start_Link.q; -- Start up the Program
		WHEN  Write		=> BaseAddr[]	=192; --#154-"Write"(=<4words) to Objects
						StartProc_Link	= Start_Link.q; -- Start up the Program
		WHEN  Read62   => BaseAddr[]	=  2;-- #130-"Read":  Read 62 words from Object(s)
						StartProc_Link	= Start_Link.q;
		WHEN  Write8  => BaseAddr[]		= 160;-- #137-"Write": Write 8 words  to Object(s)
						StartProc_Link	= Start_Link.q;

		WHEN  StartRegul       =>    -- #193-"START_Normal" (?oaiea0)
						BaseAddr[] = 72;                -- Program: CommdList_Rd000 for test with new system
						StartProc_Link	= Start_Link.q; -- Start up the Program
						StartADC_Link	= SelCommdList_Trig.q;--Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr001 =>      -- #202-"Write by CommdLst001" (Caienu0)
						BaseAddr[] =100;                -- Program: CommdList_Wr001
						StartProc_Link  = Start_Link.q; -- Start up the Program

		WHEN  StartAlter       =>    -- #210-"START_Alternative" (?oaiea1)
						BaseAddr[]		= 28;           -- Program: CommdList_Rd010
						StartProc_Link	= Start_Link.q; -- Start up the Program
						StartADC_Link	= Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr011 =>      -- #217-"Write by CommdLst011" (Caienu1)
						BaseAddr[] =106;                -- Program: CommdList_Wr011
						StartProc_Link	= Start_Link.q; -- Start up the Program

		WHEN  CommdLst_Rd100   =>    -- #226-"Read by CommdLst100" (?oaiea2)
						BaseAddr[]		= 32;           -- Program: CommdList_Rd100
						StartProc_Link	= Start_Link.q; -- Start up the Program
						StartADC_Link	= Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr101 =>      -- #233-"Write by CommdLst101" (Caienu2)
						BaseAddr[] =112;                -- Program: CommdList_Wr101
						StartProc_Link	= Start_Link.q; -- Start up the Program

		WHEN  CommdLst_Rd110   =>    -- #241-"Read  by CommdLst_selected_by_InData" (?oaiea3)
						BaseAddr[]		= 36;           -- Program: CommdList_Rd_InData;
						StartProc_Link	= Start_Link.q; -- Start up the Program
						StartADC_Link	= Start_Link.q; -- Start up the Digitizing Cycle
		WHEN  CommdLst_Wr111 =>      -- #250-"Write by CommdLst111" (Caienu3)
						BaseAddr[] =118;                -- Program: CommdList_Wr111
						StartProc_Link	= Start_Link.q; -- Start up the Program

		WHEN  Rd_SelCommdLst =>     -- #198-"Read  by CommdLst_selected_by_InData"
						BaseAddr[]		= 72;           --Program: Rd_SelCommdList
						StartProc_Link	= Start_Link.q;          --Start up the Program
						StartADC_Link	= SelCommdList_Trig.q;--SelCommdList_Count.q; -- Start up the Digitizing Cycle
		WHEN  Wr_SelCommdLst =>     -- #205-"Write by CommdLst_selected_by_InData"
						BaseAddr[]	=153;           --Program: Wr_SelCommdList
						StartProc_Link	= Start_Link.q;          --Start up the Program
						StartADC_Link	= SelCommdList_Trig.q;--SelCommdList_Count.q; -- Start up the Digitizing Cycle

		WHEN OTHERS		=>	StartProc_Link	= GND;
							StartADC_Link	= GND;
    End CASE;
End IF ;

FOR i IN 0 TO (NUM_CH-1) GENERATE
	Busy    = Link_IFace.LinkMessage OR CPU.Working;
--			OR TA12Channel[i].Working %OR Loader.Working% ;
END GENERATE;

SelCommdList_Reg.(data[15..8],data[7],data[6..0]) = (B"00001100",SelCommdList_Trig3.q,B"0000000");
SelCommdList_Reg.(clock,load,enable) = (Clk100,VCC,VCC);

LinkMsg_beg = EdgeSensing(.D=Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET);
SelCommdList_Trig.(S,R,clk,clrn) = (TA12Channel[3].test1 AND LinkMsg_beg AND !SelCommdList_Trig.q, 
									EdgeSensing(.D=!Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET) AND SelCommdList_Trig.q AND SelCommdList_Trig3.q, Clk100, !RESET);
SelCommdList_Trig2.(d,clk) = (SelCommdList_Trig.q, Clk100);
SelCommdList_Trig3.(S,R,clk,clrn) = (LinkMsg_beg AND SelCommdList_Trig2.q, 
									EdgeSensing(.D=!Link_IFace.LinkMessage, .clk=Clk100, .reset=RESET) AND SelCommdList_Trig.q AND SelCommdList_Trig3.q, Clk100, !RESET);
%SelCommdList_Count.cnt_en = EdgeSensing(.D= SelCommdList_Trig.q, .clk=Clk100, .reset=RESET);
SelCommdList_Count.(clock,clk_en) = (Clk100, VCC);
%
Error   = Link_IFace.Error OR CPU.Error OR FLink_Error;

RESET   = PwrUpReset OR ExtReset ;

--============================================================================
--******** 4. ETHERNET Interface *********************************************

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  RECEIVER section  ************

Ether.RX_CLK = RxClk;   --Ether-Rx Clock: Ether module <- Rx-channel of Eth_Controller
Ether.RX_DV = RxDv;     --"DataValid"   : Ether module <- Rx-channel of Eth_Controller
Ether.COL = Col;        --"Collision"   : Ether module <-     -//-
Ether.CRS = Crs;        --"CarrierSense": Ether module <-     -//-
Ether.RXD[3..0] = RxD[3..0];--Data half-Byte: Ether mod <- Rx-channel of Eth_Controller

--This_Device' address (to be sent at SourceAddr field of the reply packets)
Ether.Saddr[48..1] = ThisDeviceAddr;--for Test: 0110011001100110....1000110011101111

--       = Ether.RxWaitSFD          --connected below Waiting for "StartFrameDelimiter"
--       = Ether.RxDestAddr         --connected below "DestinationAddr" is being received
--       = Ether.RxSourAddr         --connected below "SourceAddr" is being received
--       = Ether.RxPkLenTyp         --connected below "Length/Type" is being received
--       = Ether.RxDataBlck;        --connected below
--       = Ether.RxEndFrame;        --connected below
--       = Ether.RxLenTyp[16..1];   -- value of the "PkLength/Type" field
--       = Ether.RxLength[12..1];   -- resulting Length(Bytes) of the Data_Block (MSbit always =0 !)
--       = Ether.RxError;           --connected below

-- Strobe for writing all DWords of the Frame (Daddr,Saddr,PkLenType,DataBlock)..
EthWord_Rd  = Addr_Settled & !RdWr & Data_Strobe;   --.. into TestRAM

--************ Circuit which saves Ethernet' OpCode ****************************
Reg_EthOpCode.data[7..0]= Ether.DataBus_out[15..8]; -- 1st Byte becomes the MSB of the 1st DWord !
Reg_EthOpCode.(clock, enable, load) = (Clk100, EthOpCode_save, VCC); -- latch the 1st DWord received
Reg_EthOpCode.(aclr, sclr)          = (RESET OR Ether.TxFrameCRC, GND );

RxDBlkDel1  = DFF(.D=Ether.RxDataBlck, .clk=RxClk); --\_  RxDataBlck.. 
RxDBlkDel2  = DFF(.D=RxDBlkDel1,       .clk=RxClk); --/ .. delayed by 2 RxClocks
RxDBlkDel3  = DFF(.D=RxDBlkDel2,       .clk=Clk100);--\_ aligned to Clk100 and ..
RxDBlkDel4  = DFF(.D=RxDBlkDel3,       .clk=Clk100);--/ .. little more delay
EthOpCode_save  = (RxDBlkDel4 & !EthOpCode_saved)   -- 1st DWord of DataBlock
            AND EthWord_Rd;                         -- RdWr=0 => "Read" from ETHERNET
EthOpCode_saved = SRFF(.S=EthOpCode_save, .clk=Clk100,
                .R=(Ether.RxEndFrame # Reset)); 

--    = Ether.RxError;  -- connected ?? 
Ether.RESET = RESET; -- reset
--    = Ether.Test[8..1];       -- connected at the "Testing circuitry" section 

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  TRANSMITTER section  ************

Ether.TX_CLK = TxClk;           -- Ether-Tx Clock: "ETHERNET" <- Tx-chan of Eth_Controller
TxEn = Ether.TX_EN;             -- Initiate a Transmission
TxD[3..0] = Ether.TXD[3..0];    -- half-Bytes of Data -> Eth_Controller

Ether.StTransmit= StartEthTx;   -- StartEthTx is defined in "Control Unit" section
--Ether.TxLength[11.0] =      -- connected in "Control Unit" section
--      = Ether.TxStFrmDel
--      = Ether.TxPkLenTyp 
--      = Ether.TxDataBlck    -- connected below
--      = Ether.TxEndFrame;   -- connected in "ETHERNET Cycle proceeding units" section 
--      = Ether.TxError;      --connected in ??

-- Strobe for TestRAM' addr incrementation when reading out all DWords requested by ETHERNET
EthWord_Wr  = Addr_Settled & RdWr & Data_Strobe;  -- RdWr=1 => "Write" to ETHERNET

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--******** Data Read/Write from/to the =local= DataBus ********

--************ ETHERNET's Bus Port : *******************************************
Ether.Clock = Clk100; -- Clock Frequency MUST BE > 50MHz !!!!

--    = Ether.IORq;             -- Connected at "Bus Handler" sub-section
--    = Ether.RdWr_out;         -- Connected at "Bus Handler" sub-section
--Ether.DataBus_in[15..0] = TestRAM.q_a[];    -- data:  TestRAM -> Ethernet

Ether.Select  = Addr_Settled;   -- Ethernet is selected for local data reading/writing
Ether.RdWr_in = RdWr;           -- RdWr=0 => data will be read from Ethernet / RdWr=1 => data will be written to Ethernet
Ether.DataStrobe = Data_Strobe; -- input data must be latched while DataStrobe=1 
--    = Ether.DataBus_out[];    -- data:  Ethernet -> TestRAM (connected at "Test Memory" sub-section)

--************ (Local)Bus Handler : ********************************************
AcsRqDetect = EdgeSensing(.D=Ether.IORq, .clk=Clk100, .reset=RESET);
AccessGrtd	=SRFF(.S=AcsRqDetect,.clk=Clk100,.R=Data_Strobe, .clrn=!RESET); --=1 during whole Operation
Addr_Settled=SRFF(.S=(AccessGrtd & !Addr_Settled),                          --flag; enables "DevSel[]" triggers
						.clk=Clk100, .R=Data_Strobe, .clrn=!RESET); 
BusOper1    = DFF(.D=Addr_Settled,.clk=Clk100,.clrn=!(RESET OR Data_Strobe));-- delay by 1 clock
BusOper2    = DFF(.D=BusOper1,    .clk=Clk100,.clrn=!(RESET OR Data_Strobe));-- delay by 1 clock
BusOper3    = DFF(.D=BusOper2,    .clk=Clk100,.clrn=!(RESET OR Data_Strobe));-- delay by 1 clock
Data_Strobe = DFF(.D=BusOper3,    .clk=Clk100,.clrn=!RESET); -- 1-clk pulse

-- Ether.RW_out=0 => Data: MainProj -> Ethernet ("write") => RdWr=1 
-- Ether.RW_out=1 => Data: MainProj <- Ethernet ("read")  => RdWr=0
RdWr   = DFF(.D=!Ether.RdWr_out, .clk=Clk100);  

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--**************** ETHERNET Cycle proceeding units *****************************

CASE  Reg_EthOpCode.q[7..0] is  -- recognizing the particular Operation :
	WHEN  H"01" =>  -- "PING" command
		St_EthTx_Ether  = VCC;  -- Start up the Transmit
		Ether.TxLength[]=  64;  -- DataBlock length = 64Bytes
		Eth_InitAddr[]  = 2000;--b"00100000000";  -- initial addr of data to be transmitted 

	--WHEN  H"03" =>  -- "StartMulti" for sending Ethernet' frames" 
	--WHEN  H"04" =>  -- "STOP sending Ethernet' frames" 

	WHEN  H"05" =>  -- "Set LinkMask and TimeGap" 
		Eth_WRITE       = VCC;  -- Ethernet' "Write" Command received 
		--St_EthTx_Ether  = GND;  -- NO Transmit 

	WHEN  H"08" =>  -- "Write" data to TestRAM
		Eth_WRITE       = VCC;  -- Ethernet' "Write" Command received 
		--St_EthTx_Ether  = GND;  -- NO Transmit 

	WHEN  H"09" =>  -- "Read" data from TestRAM
		St_EthTx_Ether  = VCC;  -- Start up the Transmit
		--Ether.TxLength[]= 255;  -- DataBlock length = 256Bytes
		Ether.TxLength[]=  64;  -- DataBlock length - temporary
		Eth_InitAddr[]  = 128;  -- initial addr of data to be transmitted 

	WHEN OTHERS => St_EthTx_Ether   = GND;
		Ether.TxLength[]=   48;  -- Minimal DataBlock length
End CASE;

Eth_Reg_LinkOpCode.data[(CommandSize+Pause-1)..0]= Link_IFace.OpCode_out[(CommandSize+Pause-1)..0];
Eth_Reg_LinkOpCode.(clock, enable, load)= (Clk100, OpCode_load, VCC); -- catch data when RxOpCodeReload=1 
Eth_Reg_LinkOpCode.(aclr, sclr)			= (RESET OR EndEtherTx OR EtherLinkTimeCt.cout OR Reg_Block.q[0], GND);

Eth_Reg_LinkEvNumber.data[] = Link_IFace.InData_out[];
Eth_Reg_LinkEvNumber.(clock, enable, load)= (Clk100, Link_IFace.IORq, VCC); -- catch data when RxOpCodeReload=1 
Eth_Reg_LinkEvNumber.(aclr, sclr)		  = (RESET OR EndEtherTx OR EtherLinkTimeCt.cout OR Reg_Block.q[0], GND);

Reg_Block.sset = PwrUpSet1;
Reg_Block.(data, clock, enable, load) = (DataBus[0], Clk100,(DataStrobe & DevSel[15] & RW),VCC); -- latch the 1st DWord received

CASE Eth_Reg_LinkOpCode.q[7..0] is -- recognizing the particular Operation :
	WHEN StartRegul		 =>     -- #193-"START_Regular"        (+?oyoo Lst0)
		 St_Ether_Link	 = VCC;	--Start up Ethernet transmition with waveforms

	WHEN StartAlter		 =>     -- #210-"START_Alternative"    (+?oyoo Lst2)
		 St_Ether_Link	 = VCC;	--Start up Ethernet transmition with waveforms
		 EmptyMess		 = VCC;

	WHEN CommdLst_Rd100  =>     -- #226-"Read  by CommdLst100" (+?oyoo Lst4)
		 St_Ether_Link	 = VCC;	--Start up Ethernet transmition with waveforms
		 EmptyMess		 = VCC;

	WHEN CommdLst_Rd110	 =>     -- #241-"Read  by CommdLst110" (+?oyoo3)
		 St_Ether_Link	 = VCC;	--Start up Ethernet transmition with waveforms
		 EmptyMess		 = VCC;

	WHEN Others => 	
		 St_Ether_Link	 = GND;	--Start up Ethernet transmition with waveforms
		 EmptyMess		 = GND;
End CASE;
--Ether.DataBus_in[15..0] = TestRAM.q_a[];--TAWF_HistRAM.q_b[];--


IF (St_Ether_Link == VCC) Then
	CASE EthAddrCt.q is
--Channel 1
		When 0 => Ether.DataBus_in[15..0] = StatusPack.q[15..0];
		
		When 1 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 2 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 2
		When 256 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 257 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 3
		When 512 => Ether.DataBus_in[15..0] = StatusPack.q[15..0];
		
		When 513 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 514 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 4
		When 768 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 779 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 5
		When 1024 => Ether.DataBus_in[15..0] = StatusPack.q[15..0];
		
		When 1025 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 1026 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 6
		When 1280 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 1281 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
%--Channel 7
		When 1536 => Ether.DataBus_in[15..0] = StatusPack.q[15..0];
		
		When 1537 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 1538 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 8
		When 1792 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 1793 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 9
		When 2048 => Ether.DataBus_in[15..0] = StatusPack.q[15..0];
		
		When 2049 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 2050 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 10
		When 2304 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 2305 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 11
		When 2560 => Ether.DataBus_in[15..0] = StatusPack.q[15..0];
		
		When 2561 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 2562 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
--Channel 12
		When 2816 => Ether.DataBus_in[15..0] = (b"00000000", Eth_Reg_LinkOpCode.q[7..0]);
		
		When 2817 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
%		When others => Ether.DataBus_in[15..0] = TAWF_HistRAM.q_b[];--TestRAM.q_a[];--
	End case;
ELSIF (St_EthTx_Ether == VCC) Then
	%CASE EthAddrCt.q is
		When 0 => Ether.DataBus_in[15..0] = (b"00000000",StartEthTx_Cnt.q[7..0]);
		
--		When 1 => Ether.DataBus_in[15..0] = Eth_Reg_LinkEvNumber.q[];
		
		When others => Ether.DataBus_in[15..0] = TestRAM.q_a[];
	End case;%
	Ether.DataBus_in[15..0] = TAWF_HistRAM.q_b[];--TestRAM.q_a[];--
END IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--**************** START of an ETHERNET operation ******************************

-- "RxEndFrame" appears ONLY in case that the received Frame is addressed to ThisDevice. 
-- Ethernet' Transmitting START is delayed after the Ethernet' Receiving Cycle :
Delay_StEthTx.(D,clk,reset) = ((St_EthTx_Ether & Ether.RxEndFrame),Clk100,RESET);  -- Delay of Compulsive START
--StartEthTx_Ether.(D, clk,reset) =(Delay_StEthTx.q, Clk100, RESET);--PulseShaper

EtherLinkMessage.(S,clk,R,clrn) = (St_Ether_Link, Clk100, RESET, !(EndEtherTx OR EtherLinkTimeCt.cout));

EtherLinkTimeCt.(clock, clk_en, cnt_en, sclr) = (Clk25, VCC, St_Ether_Link AND !EtherLinkMessage.q, EtherLinkTimeCt.cout OR EtherLinkMessage.q);
--IF EtherLinkTimeCt.cout == VCC Then St_Ether_Link = GND;
--END IF;

EtherBank_1.(S,clk,R,clrn) = ((St_Ether_Link AND !(EtherBank_1.q OR EtherPause1.q OR EtherBank_2.q OR EtherPause2.q OR EtherBank_3.q OR EtherPause3.q)), 
																					Clk100, EtherPause1.q, !(RESET OR EtherLinkTimeCt.cout));

	EtherPause1.(S,clk,R,clrn) = (EtherBank_1.q AND Ether.TxFrameCRC, Clk100, EtherBankDelay.cout, !EtherLinkTimeCt.cout);

EtherBank_2.(S,clk,R,clrn) = (EtherPause1.q AND EtherBankDelay.cout, Clk100, EtherPause2.q, !(RESET OR EtherLinkTimeCt.cout));

	EtherPause2.(S,clk,R,clrn) = (EtherBank_2.q AND Ether.TxFrameCRC, Clk100, EtherBankDelay.cout, !EtherLinkTimeCt.cout);

EtherBank_3.(S,clk,R,clrn) = (EtherPause2.q AND EtherBankDelay.cout, Clk100, EtherPause3.q, !(RESET OR EtherLinkTimeCt.cout));

	EtherPause3.(S,clk,R,clrn) = (EtherBank_3.q AND Ether.TxFrameCRC, Clk100, EtherBankDelay.cout, !EtherLinkTimeCt.cout);

EtherBankDelay.(clock, clk_en, cnt_en, sclr) = (Clk100, VCC, EtherPause1.q OR EtherPause2.q OR EtherPause3.q, EtherBankDelay.cout);

IF EtherBank_1.q == VCC Then
		Ether.TxLength[]= 1024;	-- DataBlock length = 1024Bytes = 512 words
		Eth_InitAddr[]  = 0;	-- initial addr of data in WF Ram to be transmitted 
	ELSIF EtherBank_2.q == VCC Then
		Ether.TxLength[]= 1024;	-- DataBlock length = 1024Bytes = 512 words
		Eth_InitAddr[]  = 512;--512;	-- initial addr of data in WF Ram to be transmitted 
	ELSIF EtherBank_3.q == VCC Then
		Ether.TxLength[]= 1024;	-- DataBlock length = 1024Bytes = 512 words
		Eth_InitAddr[]  = 1024;--1024;	-- initial addr of data in WF Ram to be transmitted 
%	ELSIF EtherBank_4.q == VCC Then
		Ether.TxLength[]= 1024;	-- DataBlock length = 1024Bytes = 512 words
		Eth_InitAddr[]  = 1536;--1024;	-- initial addr of data in WF Ram to be transmitted 
	ELSIF EtherBank_5.q == VCC Then
		Ether.TxLength[]= 1024;	-- DataBlock length = 1024Bytes = 512 words
		Eth_InitAddr[]  = 2048;--1024;	-- initial addr of data in WF Ram to be transmitted 
	ELSIF EtherBank_6.q == VCC Then
		Ether.TxLength[]= 1024;	-- DataBlock length = 1024Bytes = 512 words
		Eth_InitAddr[]  = 2560;--1024;	-- initial addr of data in WF Ram to be transmitted 
%END IF; 

--StartEthTx_Link.(D, clk, reset) = ((!Link_IFace.LinkMessage & Delay_LinkMessage.q) AND Delay_St_Ether_Link.q, Clk100, RESET);
StartEthTx_Link.(D, clk, reset) = ((EtherBank_1.q OR EtherBank_2.q OR EtherBank_3.q) AND St_Ether_Link, Clk100, RESET);

StartEthTx  = ((StartEthTx_Link.q OR Delay_StEthTx.q) AND !Ether.TX_EN ); 

StartEthTx_Cnt.(clock, clk_en, cnt_en) = (Clk25%StartEthTx%, VCC, StartEthTx);

StatusPack.(clock, enable, load) = (Clk25, StartEthTx, VCC);
StatusPack.data[] = (StartEthTx_Cnt.q[], b"00000", EtherBank_3.q,EtherBank_2.q,EtherBank_1.q); 

IF ((EtherPause3.q == VCC) AND (EtherBankDelay.cout == VCC))
	Then EndEtherTx = VCC;
	Else EndEtherTx = GND;
END IF;

-- Counter which contains address for exchange between ETHERNET and TestRAM
EthAddrCt.(clock, clk_en) = (Clk100, VCC);
EthAddrCt.cnt_en= EthWord_Rd OR EthWord_Wr; -- increments simultaneously with real "Read" or "Write"
EthAddrCt.data[]= Eth_InitAddr[];
--EthAddrCt.sclr  = EdgeSensing(.D=(Ether.RxDataBlck  -- before receiving 1st DWord of Data Block
EthAddrCt.sclr	= EdgeSensing(.D=Ether.RxDestAddr,  -- before receiving 1st DWord of RxFrame
						.clk=Clk100, .reset=RESET) OR RESET;
EthAddrCt.sload	= EdgeSensing(.D=StartEthTx, -- at the beginning of Transmit Cycle
						.clk=Clk100, .reset=RESET);

--When ETHERNET' "WRITE" command => EtherWRITE=1 => write to TestRAM enabled 
EtherWRITE  = DFF(.D=Eth_WRITE, .clk=Clk100, .clrn=!(Ether.RxEndFrame # RESET)); 
--EtherWR_we  = EtherWRITE    -- Upon Ether' "WRITE" command, enables ETHERNET -> TestRAM
--            AND(Addr_Settled & !RdWr & Data_Strobe);-- RdWr=0 => "Read" from ETHERNET

--Ether.StTransmit = TA_proces[0].Data_ready; -- noa?o ia?aaa?e iaeaoa
--Ether.TxLength[15..0] = B"0000001100000000"; -- aeeia iaeaoa aaiiuo (noa?oee ?ac?ya anaaaa = 0)!

--============================================================================
--******** 5. Processor ******************************************************
CPU.Clock   = Clk100;   CPU.Sync    = Synchro25; 
CPU.ProgInit        = StartProc_Link ; 
CPU.BaseAddr[7..0]  = BaseAddr[7..0];
--CPU.Int[4..1]       = 
CPU.int1            = Link_IFace.IORq;
CPU.int4            = TestCt.q[25];

CPU.DataIn[]        = DataBus[];        -- Data Bus - input
--            = CPU.AddrOut[15..0]        -- \ connected in "Internal Bus"
--            = CPU.DataOut[15..0]        -- /                       section

--            = CPU.AccessReq ;           -- connected in "Internal Bus" section
--                    = CPU.RdWr;         -- connected in "Internal Bus" section
--CPU.AccessGranted   = AccessGtd;        -- connected in "Internal Bus" section
--CPU.DataStrobe      = DataStrobe;       -- connected in "Internal Bus" section

--            = CPU.Working;      -- connected below, in "Control Unit" section
--            = Error;            -- connected below, in "Control Unit" section
CPU.Reset   = RESET;            -- reset by MainRESET

-- Direct access to ProgRAM as to a part of common RAM
CPU.(ProgRAM_addr[ 7..0],ProgRAM_data[15..0]) = (AddrBus[7..0], DataBus[]);
CPU.ProgRAM_we  = DataStrobe & DevSel[2] & RW;
--            = CPU.ProgRAM_q[];  -- connected in "Internal Bus" section

--============================================================================
-- RAM blocks, Registers

MainRAM.(address[7..0], data[],    clock,    wren                     ) =
        (AddrBus[7..0], DataBus[], Clk100,(DataStrobe & DevSel[1] & RW)); 
--ProgRAM belongs to "Processor"unit, and is defined there
CommandRAM.(address[9..0], data[], clock,    wren                     ) =
        (AddrBus[9..0], DataBus[], Clk100,(DataStrobe & DevSel[3] & RW)); 

--************ Circuit which saves OpCode ************
Reg_OpCode.data[(CommandSize+Pause-1)..0]= Link_IFace.OpCode_out[(CommandSize+Pause-1)..0];
Reg_OpCode.(clock, enable, load)= (Clk100, OpCode_load, VCC); -- catch data when RxOpCodeReload=1 
Reg_OpCode.(aclr, sclr)         = (RESET, GND );

Reg_BaseAddr.data[7..0]     = DataBus[7..0];
Reg_BaseAddr.(clock,enable) =(Clk100, (DataStrobe & DevSel[13] & RW));
Reg_BaseAddr.(load, aclr)   = (VCC, RESET);

--============================================================================
--******** 6. Digitizers section *********************************************

--Only for test
--============================================================================
-- Im_ADC - a RAM which contains data substituted for the ADC data (Oanoiaay iaiyou aey i?iaa?ee aeai?eoia)
%	Im_ADC.data_a[] = GND;
	Im_ADC.(address_a[], clock_a, wren_a) = (Im_ADCCt.q[7..0], ADC_Clock, GND);
	
--	Im_ADC.(data_b[],address_b[], clock_b)= (DataBus_In[],Im_RAMAddrBus[7..0], Bus_clock);
	Im_ADC.(data_b[],address_b[], clock_b)= (DataBus_In[],AddrBus_In[7..0], Bus_clock);
	Im_ADC.wren_b = DataBusStrobe and  DirectIn AND Select AND Ram_SeL[0];
	
	Im_ADCCt.clock   = ADC_Clock;
	Im_ADCCt.sclr = !Working;
--	Im_ADCCt.clk_en  = VCC;
--	Im_ADCCt.cnt_en = GN;
--	Im_RAMAddrBus[7..0] = AddrBus_In[7..0] + Im_ADCCt.q[7..0]; -- aunoaaeaiea aa?ana a 0 aey oaeouaai iaai?a FOR-ia
%
--============================================================================

FOR i IN 0 TO (NUM_CH-1) GENERATE

	TA12Channel[i].Bus_Clock		= Clk100; -- Clock 100MHz
	TA12Channel[i].ADC_Clock		= Clk100; -- Clock 100MHz
	TA12Channel[i].Flink_clock		= Clk25;

	TA12Channel[i].DigitInit		= StartADC_Link;--PwrUpSet1;-- initiates Cycle: Digitizing and store the results in ADC_RAM
	TA12Channel[i].RegInit			= PwrUpSet1;
	TA12Channel[i].Reset			= RESET; -- reset by MainRESET

	FOR j in 0 to 1 GENERATE

		DDR_InLVDS[i][j].(datain, inclock, aclr) = (ADC_In_Data[i][j], Clk300_adc, Reset);
		DDR_Reg_pos[i][j].(shiftin, clock, enable, load) = (DDR_InLVDS[i][j].dataout_h, Clk300_adc, VCC, GND);
		DDR_Reg_neg[i][j].(shiftin, clock, enable, load) = (DDR_InLVDS[i][j].dataout_l, Clk300_adc, VCC, GND);

	END GENERATE;

	InData_RegMix[i].(clock, enable, load) = (Clk100, VCC, VCC);
-- Cauaeeeaaiea aeoia a ii?aaaeaiiie iineaaiaaoaeuiinoe.
	InData_RegMix[i].data[11..0] = (DDR_Reg_pos[i][1].q[2],DDR_Reg_neg[i][1].q[2],DDR_Reg_pos[i][0].q[2],DDR_Reg_neg[i][0].q[2],
									DDR_Reg_pos[i][1].q[1],DDR_Reg_neg[i][1].q[1],DDR_Reg_pos[i][0].q[1],DDR_Reg_neg[i][0].q[1],
									DDR_Reg_pos[i][1].q[0],DDR_Reg_neg[i][1].q[0],DDR_Reg_pos[i][0].q[0],DDR_Reg_neg[i][0].q[0]);
	InData_Reg[i].(clock, enable, load) = (Clk100, VCC, VCC);
-- Cauaeeeaaiea aeoia a ii?aaaeaiiie iineaaiaaoaeuiinoe.
	InData_Reg[i].data[11..0] = (InData_RegMix[i].q[5],InData_RegMix[i].q[2],InData_RegMix[i].q[3],InData_RegMix[i].q[0],
								InData_RegMix[i].q[5],InData_RegMix[i].q[2],InData_RegMix[i].q[3],InData_RegMix[i].q[0],
								InData_RegMix[i].q[1],InData_RegMix[i].q[6],InData_RegMix[i].q[7],InData_RegMix[i].q[4]);

	TA12Channel[i].ADCdata[]		 = InData_Reg[i].q[];
	TA12Channel[i].DataBus_In[15..0] = DataBus[15..0];
	TA12Channel[i].AddrBus_In[9..0]  = AddrBus[9..0] ;

	TA12Channel[i].DataBusStrobe		= DataStrobe ;
	TA12Channel[i].DirectIn			= RW;
	TA12Channel[i].Select			= DevSel[5+i].q ;
	TA12Channel[i].LinkMessage		= Link_IFace.LinkMessage;
	TA12Channel[i].WriteRAM			= SelCommdList_Trig.q;--SelCommdList_Count.q;

END GENERATE;
--Working,        -- connected in "Control Unit" section
--Error,          -- connected in "Control Unit" section

----- Ethernet WF_HIST Tx to DAQ

CASE Eth_Reg_LinkOpCode.q[7..0] is -- recognizing the particular Operation :
	WHEN StartRegul		 =>     -- #193-"START_Regular"        (+?oyoo Lst0)
		 StartWFTx_Eth	 = VCC;	--Start up Ethernet transmition with waveforms
	WHEN Others => 	
		 StartWFTx_Eth	 = GND;	--Start up Ethernet transmition with waveforms
End CASE;

DelayWriteWFhist_Eth.(D,clk,reset) = (StartWFTx_Eth, Clk100, Reset);
Delay_EthMessage.(D,clk) = (DelayWriteWFhist_Eth.q, Clk100);
TxWFhist_Eth.(S, clk, R, clrn) = (DelayWriteWFhist_Eth.q AND !Delay_EthMessage.q, Clk100, GND, !StopCount_Eth);

FOR i IN 0 TO (NUM_CH-1) GENERATE
	TA12Channel[i].WriteWFhist_Eth = !TxWFhist_Eth.q;--TestLinkCt.q[11];--Link_IFace.LinkMessage;
END GENERATE;

--DataCount.(clock, cnt_en, sclr) = (Clk25, Link_IFace.LinkMessage, !Link_IFace.LinkMessage);
--ChannelCount.(clock, cnt_en, sclr) = (Clk25, DataCount.cout, !Link_IFace.LinkMessage);
DataCount_Eth.(clock, cnt_en, sclr) = (Clk100, TxWFhist_Eth.q, StopCount_Eth);
ChannelCount_Eth.(clock, cnt_en, sclr) = (Clk100, DataCount_Eth.cout, StopCount_Eth);
IF (ChannelCount_Eth.q[] == b"1011" AND DataCount_Eth.q[] == VCC )
	THEN StopCount_Eth = VCC;
	ELSE StopCount_Eth = GND;
END IF;

TAWF_HistRAM.data_a[15..12] = GND;
TAWF_HistRAM.(address_a[],			wren_a		,	clock_a) =	--\ for common
			 (TAWF_HistRAM_Cnt.q[], TxWFhist_Eth.q, Clk100);	-- > access
TAWF_HistRAM.(enable_a) = (VCC); 

TAWF_HistRAM_Cnt.(clock, cnt_en, sclr) = (Clk100, TxWFhist_Eth.q %AND !EtherLinkMessage.q%, !TxWFhist_Eth.q);

TAWF_HistRAM.(address_b[],		 data_b[],				wren_b ) =	--\ for local access 
			 (EthAddrCt.q[10..0], Ether.DataBus_out[], EthWord_Rd);	--/ from inside of "Ethernet" section

TAWF_HistRAM.(clock_b, enable_b) = (Clk100, VCC);

CASE ChannelCount_Eth.q[] IS 
	When b"0000" => TA12Channel[0].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[0].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[0].ReadWFhist_Eth			= TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[0].DAQDataBusOut_Eth[11..0];
	When b"0001" => TA12Channel[1].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[1].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[1].ReadWFhist_Eth			= TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[1].DAQDataBusOut_Eth[11..0];
	When b"0010" => TA12Channel[2].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[2].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[2].ReadWFhist_Eth			= TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[2].DAQDataBusOut_Eth[11..0];
	When b"0011" => TA12Channel[3].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[3].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[3].ReadWFhist_Eth			= TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[3].DAQDataBusOut_Eth[11..0];
	When b"0100" => TA12Channel[4].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[4].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[4].ReadWFhist_Eth			= TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[4].DAQDataBusOut_Eth[11..0];
	When b"0101" => TA12Channel[5].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[5].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[5].ReadWFhist_Eth			= TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[5].DAQDataBusOut_Eth[11..0];
	When b"0110" => TA12Channel[6].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[6].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[6].ReadWFhist_Eth		  = TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[6].DAQDataBusOut_Eth[11..0];
	When b"0111" => TA12Channel[7].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[7].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[7].ReadWFhist_Eth		  = TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[7].DAQDataBusOut_Eth[11..0];
	When b"1000" => TA12Channel[8].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[8].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[8].ReadWFhist_Eth		  = TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[8].DAQDataBusOut_Eth[11..0];
	When b"1001" => TA12Channel[9].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[9].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[9].ReadWFhist_Eth		  = TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[9].DAQDataBusOut_Eth[11..0];
	When b"1010" => TA12Channel[10].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[10].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[10].ReadWFhist_Eth		  = TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[10].DAQDataBusOut_Eth[11..0];
	When b"1011" => TA12Channel[11].DAQAddrBus_Eth_In[7..0] = DataCount_Eth.q[];
					TA12Channel[11].DAQAddrBus_Eth_In[8] = GND;
					TA12Channel[11].ReadWFhist_Eth		  = TxWFhist_Eth.q;
					TAWF_HistRAM.data_a[11..0] = TA12Channel[11].DAQDataBusOut_Eth[11..0];
	When others =>
					TA12Channel[0].ReadWFhist_Eth		  = GND;
					TA12Channel[1].ReadWFhist_Eth		  = GND;
					TA12Channel[2].ReadWFhist_Eth		  = GND;
					TA12Channel[3].ReadWFhist_Eth		  = GND;
					TA12Channel[4].ReadWFhist_Eth		  = GND;
					TA12Channel[5].ReadWFhist_Eth		  = GND;
					TA12Channel[6].ReadWFhist_Eth		  = GND;
					TA12Channel[7].ReadWFhist_Eth		  = GND;
					TA12Channel[8].ReadWFhist_Eth		  = GND;
					TA12Channel[9].ReadWFhist_Eth		  = GND;
					TA12Channel[10].ReadWFhist_Eth		  = GND;
					TA12Channel[11].ReadWFhist_Eth		  = GND;
					TA12Channel[0].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[1].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[2].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[3].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[4].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[5].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[6].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[7].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[8].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[9].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[10].DAQAddrBus_Eth_In[8..0] = GND;
					TA12Channel[11].DAQAddrBus_Eth_In[8..0] = GND;

END Case;

Compres.(trigger, CLOCK_100) = (Link_IFace.LinkMessage, clk100);
Compres.(cs, Read_Write, thr_in[7..0]) = (DevSel[11].q, RW, DataBus[7..0]);

CASE Compres.en_ROM[] IS
	When b"0000" => TA12Channel[0].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in0[11..0] = TA12Channel[0].DAQDataBusOut_Eth[11..0];
	When b"0001" => TA12Channel[1].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in1[11..0] = TA12Channel[1].DAQDataBusOut_Eth[11..0];
	When b"0010" => TA12Channel[2].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in2[11..0] = TA12Channel[2].DAQDataBusOut_Eth[11..0];
	When b"0011" => TA12Channel[3].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in3[11..0] = TA12Channel[3].DAQDataBusOut_Eth[11..0];
	When b"0100" => TA12Channel[4].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in4[11..0] = TA12Channel[4].DAQDataBusOut_Eth[11..0];
	When b"0101" => TA12Channel[5].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in5[11..0] = TA12Channel[5].DAQDataBusOut_Eth[11..0];
	When b"0110" => TA12Channel[6].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in6[11..0] = TA12Channel[6].DAQDataBusOut_Eth[11..0];
	When b"0111" => TA12Channel[7].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in7[11..0] = TA12Channel[7].DAQDataBusOut_Eth[11..0];
	When b"1000" => TA12Channel[8].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in8[11..0] = TA12Channel[8].DAQDataBusOut_Eth[11..0];
	When b"1001" => TA12Channel[9].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in9[11..0] = TA12Channel[9].DAQDataBusOut_Eth[11..0];
	When b"1010" => TA12Channel[10].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in10[11..0] = TA12Channel[10].DAQDataBusOut_Eth[11..0];
	When b"1011" => TA12Channel[11].DAQAddrBus_Eth_In[7..0] = Compres.add_ROM[7..0];
					Compres.data_in11[11..0] = TA12Channel[11].DAQDataBusOut_Eth[11..0];
	When others => TA12Channel[0].DAQAddrBus_Eth_In[7..0] = GND;
					Compres.data_in0[11..0] = GND;
END Case;

ExtRAM_Addr[15..0]		= Compres.ram_ADDR[15..0];
ExtRAM_Data[15..0]		= Compres.ram_DATA[15..0];
ExtRAM_OutEn			= Compres.ram_OE_N;
ExtRAM_InEn				= Compres.ram_CE_N;
ExtRAM_WriteEn			= Compres.ram_WE_N;
ExtRAM_LowerByteControl	= Compres.ram_LB_N;
ExtRAM_UpByteControl	= Compres.ram_UB_N;

--============================================================================
--******** 7. Fust LINK's Interface *******************************************

--FLink_Sync = TestCt.q[25];

--************************** Ia?aaa?a aaiiuo a IPT ***************************** 

FLink_Reg_LinkOpCode.data[(CommandSize+Pause-1)..0]= Link_IFace.OpCode_out[(CommandSize+Pause-1)..0];
FLink_Reg_LinkOpCode.(clock, enable, load)= (Clk100, OpCode_load, VCC); -- catch data when RxOpCodeReload=1 
FLink_Reg_LinkOpCode.(aclr, sclr)			= (StopCount, GND);

CASE FLink_Reg_LinkOpCode.q[7..0] is -- recognizing the particular Operation :
	WHEN StartRegul		 =>     -- #193-"START_Regular"        (+?oyoo Lst0)
		 StartWFTx	 = VCC;	--Start up Ethernet transmition with waveforms
	WHEN Others => 	
		 StartWFTx	 = GND;	--Start up Ethernet transmition with waveforms
End CASE;

--Clk37_5 = DFF (.d = !Clk37_5, .clk = Clk75);
SerClk = Clk25;--Clk50;--Clk37_5;--
DelayWriteWFhist.(D,clk,reset) = (StartWFTx, Clk100, Reset);
Delay_LinkMessage.(D,clk) = (DelayWriteWFhist.q, Clk100);
TxWFhist.(S, clk, R, clrn) = (DelayWriteWFhist.q AND !Delay_LinkMessage.q, Clk100, GND, !StopCount);
TAWF_DataStrobe = TxWFhist.q;

FOR i IN 0 TO (NUM_CH-1) GENERATE
	TA12Channel[i].WriteWFhist = !TxWFhist.q;--TestLinkCt.q[11];--Link_IFace.LinkMessage;
END GENERATE;

--DataCount.(clock, cnt_en, sclr) = (Clk25, Link_IFace.LinkMessage, !Link_IFace.LinkMessage);
--ChannelCount.(clock, cnt_en, sclr) = (Clk25, DataCount.cout, !Link_IFace.LinkMessage);
DataCount.(clock, cnt_en, sclr) = (Clk25, TxWFhist.q, StopCount);
ChannelCount.(clock, cnt_en, sclr) = (Clk25, DataCount.cout, StopCount);
IF (ChannelCount.q[] == b"0101" AND DataCount.q[] == VCC )
	THEN StopCount = VCC;
	ELSE StopCount = GND;
END IF;

NWordCount.(clock, cnt_en) = (Clk25, VCC);
FLink_Data_BUS.data[11..10] = NWordCount.q[];
FLink_Data_BUS.clock = Clk25;
SerDataOut[13..10] = b"1010";
IF (TxWFhist.q == GND) Then --Link_IFace.LinkMessage == GND Then
	--FLink_Data_BUS.data[5..0]	= (VCC,GND,VCC,GND,VCC,GND);--TA12Channel[5..0].EventFound;	-- Trigger efficiency check
	--FLink_Data_BUS.data[9..6]	= (VCC,GND,VCC,GND);--TA12Channel[4..0].EventFound;
	SerDataOut[9..0] = (VCC,GND,VCC,GND,VCC,GND,VCC,GND,VCC,GND);
	NWordFLink[] = NWordCount.q[];
Else 
--	SerDataOut[9..0] = (ChannelCount.q[1..0],DataCount.q[]);--TestLinkCt.q[9..0];--
--	NWordFLink[] = (GND,ChannelCount.q[2]);
	CASE ChannelCount.q[] IS 
		 When b"0000" => TA12Channel[0].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[0].DAQAddrBus_In[8] = GND;
						TA12Channel[0].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[0].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[0].DAQDataBusOut[11..10];
		 When b"0001" => TA12Channel[1].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[1].DAQAddrBus_In[8] = GND;
						TA12Channel[1].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[1].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[1].DAQDataBusOut[11..10];
		 When b"0010" => TA12Channel[2].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[2].DAQAddrBus_In[8] = GND;
						TA12Channel[2].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[2].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[2].DAQDataBusOut[11..10];
		 When b"0011" => TA12Channel[3].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[3].DAQAddrBus_In[8] = GND;
						TA12Channel[3].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[3].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[3].DAQDataBusOut[11..10];
		 When b"0100" => TA12Channel[4].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[4].DAQAddrBus_In[8] = GND;
						TA12Channel[4].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[4].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[4].DAQDataBusOut[11..10];
		 When b"0101" => TA12Channel[5].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[5].DAQAddrBus_In[8] = GND;
						TA12Channel[5].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[5].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[5].DAQDataBusOut[11..10];
		 When b"0110" => TA12Channel[6].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[6].DAQAddrBus_In[8] = GND;
						TA12Channel[6].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[6].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[6].DAQDataBusOut[11..10];
		 When b"0111" => TA12Channel[7].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[7].DAQAddrBus_In[8] = GND;
						TA12Channel[7].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[7].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[7].DAQDataBusOut[11..10];
		 When b"1000" => TA12Channel[8].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[8].DAQAddrBus_In[8] = GND;
						TA12Channel[8].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[8].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[8].DAQDataBusOut[11..10];
		 When b"1001" => TA12Channel[9].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[9].DAQAddrBus_In[8] = GND;
						TA12Channel[9].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[9].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[9].DAQDataBusOut[11..10];
		 When b"1010" => TA12Channel[10].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[10].DAQAddrBus_In[8] = GND;
						TA12Channel[10].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[10].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[10].DAQDataBusOut[11..10];
		 When b"1011" => TA12Channel[11].DAQAddrBus_In[7..0] = DataCount.q[];
						TA12Channel[11].DAQAddrBus_In[8] = GND;
						TA12Channel[11].ReadWFhist		  = TxWFhist.q;
						SerDataOut[9..0] = TA12Channel[11].DAQDataBusOut[9..0];
						NWordFLink[] = TA12Channel[11].DAQDataBusOut[11..10];
		 WHEN OTHERS => FLink_Error = VCC;
						TA12Channel[0].ReadWFhist		  = GND;
						TA12Channel[1].ReadWFhist		  = GND;
						TA12Channel[2].ReadWFhist		  = GND;
						TA12Channel[3].ReadWFhist		  = GND;
						TA12Channel[4].ReadWFhist		  = GND;
						TA12Channel[5].ReadWFhist		  = GND;
						TA12Channel[6].ReadWFhist		  = GND;
						TA12Channel[7].ReadWFhist		  = GND;
						TA12Channel[8].ReadWFhist		  = GND;
						TA12Channel[9].ReadWFhist		  = GND;
						TA12Channel[10].ReadWFhist		  = GND;
						TA12Channel[11].ReadWFhist		  = GND;
						TA12Channel[0].DAQAddrBus_In[8..0] = GND;
						TA12Channel[1].DAQAddrBus_In[8..0] = GND;
						TA12Channel[2].DAQAddrBus_In[8..0] = GND;
						TA12Channel[3].DAQAddrBus_In[8..0] = GND;
						TA12Channel[4].DAQAddrBus_In[8..0] = GND;
						TA12Channel[5].DAQAddrBus_In[8..0] = GND;
						TA12Channel[6].DAQAddrBus_In[8..0] = GND;
						TA12Channel[7].DAQAddrBus_In[8..0] = GND;
						TA12Channel[8].DAQAddrBus_In[8..0] = GND;
						TA12Channel[9].DAQAddrBus_In[8..0] = GND;
						TA12Channel[10].DAQAddrBus_In[8..0] = GND;
						TA12Channel[11].DAQAddrBus_In[8..0] = GND;
	END CASE;
END IF;


--FLink_Data_BUS.data[11..0] = (!ADC_In_Data[1][11],ADC_In_Data[1][10..0]);

--SerDataOut[9..0] = FLink_Data_BUS.q[9..0]; --TestLinkCt.q[9..0];--
--FLink_Data_BUS.q[11..10];--

TestLinkCt.(clock, clk_en)	= (Clk25, VCC); -- Test Counter, can be used to drive LED blinking
TestLinkCt.cnt_en			= PowerUp0;
TestLinkCt.aclr				= !PowerUp0;    -- even if NO clock - Reset does occur
----------For tests with Ser/Deser
%
IF (TestLinkCt.q[18] == VCC) 
	THEN SerDataOut[3..0] = VCC;--TestLinkCt.q[7];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[7..4] = VCC;--TestLinkCt.q[8];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[9..8] = GND;--TestLinkCt.q[9];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 NWordFLink[] = GND;--TestLinkCt.q[9];--(VCC,GND);--FLink_Data_BUS.q[11..10];
	ELSE SerDataOut[3..0] = GND;--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[7..4] = TestLinkCt.q[8];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 SerDataOut[9..8] = TestLinkCt.q[9];--FLink_Data_BUS.q[9..0];--b"1010000111";--
		 NWordFLink[] = TestLinkCt.q[9];--(VCC,GND);--FLink_Data_BUS.q[11..10];
END IF;
%
%
OutData.(tx_in[], tx_inclock) = (FLink_Data_BUS.q[11..0], Clk25);
DataOutLVDS_TA = OutData.tx_out[];
%
--============================================================================
--******** 8. Error counter **************************************************

-- Project Bus Port, common
	ErrorCounters_IFace.clock 			=	CLK100;
	ErrorCounters_IFace.AddrBusIn[3..0]	=	AddrBus[3..0];
	ErrorCounters_IFace.DataBusStrobe	=	DataStrobe ;
-- Project Bus Port, Slave
	--ErrorCounters_IFace.DirectIn		= 	RW;
	ErrorCounters_IFace.Select			= 	DevSel[14].q;

	ErrorCounters_IFace.ErrorInputs[0]	=	CPU.Error;--Bus_Arbiter.ErrorLight;
	ErrorCounters_IFace.ErrorInputs[1]	=	Error;
	ErrorCounters_IFace.ErrorInputs[2]	=	Link_IFace.Error;
	ErrorCounters_IFace.ErrorInputs[3]	=	Link_IFace.Error;
	ErrorCounters_IFace.ErrorInputs[4]	=	FLink_Error;
	ErrorCounters_IFace.ErrorInputs[5]	=	FLink_Error;
	ErrorCounters_IFace.ErrorInputs[6]	=	Error;--Sync_ES.q;
	ErrorCounters_IFace.ErrorInputs[7]	=	GND;--(TA12Channel0.Error OR TA12Channel1.Error OR TA12Channel2.Error OR TA12Channel3.Error OR TA12Channel4.Error OR TA12Channel5.Error);
--	ErrorCounters_IFace.ErrorInputs[9]	=	(ADC_OR0 OR ADC_OR1 OR ADC_OR2 OR ADC_OR3 OR ADC_OR4 OR ADC_OR5);--PLL_PS.q;
%
	Sync_ES.(d,clk)  = (FLink_Lock, CLK100);

	PLL_PS.(d,clk,clr,Shaping_Time[]) = (PLL.locked,FLCLK,GND,B"11111010");
%
--============================================================================
-- 9. Internal Bus of Project & Data transfer control ************************

AddrBus[15..0]	= CPU.AddrOut[15..0];   -- CPU is the only Master, rules forever
RW				= CPU.RdWr ;            -- y?y??ouoyoo yo?oo??o
CPU.AccessGranted	= AccessGrtd;       -- 
CPU.DataStrobe		= DataStrobe;       -- connected in "Control Unit" section

-- Bus Handler : 
AcsRqDetect = EdgeSensing(.D=CPU.AccessReq, .clk=Clk100, .reset=RESET);
AccessGrtd	=SRFF(.S=AcsRqDetect,.clk=Clk100, .r=DataStrobe, .clrn=!RESET); --=1 during whole Operation
AddrSettled =SRFF(.S=(AccessGrtd & !AddrSettled),                           --flag; enables "DevSel[]" triggers
						.clk=Clk100, .r=DataStrobe, .clrn=!RESET); 
BusOper1	= DFF(.D=AddrSettled,.clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
BusOper2	= DFF(.D=BusOper1,   .clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
BusOper3	= DFF(.D=BusOper2,   .clk=Clk100,.clrn=!(RESET OR DataStrobe)); -- delay by 1 clock
DataStrobe	= DFF(.D=BusOper3,   .clk=Clk100,.clrn=!RESET); -- 1-clk pulse

-- When Address from Master is set on the Address Bus, ...
-- DEVICE SELECTION - the Slave-device is identified by its Address 

-- 1) Main RAM, Program RAM, CommandList RAM
IF ((AddrBus[15..0] >=  MainRAM_Offset ) AND 
	(AddrBus[15..0] <= (MainRAM_Offset + MainRAM_Size - 1))) 
	Then  MainRAM_cs    = VCC;          -- Address belongs to MainRAM
	Else  MainRAM_cs    = GND;
End IF;
IF ((AddrBus[15..0] >=  ProgRAM_Offset ) AND 
	(AddrBus[15..0] <= (ProgRAM_Offset + ProgRAM_Size - 1))) 
	Then  ProgRAM_cs    = VCC;          -- Address belongs to ProgRAM
	Else  ProgRAM_cs    = GND;
End IF;
IF ((AddrBus[15..0] >=  CommdList_Offset ) AND 
	(AddrBus[15..0] <= (CommdList_Offset + CommdList_Size - 1))) 
	then  CommandRAM_cs = VCC;          -- Address belongs to CommandRAM
	else  CommandRAM_cs = GND;
End IF;

-- 2) ADC Unit
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] >= (ADC_RAM_Offset + i*ADC_RAM_Size)) AND
		(AddrBus[15..0] <= (ADC_RAM_Offset + (i+1)*(ADC_RAM_Size - 1))) ) 
		THEN 	TA12Channel_cs[i]   = VCC;
		ELSE 	TA12Channel_cs[i]   = GND;
	END IF;
END GENERATE;

IF ((AddrBus[15..0] >=  Compres_Offset) AND 
	(AddrBus[15..0] <= (Compres_Offset + 1))) 
	then  Compres_cs = VCC;          -- Address belongs to CommandRAM
	else  Compres_cs = GND;
End IF;

%
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] == (DDREqu_Offset + i*DDREqu_Size)) AND
		(AddrBus[15..0] <= (DDREqu_Offset + (i+1)*DDREqu_Size)) )
		Then DDREqu_cs[i]  = VCC ;         -- Address belongs to ADC Unit
		Else DDREqu_cs[i]  = GND ;
	End IF ;
END GENERATE;
FOR i IN 0 TO (NUM_CH-1) GENERATE
	IF ((AddrBus[15..0] == (DDRNEqu_Offset + i*DDRNEqu_Size)) AND
		(AddrBus[15..0] <= (DDRNEqu_Offset + (i+1)*DDRNEqu_Size)) )
		Then DDRNEqu_cs[i]  = VCC ;         -- Address belongs to ADC Unit
		Else DDRNEqu_cs[i]  = GND ;
	End IF ;
END GENERATE;
%%
IF (AddrBus[15..0] == GateDur_Offset) 
	Then GateDur_CS = VCC;
	Else GateDur_CS = GND ;
End IF ;
IF (AddrBus[15..0] == GateDel_Offset) 
	Then GateDel_CS = VCC;
	Else GateDel_CS = GND ;
End IF ;
%
-- 4) Link: InData, DataBus_in / DataBus_out
--IF ( AddrBus[15..0] == Link_IFace_Offset ) 
--    Then Link_InData_cs = VCC ;         -- Address of Link's InData register
--    Else Link_InData_cs = GND ;
--End IF ;
IF ( (AddrBus[15..0] == Link_IFace_Offset)          --Addr of Link's InData Reg
	OR (AddrBus[15..0] == (Link_IFace_Offset +1)) ) --Addr of Link's I/O port
	Then Link_cs = VCC ;
	Else Link_cs = GND ;
End IF ;
IF ( AddrBus[15..0] == SelCommdList)          --Addr of Link's InData Reg
	Then SelCommdList_cs = VCC ;
	Else SelCommdList_cs = GND ;
End IF ;

-- 5) Registers and similar objects
IF (AddrBus[15..0] == OpCode_Offset) 
	Then OpCode_cs = VCC;
	Else OpCode_cs = GND ;
End IF ;
IF (AddrBus[15..0] == BaseAddr_Offset) 
	Then BaseAddr_cs = VCC;
	Else BaseAddr_cs = GND ;
End IF ;

-- 6) Error counter
IF ((AddrBus[15..0] >= ErrorCounters_Offset) AND ((ErrorCounters_Offset + ErrorCounters_Size) > AddrBus[15..0]) ) 
	THEN ErrorCounters_IFace_CS = VCC ; 
	ELSE ErrorCounters_IFace_CS = GND ; 
END IF ;
-- 7) Test
IF ((AddrBus[15..0] >=  TestRAM_Offset ) AND 
	(AddrBus[15..0] <= (TestRAM_Offset + TestRAM_Size - 1))) 
	Then TestRAM_cs = VCC;          -- Address belongs to MainRAM
	Else TestRAM_cs = GND;
End IF;

-- 8) ZERO: fictive object, always replies B"0000000000000000" word
IF ( AddrBus[15..0] == B"1111111111111111" ) 
	Then ZERO_cs = VCC ;         -- Address of ZERO word
	Else ZERO_cs = GND ;
End IF ;

DevSel[ 1].d	= MainRAM_cs ;
DevSel[ 2].d	= ProgRAM_cs ;
DevSel[ 3].d	= CommandRAM_cs;
DevSel[ 4].d	= Link_cs ;             -- Link's I/O port or InData_out
FOR i IN 0 TO (NUM_CH-1) GENERATE
	DevSel[5+i].d  = TA12Channel_cs[i]; -- ADC channel data
END GENERATE;
DevSel[11].d	= Compres_cs;
DevSel[12].d	= SelCommdList_cs;--GateDur_cs ;          -- Reg_OpCode
--DevSel[12].d	= GND;--GateDel_cs ;          -- Reg_OpCode
DevSel[13].d	= OpCode_cs ;           -- Reg_OpCode
DevSel[14].d	= BaseAddr_cs ;         -- Reg_BaseAddr
DevSel[15].d	= ErrorCounters_IFace_CS ; -- Error Counters
DevSel[16].d	= TestRAM_cs; --
DevSel[17].d	= ZERO_cs ;             -- ZERO word
%FOR i IN 0 TO (NUM_CH-1) GENERATE
	DevSel[16+2*i].d	= DDREqu_cs[i];
	DevSel[17+2*i].d	= DDRNEqu_cs[i] ;             -- ZERO word
END GENERATE;
%

FOR i in 1 to 17 % with ErCount must be 28 % GENERATE
	DevSel[i].clrn = AddrSettled;-- DevSel[] are enabled while Addr. is settled
	DevSel[i].clk  = Clk100;
END GENERATE; 

-- Multiplexer of Data Bus sources (Enables Data drivers )
IF (RW == VCC) Then		-- Master will write to
	DataBus[] = CPU.DataOut[] ;
Else					-- Master will read from
	CASE DevSel[].q IS     -- Data_Line MUX for Target drivers
		--WHEN  b"1000000000" => DataBus[] = something.q[]
		WHEN  b"00000000000000001" => DataBus[]			= MainRAM.q[];
		WHEN  b"00000000000000010" => DataBus[]			= CPU.ProgRAM_q[];
		WHEN  b"00000000000000100" => DataBus[]			= CommandRAM.q[];
		WHEN  b"00000000000001000" => CASE  AddrBus[1..0] is
			When  0 => DataBus[]= Link_IFace.InData_out[];
			When  1 => DataBus[]= Link_IFace.DataBus_out[];
			--When  2 => DataBus[7..0]= Link_IFace.OpCode_out[];
		End CASE;
		WHEN  b"00000000000010000" => DataBus[]			= TA12Channel[0].DataBusOut[] ;
		WHEN  b"00000000000100000" => DataBus[]			= TA12Channel[1].DataBusOut[] ;
		WHEN  b"00000000001000000" => DataBus[]			= TA12Channel[2].DataBusOut[] ;
		WHEN  b"00000000010000000" => DataBus[]			= TA12Channel[3].DataBusOut[] ;
		WHEN  b"00000000100000000" => DataBus[]			= TA12Channel[4].DataBusOut[] ;
		WHEN  b"00000001000000000" => DataBus[]			= TA12Channel[5].DataBusOut[] ;
		WHEN  b"00000010000000000" => DataBus[7..0] = Compres.thr_out[7..0];
		WHEN  b"00000100000000000" => DataBus[]			= SelCommdList_Reg.q[];--GateDur_reg.q[9..0];
		WHEN  b"00001000000000000" => DataBus[7..0]		= Reg_OpCode.q[7..0];
		WHEN  b"00010000000000000" => DataBus[7..0]		= Reg_BaseAddr.q[7..0];
		WHEN  b"00100000000000000" => DataBus[8..0]		= ErrorCounters_IFace.DataBusOut[8..0];
		WHEN  b"01000000000000000" => DataBus[]			= TestRAM.q[]; --AddrMux[]  = 2;
		WHEN  b"10000000000000000" => DataBus[]			= 0 ;
		WHEN OTHERS => DataBus[] = 0;
	End CASE;
End IF;
%		WHEN  b"00000000000001000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[0].q[];
		WHEN  b"00000000000010000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[0].q[];
		WHEN  b"00000000000100000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[1].q[];
		WHEN  b"00000000001000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[1].q[];
		WHEN  b"00000000010000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[2].q[];
		WHEN  b"00000000100000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[2].q[];
		WHEN  b"00000001000000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[3].q[];
		WHEN  b"00000010000000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[3].q[];
		WHEN  b"00000100000000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[4].q[];
		WHEN  b"00001000000000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[4].q[];
		WHEN  b"00010000000000000000000000000" => DataBus[11..0]	= DDR_Reg_Equ[5].q[];
		WHEN  b"00100000000000000000000000000" => DataBus[11..0]	= DDR_Reg_NEqu[5].q[];
%
--============================================================================
-- 10. Testing circuitry ******************************************************
%TestCt.(clock, clk_en)  = (FQuartz, VCC); -- Test Counter, can be used to drive LED blinking
--TestCt.(clock, clk_en)  = (LinkClk, VCC); -- Test Counter, can be used to drive LED blinking
TestCt.cnt_en           = VCC;
TestCt.aclr             = PowerUp0 & !TestCt_rst2;  --\Reset for making proper PwrUp timing diagram
    TestCt_rst1 = DFF(.D=PowerUp0,   .clk= FQuartz);-- > _/^^\_ ,
    TestCt_rst2 = DFF(.D=TestCt_rst1,.clk=!FQuartz);--/   duration >=(1/2)Tquartz
%
TestCt.(clock, clk_en)	= (FQuartz, VCC); -- Test Counter, can be used to drive LED blinking
TestCt.cnt_en			= PowerUp0;
TestCt.aclr				= !PowerUp0;    -- even if NO clock - Reset does occur

TestRAM.(address[7..0], data[],    clock,    wren                     ) =
        (AddrBus[7..0], DataBus[], Clk100,(DataStrobe & DevSel[15] & RW)); 

Test1	= PLL_res;--Link_IFace.LinkMessage;--PhaseSw.LinkClk_selected; 													-- pin 231
Test2	= TAWF_DataStrobe;--LinkMsg_beg;																		-- pin 232
Test3	= TxWFhist.q;--SerDataOut[9];--PLL.locked;																-- pin 233
Test4	= DataCount.cout;--SelCommdList_Trig.q;																	-- pin 234
Test5	= StopCount;--SelCommdList_Trig3.q;																		-- pin 235
Test6	= SerDataOut[7];--TA12Channel[3].test5;																	-- pin 236
Test7	= SerDataOut[8];--AddrSettled;																			-- pin 237
Test8	= NWordFLink[0];--TA12Channel[3].test1;																	-- pin 146
Test9	= TA12Channel[3].test2;				--FLink_Data_BUS.q[3];--DataStrobe;			--Digitizer1.Test1;		-- pin 147
Test10	= TA12Channel[3].test3;				--FLink_Data_BUS.q[4];--DataBus[0];			--Digitizer1.Working;	-- pin 148

END;