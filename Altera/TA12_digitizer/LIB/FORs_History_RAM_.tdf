TITLE "FORs";

INCLUDE "lpm_counter.inc" ;
INCLUDE "lpm_shiftreg.inc";
INCLUDE "Edge_Sensing.inc";
INCLUDE "lpm_mux.inc" ;
INCLUDE "FORs_RAM.inc";

CONSTANT WORD_WIDTH       = 16; -- размер слова данных
CONSTANT PrescalerModule6  = 6;  -- делим входную частоту в 6 раз
CONSTANT PrescalerModule3  = 3;  -- делим входную частоту в 3 раза


SUBDESIGN FORs_History_RAM_
(
--
  LinkMessage                 : input;  -- сигнал паузы в работе модуля
  Clock           			  : input;  -- входная частота 150 МГц, частота работы модуля
  FOR_Sample_Enable           : input;  -- частота оборота пучка, привязанная к общему стопу 
    
-- Module specific signals
  DataIn[31..0]  		 	  : input; 
   
  DataBus_In[15..0]			  : input;  -- отправляемые с Внутренней Шины в Линк данные
  DataBusOut[15..0]     	  : output; -- выдаваемые на Внутреннюю Шину из Модуля данные (младшие 16бит шины R)
  
  Bus_Clock                   : input;  -- частота шины проекта 100 МГц
  DataBusStrobe 			  : input;  -- строб приема/передачи данных наружу (высокий уровень, защелкиваем по заднему фронту)
  Select					  : input;  -- Выбор Модуля для работы с памятью Командного Листа в режиме Slave (с КАМАК-ом)
  DirectIn					  : input;  -- направление передачи данных, Если =GND, то данный Модуль читается, если =VCC, то пишется.
  AddrBus_In[9..0]			  : input;  -- адрес при операциях доступа чтения/записи Командного Листа с КАМАК-а
  
  HS_RAM_ADDR_0[7..0]         : output;
 )

VARIABLE

  RAM[1..0]					  : FORs_RAM;
  RAM_Addr_Cnt_a   	          : LPM_COUNTER with ( lpm_width=8, lpm_direction="down" );  
  RAMAddrBus[7..0]            : node;
  SaveRAM_0                   : node;
  SaveRAM_1                   : node;
    
BEGIN

DEFAULTS
	DataBusOut[] = GND;
END DEFAULTS;


--*************** Память истории ***************************
RAM[0].(address_a[7..0]       , clock_a, data_a[15..0] , wren_a) =
       (RAM_Addr_Cnt_a.q[7..0], Clock  , DataIn[15..0] , FOR_Sample_Enable); 
RAM[1].(address_a[7..0]       , clock_a, data_a[15..0] , wren_a) =
       (RAM_Addr_Cnt_a.q[7..0], Clock  , DataIn[31..16], FOR_Sample_Enable); 

RAM_Addr_Cnt_a.clock   = Clock;
RAM_Addr_Cnt_a.clk_en  = !LinkMessage AND FOR_Sample_Enable;

-- с 0..511 адрес пишем в память
IF(AddrBus_In[] >= 0 AND AddrBus_In[] <= 255)   THEN SaveRAM_0 = DataBusStrobe and  DirectIn AND Select;
                                                     DataBusOut[] = RAM[0].q_b[15..0];
                                                ELSE SaveRAM_0 = GND; 
END IF;
IF(AddrBus_In[] >= 256 AND AddrBus_In[] <= 511) THEN SaveRAM_1    = DataBusStrobe and  DirectIn AND Select; 
                                                     DataBusOut[] = RAM[1].q_b[15..0];
                                                ELSE SaveRAM_1 = GND; 
END IF;


RAMAddrBus[7..0] = AddrBus_In[7..0] + RAM_Addr_Cnt_a.q[7..0]; -- выставление адреса в 0 для текущего набора FOR-ов
RAM[0].(address_b[7..0] , clock_b  , data_b[15..0], wren_b) =
       (RAMAddrBus[7..0], Bus_Clock, DataBus_In[] , SaveRAM_0); 
RAM[1].(address_b[7..0] , clock_b  , data_b[15..0], wren_b) =
       (RAMAddrBus[7..0], Bus_Clock, DataBus_In[] , SaveRAM_1); 


-- для симуляции
HS_RAM_ADDR_0[7..0] = RAM_Addr_Cnt_a.q[7..0];
 
END; -- End design
