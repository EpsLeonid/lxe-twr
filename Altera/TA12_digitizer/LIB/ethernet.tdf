TITLE "ETHERNET";

INCLUDE "lpm_counter.inc";
INCLUDE "lpm_shiftreg.inc";

--INCLUDE "LevelSensing.inc";
INCLUDE "PulseShaper.inc";

--INCLUDE "EthernetRx.inc";
--INCLUDE "EthernetTx.inc";
INCLUDE "CRC32";

SUBDESIGN  ETHERNET  
(
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  RECEIVER section  ************
RX_CLK          : INPUT;    -- Ether-Rx Clock   <- Rx-channel of Eth_Controller
RX_DV           : INPUT;    -- "DataValid"      <- Rx-channel of Eth_Controller
COL             : INPUT;    -- "Collision"     -//-
CRS             : INPUT;    -- "CarrierSense"  -//-
RXD[3..0]       : INPUT;    -- Data half-Byte   <- Rx-channel of Eth_Controller

Saddr[48..1]    : input;  --This_Device' address (to be sent at "SourceAddr" field ..
                                        --.. of the outcoming packets)
--Daddr[48..1]    : output; -- DestinationAddr for the outcoming packet (received 
--                                        -- before, at "SourceAddr" field)

--RxLineIdle      : output;   -- flag:  "Idle" symbols are received
--RxChkPream      : output;   -- flag:  checking the "Preamble" symbols
RxWaitSFD       : output;   -- flag: Waiting for "StartFrameDelimiter"
RxDestAddr      : output;   -- flag: "DestinationAddr" is being received
RxSourAddr      : output;   -- flag: "SourceAddr" is being received
RxPkLenTyp      : output;   -- flag: "PkLength/Type" is being received
RxDataBlck      : output;   -- flag: receiving of Data_Block is ongoing
RxFrameCRC      : OUTPUT;   -- flag: "FrameCheckSequence" is being received
RxEndFrame      : output;   -- flag: End-of-Received_Frame
RxCount[11..0]  : OUTPUT;   -- Receiving_Cycle Counter's outputs

RxLenTyp[16..1] : output;   -- value of the "PkLength/Type" field (MSbit always =0 !)
RxLength[12..1] : output;   -- resulting Length(Bytes) of the Data_Block

RxError         : output;   

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  TRANSMITTER section  ************
TX_CLK          : INPUT;    -- Ether-Tx Clock   <- Tx-channel of Eth_Controller
TXD[3..0]       : OUTPUT;   -- half-Bytes of Data       -> Eth_Controller
TX_EN           : OUTPUT;   -- Enabling Transmission    -> Eth_Controller

StTransmit      : input ; -- старт передачи пакета

--Saddr[48..1]    : input;    -- declared in the RECEIVER section
--Daddr[48..1]    : input;    -- DestinationAddr for the outcoming packet (received 
--                                        -- before, at "SourceAddr" field)
TxPreamble      : output;   -- flag: "Preamble" is being transmitted
TxStFrmDel      : output;   -- flag: "StartFrameDelimiter" is being transmitted
TxDestAddr      : OUTPUT;   -- flag: "DestinationAddr" is being transmitted
TxSourAddr      : OUTPUT;   -- flag: "SourceAddr is being transmitted
TxPkLenTyp      : output;   -- flag: "Packet Length/Type" is being transmitted
TxDataBlck      : output;   -- flag: Data_Block is being transmitted
TxFrameCRC      : output;   -- flag: "FrameCheckSequence" is being transmitted
TxEndFrame      : output;   -- flag: End-of-TxFrame
TxCount[11..0]  : OUTPUT;   -- Cycle Counter's outputs, for test

--TxLenTyp[16..1] : input;    -- value of the "PkLength/Type" field
TxLength[12..1] : input ;   -- length of the DataBlock (MSbit always =0 ! )

TxError             : output;   

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--******** Data Read/Write from/to the common DataBus of the MainProject ********
Clock               : input;  -- Clock Frequency MUST BE > 50MHz !!!!

IORq                : output; -- Data_ready or Data_required	
RdWr_out            : output; -- =1(Wr) => Data_ready / =0(Rd) => Data_required

Select              : input = GND; -- Link is selected for data reading/writing
RdWr_in             : input = GND; -- RdWr=0 => data will be read from Link / RdWr=1 => data will be written to Link
DataStrobe          : input = GND; -- input data must be latched while DataStrobe=1 

DataBus_in[15..0]   : input;    -- data:  DataBus -> Ethernet
DataBus_out[15..0]  : output;   -- data:  DataBus <- Ethernet

--Error               : output;   -- all Errors combined
RESET               : INPUT =GND; -- сброс

Test[8..1]          : output;
)

VARIABLE
--EtherTx             : EthernetTx ;  -- Ethernet Transmitter module 
--EtherRx             : EthernetRx ;  -- Ethernet Receiver module 

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  ETHERNET RECEIVER  *********************************************
RX_DV_FF,  
RxD_Reg[4..1], 
COL_FF, CRS_FF  : DFF ;

RxCycle         : SRFF; -- flag: receiving of a Frame is ongoing
ChkDaddr        : DFFE;    
ChkDaddr_ena    : node;
Daddr[48..1]    : DFFE; -- "Register" for latching and storing the DestAddr

-- Main Receiving_Cycle Counter
CtReceiv        : LPM_COUNTER with ( lpm_width=12, lpm_direction="up" );
CtReceiv_sclr   : node; -- logic node

-- Triggers which represent the state of the Receiving_Cycle :
RxLineIdle      : DFF ; -- flag:  "Idle" symbols are received
RxChkPream      : DFF ; -- flag:  checking the "Preamble" symbols
RxWaitSFD       : DFF ; -- flag:  Waiting for "StartFrameDelimiter"
RxDestAddr      : DFF ; -- flag:  "DestinationAddr" is being received
RxSourAddr      : DFF ; -- flag:  "SourceAddr" is being received
RxPkLenTyp      : DFF ; -- flag:  "PacketLength/Type" is being received
RxDataBlck      : DFF ; -- flag:  Block of Data is being received
RxFrameCRC      : DFF ; -- flag:  "FrameCheckSequence" is being received
RxEndFrame      : DFF ; -- прием фрейма завершен

RxLenTyp[16..1] : DFFE; -- "register" containing the value of "PkLength/Type"
RxLength[12..1] : DFF;  -- "register" containing the length of Data_Block

RxCRC           : CRC32;-- CRC checking function
R_ReceivOK      : node; -- CRC value is correct (1clk pulse, =simultaneous= with EndFrame ! )

-- Conversion of 4 half-Bytes into 1 16-bit Word :
RxShifter1      : LPM_SHIFTREG with (lpm_width=3, -- contains 1st bits (LSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
RxShifter2      : LPM_SHIFTREG with (lpm_width=3, -- contains 2nd bits       of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
RxShifter3      : LPM_SHIFTREG with (lpm_width=3, -- contains 3rd bits       of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
RxShifter4      : LPM_SHIFTREG with (lpm_width=3, -- contains 4th bits (MSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
RxWordConv      : node; -- enables half-Bytes to Words conversion
RxWord, 
RxWord1,RxWord2 : node; -- derive strobe for latching RxData word
RxWord_en       : node; -- enable for Reg_RxData
-- Reg: holds a 16-bit Data word, for outputting it to the DataBus 
Reg_RxWord      : LPM_SHIFTREG with (lpm_width=16, lpm_direction="left"); 

R_Err           : node; --logical: if incorrect value of "PkLength/Type" field detected 
R_Error         : PulseShaper with (DurationCode=4);--flag: Error occured during receiving a Frame

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  ETHERNET TRANSMITTER  ******************************************
TX_EN_FF        : DFF;
--TXD_FF[3..0]    : DFF;
TxD_Reg[4..1]   : DFF;

Tx_init         : node;  -- garanteedly initiates a Transmit operation
enTransmit      : node; -- enable Transmission 

-- Main Transmit_Cycle Counter
CtTransm        : LPM_COUNTER with (LPM_WIDTH=12, LPM_DIRECTION="up");
CtTransm_sclr	: node; 

-- Triggers which represent the state of the Transmit_Cycle :
TxLineIdle      : DFF;
TxPreamble      : DFF;
TxStFrmDel      : DFF; 
TxDestAddr      : DFF; 
TxSourAddr      : DFF;
TxPkLenTyp      : DFF;
TxDataBlck      : DFF;
TxFrameCRC      : DFF; 
TxEndFrame      : DFF;      

TxLenTyp[16..1] : node; -- value of the "PkLength/Type" field for TxFrame

TxPkLng_Reg     : LPM_SHIFTREG with (lpm_width=12, -- latches the DataPacket Length (in Bytes)
                                lpm_direction="left"); --shift: q0 -> q[MSB]

TxCRC           : CRC32;-- function which calculates the CRC of the TxFrame

--==============================================================================
-- In TRANSMITTER, it is more efficient to make several separate registers 
-- for conversion of Daddr, Saddr, PkLenType and DWords into half-Bytes 
-- than to make ONE common register with (9-input 16-bit) multiplexer at inputs. 

-- Registers for Conversion of 48-bit DestAddr into 12 consecutive half-Bytes :
Daddr_Reg1      : LPM_SHIFTREG with (lpm_width=12, -- contains 1st bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Daddr_Reg2      : LPM_SHIFTREG with (lpm_width=12, -- contains 2nd bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Daddr_Reg3      : LPM_SHIFTREG with (lpm_width=12, -- contains 3rd bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Daddr_Reg4      : LPM_SHIFTREG with (lpm_width=12, -- contains 4th bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Daddr_ld        : node;     -- strobe for loading Daddr_Reg-s

-- Registers for Conversion of 48-bit SourAddr into 12 consecutive half-Bytes :
Saddr_Reg1      : LPM_SHIFTREG with (lpm_width=12, -- contains 1st bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Saddr_Reg2      : LPM_SHIFTREG with (lpm_width=12, -- contains 2nd bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Saddr_Reg3      : LPM_SHIFTREG with (lpm_width=12, -- contains 3rd bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Saddr_Reg4      : LPM_SHIFTREG with (lpm_width=12, -- contains 4th bits (LSB) of 12 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
Saddr_ld        : node;     -- strobe for loading Saddr_Reg-s

-- Registers for Conversion of 16-bit TxLength into 4 consecutive half-Bytes :
TxLng_Reg1      : LPM_SHIFTREG with (lpm_width= 4, -- contains 1st bits (LSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxLng_Reg2      : LPM_SHIFTREG with (lpm_width= 4, -- contains 2nd bits (LSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxLng_Reg3      : LPM_SHIFTREG with (lpm_width= 4, -- contains 3rd bits (LSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxLng_Reg4      : LPM_SHIFTREG with (lpm_width= 4, -- contains 4th bits (LSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxLng_ld        : node;     -- strobe for loading TxLng_Reg-s

-- Registers for Conversion of each 16-bit Word into 4 consecutive half-Bytes :
TxShifter1      : LPM_SHIFTREG with (lpm_width=4, -- contains 1st bits (LSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxShifter2      : LPM_SHIFTREG with (lpm_width=4, -- contains 2nd bits       of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxShifter3      : LPM_SHIFTREG with (lpm_width=4, -- contains 3rd bits       of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxShifter4      : LPM_SHIFTREG with (lpm_width=4, -- contains 4th bits (MSB) of 4 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxShift_ld      : node; -- load   for TxShifters

-- Registers for Conversion of 32-bit FrameCRC into 8 consecutive half-Bytes :
TxCRC_Reg1      : LPM_SHIFTREG with (lpm_width= 8, -- contains 1st bits (LSB) of 8 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxCRC_Reg2      : LPM_SHIFTREG with (lpm_width= 8, -- contains 2nd bits (LSB) of 8 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxCRC_Reg3      : LPM_SHIFTREG with (lpm_width= 8, -- contains 3rd bits (LSB) of 8 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxCRC_Reg4      : LPM_SHIFTREG with (lpm_width= 8, -- contains 4th bits (LSB) of 8 consecutive half-Bytes
                                lpm_direction="left"); --shift: q0 -> q[MSB]
TxCRC_ld        : node;     -- strobe for loading TxCRC_Reg-s

TxWord, 
TxWord1,TxWord2 : node; -- derive strobe for latching RxData word
TxWord_rq       : node; -- to set IORq / to clear Reg_TxWord
TxWord_ld       : node; -- enables Reg_TxWord to load data
TxShift_ld1     : node; -- strobe at the =last moment= before loading the TxShifters 
-- Reg: holds a 16-bit Data word just inputted from the DataBus 
Reg_TxWord      : LPM_SHIFTREG with (lpm_width=16, lpm_direction="left"); 

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************ Data Read/Write control signals generation **************
IORq_r, 
IORq_r1,IORq_r2 : node; -- to reset IORq 

IORq_set        : node; -- 1clk _/^\_ 
IORq_rst        : node; -- 1clk _/^\_ just before new "IORq" request

TxWord_Error    : node; -- error: new DataWord (for Tx) has NOT been read in time
RdWr_Error      : node; -- error during Read/Write operation 


BEGIN
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
DEFAULTS
RxLineIdle.D = GND; RxChkPream.D = GND; RxWaitSFD.D = GND;  
RxDestAddr.D = GND; RxSourAddr.D = GND; RxPkLenTyp.D = GND; RxDataBlck.D = GND; 
RxFrameCRC.D = GND; RxEndFrame.D = GND;

CtReceiv_sclr = GND;    ChkDaddr_ena = GND;     RxCRC.sclr    = GND;

R_Err = GND;    TxError = GND;  --Error = GND;
RxWord  = GND;  TxWord  = GND; 


TxLineIdle.D  = GND;
CtTransm_sclr = GND;    TxCRC.clk_en = GND;
Daddr_ld = GND;     Saddr_ld = GND;     TxLng_ld = GND;

END DEFAULTS;

--==============================================================================
--********  ETHERNET' RECEIVER  ************************************************
--==============================================================================
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--******** RECEIVING Cycle proceeding control  *********************************
(RX_DV_FF, RxD_Reg[], COL_FF, CRS_FF ).clk = RX_CLK;
RX_DV_FF.d  = RX_DV;
RxD_Reg[4..1].d = RXD[3..0]; 
COL_FF.d    = COL;
CRS_FF.d    = CRS;

-- Triggers which represent the state of the Receiving_Cycle :
( RxLineIdle, RxChkPream, RxWaitSFD, 
  RxDestAddr, RxSourAddr, RxPkLenTyp, RxDataBlck, 
  RxFrameCRC, RxEndFrame).clk = RX_CLK; 

RxLineIdle.D    = !RX_DV_FF & !RxCycle; -- RxLineIdle.D is also asserted in "RxCycle' State Handling"

--RxCycle.S   = defined in the "RxCycle' State Handling" sub-section, in "RxWaitSFD" state
RxCycle.(R,clk) = (!RX_DV_FF, RX_CLK); 

-- Main Cycle Counter :
CtReceiv.clock  = RX_CLK;
CtReceiv.sclr   = CtReceiv_sclr;    -- defined in the StateMachine
RxCount[11..0]   = CtReceiv.q[11..0];

-- "Frame Check Sequence" handling and CRC check : 
RxCRC.d[]   = RxD_Reg[];
RxCRC.clk   = RX_CLK;
RxCRC.clk_en= VCC;              -- no?aiii !
--RxCRC.sclr  = defined in the State Machine
R_ReceivOK  = RxCRC.crc_ok;   -- 1clk pulse, =simultaneous= with EndFrame !
	
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  RxCycle' State Handling  *******************************************
IF  RxLineIdle  Then    -- The INITIAL STATE :  just "Idle" symbols are received. 
                        -- When RX_DV appears => 
    CtReceiv_sclr = VCC; 
    IF (RX_DV_FF AND !RxCycle)  -- IF  RX_DV_FF=1 AND there is NO Frame in progress, ..
        Then  RxLineIdle.D  = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxChkPream.D  = VCC;  --/ .. to check if it is Preamble
    ELSE                            -- Otherwise, ..
              RxLineIdle.D  = VCC;  -- .. remain in the initial state 
    End IF;
End IF;
			
IF  RxChkPream  Then    -- checking if "Preamble" has begun :
                        -- any (half-Byte = H"5") is being searched for
    CtReceiv_sclr = VCC;
    IF (RX_DV_FF AND RxD_Reg[]==H"5") -- IF  Preamble detected, ..
        Then  RxChkPream.D  = GND;  -- \_.. Then  jump (by next _/RX_CLK) ..
              RxWaitSFD.D   = VCC;  -- / .. to wait for StartFrameDelimiter
    ELSIF  RX_DV_FF == VCC          -- IF  Preamble not detected yet, ..
        Then  RxChkPream.D  = VCC;  -- .. continue waiting for Preamble
    ELSE                            -- If RX_DV_FF flips back to =0, ..
              RxChkPream.D  = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;

IF  RxWaitSFD  Then     -- waiting for "Start Frame Delimiter" to appear :
                        -- (4 MSbits of SFD = H"D" ) is being searched for
              CtReceiv_sclr = VCC;
              RxCRC.sclr    = VCC;
    IF (RX_DV_FF & (RxD_Reg[]==H"D")) -- IF 4 MSbits of SFD detected, ..
        Then  RxWaitSFD.D   = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxDestAddr.D  = VCC;  --/ .. to receive DestAddr
              RxCycle.S   = VCC;    -- set flag : receiving of a Frame is ongoing
    ELSIF (RX_DV_FF & (RxD_Reg[]==H"5"))-- IF Preamble detected again, ..
        Then  RxWaitSFD.D   = VCC;  -- .. continue waiting for SFD
    ELSE                  
              RxWaitSFD.D   = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;

IF  RxDestAddr  Then    -- receiving "DestinationAddr" (6 Bytes) :
    -- DestAddr is to be compared with ThisDevice' address !
                    -- RxDestAddr =1,  CtReceiv = 0, RxD_Reg = DestAddr[43..40]
                    -- RxDestAddr =1,  CtReceiv = 1, RxD_Reg = DestAddr[47..44]
                    -- RxDestAddr =1,  CtReceiv = 2, RxD_Reg = DestAddr[35..32]
                    -- RxDestAddr =1,  CtReceiv = 3, RxD_Reg = DestAddr[39..36]
                    -- RxDestAddr =1,    .  .  .  .  .  .  .  .  .
                    -- RxDestAddr =1,  CtReceiv =11, RxD_Reg[]=DestAddr[ 7.. 4]
    IF (RX_DV_FF & (CtReceiv.q[3..0]==11))  -- IF 12th half-Byte received, .. 
        Then  RxDestAddr.D  = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxSourAddr.D  = VCC;  --/ .. to receive SourAddr
              CtReceiv_sclr = VCC;  -- CtReceiv will flip to =00 by next _/RX_CLK
    ELSIF (RX_DV_FF == VCC)         -- IF receiving is ongoing, ..
        Then  RxDestAddr.D  = VCC;  -- .. continue receiving the DestAddr
    ELSE
              RxDestAddr.D  = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;

IF  RxSourAddr  Then    -- receiving "SourceAddr" (6 Bytes) :
    -- SourceAddr is to be stored so that to be used as DestAddr in the reply packet !
                    -- RxSourAddr =1,  CtReceiv = 0, RxD_Reg = SourAddr[43..40]
                    -- RxSourAddr =1,  CtReceiv = 1, RxD_Reg = SourAddr[47..44]
                    -- RxSourAddr =1,  CtReceiv = 2, RxD_Reg = SourAddr[35..32]
                    -- RxSourAddr =1,  CtReceiv = 3, RxD_Reg = SourAddr[39..36]
                    -- RxSourAddr =1,    .  .  .  .  .  .  .  .  .
                    -- RxSourAddr =1,  CtReceiv =11,  RxD_Reg[]=DestAddr[ 7.. 4]
    IF (RX_DV_FF AND ChkDaddr   -- IF ThisFrame is addressed to ThisDevice, ..
      AND (CtReceiv.q[3..0]==11))   --.. and 12th half-Byte received, .. 
        Then  RxDestAddr.D  = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxPkLenTyp.D  = VCC;  --/ .. to receive "PkLength/Type"
              CtReceiv_sclr = VCC;  -- CtReceiv will flip to =00 by next _/RX_CLK
    ELSIF (RX_DV_FF & ChkDaddr) -- IF ThisFrame is addressed to ThisDevice, ..
                                --.. and receiving is ongoing, ..
        Then  RxSourAddr.D  = VCC;  -- .. continue receiving the SourAddr
    ELSE
              RxSourAddr.D  = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;		

IF  RxPkLenTyp  Then    -- receiving "PacketLength/Type" (2 Bytes) :
                    -- RxPkLength =1,  CtReceiv = 0, RxD_Reg = Length[11.. 8]
                    -- RxPkLength =1,  CtReceiv = 1, RxD_Reg = Length[15..12]
                    -- RxPkLength =1,  CtReceiv = 2, RxD_Reg = Length[ 3.. 0]
                    -- RxPkLength =1,  CtReceiv = 3, RxD_Reg = Length[ 7.. 4]
    IF (RX_DV_FF AND (CtReceiv.q[1..0]==3))  --IF 4th half-Byte received, .. 
        Then  RxPkLenTyp.D  = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxDataBlck.D  = VCC;  --/ .. to receive Data Block
              CtReceiv_sclr = VCC;  -- CtReceiv will flip to =00 by next _/RX_CLK
    ELSIF (RX_DV_FF == VCC)         -- IF receiving is ongoing, ..
        Then  RxPkLenTyp.D  = VCC;  -- .. continue receiving the PacketLength
    ELSE
              RxPkLenTyp.D  = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;
		    
IF  RxDataBlck  Then    -- receiving DataBlock ( "RxLength" Bytes) :
                    -- RxDataBlck =1,  CtReceiv = 0, RxD_Reg=DByte01[3..0]=DWord01[11.. 8]
                    -- RxDataBlck =1,  CtReceiv = 1, RxD_Reg=DByte01[7..4]=DWord01[15..12]
                    -- RxDataBlck =1,  CtReceiv = 2, RxD_Reg=DByte02[3..0]=DWord01[ 3.. 0]
                    -- RxDataBlck =1,  CtReceiv = 3, RxD_Reg=DByte02[7..4]=DWord01[ 7.. 4]
    IF RX_DV_FF & (CtReceiv.q[] == ((RxLength[11..1],GND) - 1)) -- -1!
        Then  RxDataBlck.D  = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxFrameCRC.D  = VCC;  --/ .. to receive Data Block
              CtReceiv_sclr = VCC;  -- CtReceiv will flip to =00 by next _/RX_CLK
    ELSIF (RX_DV_FF == VCC)         -- IF receiving is ongoing, ..
        Then  RxDataBlck.D  = VCC;  -- .. continue receiving the Data Block
    ELSE
              RxDataBlck.D  = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;
		
IF  RxFrameCRC  Then    -- receiving Frame' CRC (4 Bytes) :
    IF (RX_DV_FF & (CtReceiv.q[2..0]== 7))  -- IF 8th half-Byte received, ..
        Then  RxFrameCRC.D  = GND;  --\_.. Then  jump (by next _/RX_CLK) ..
              RxLineIdle.D  = VCC;  --/ .. to the initial state
              RxEndFrame.d  = VCC;  -- .. RxEndFrame will flip to =1 by next _/RX_CLK
    ELSIF (RX_DV_FF == VCC)         -- IF receiving is ongoing, ..
        Then  RxFrameCRC.D  = VCC;  -- .. continue receiving the Frame' CRC
    ELSE
              RxFrameCRC.D  = GND;  --\_.. return (by next _/RX_CLK) .. 
              RxLineIdle.D  = VCC;  --/ .. to the initial state 
    End IF;
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--****  Conversion of 4 consecutive half-Bytes into 1 16-bit Word :  ***********
RxWordConv  = RxDestAddr # RxSourAddr # RxPkLenTyp # RxDataBlck ;

RxShifter1.(clock, enable, load) = (RX_Clk, RxWordConv, GND); 
RxShifter1.shiftin = RxD_Reg1.q; 
RxShifter2.(clock, enable, load) = (RX_Clk, RxWordConv, GND); 
RxShifter2.shiftin = RxD_Reg2.q; 
RxShifter3.(clock, enable, load) = (RX_Clk, RxWordConv, GND); 
RxShifter3.shiftin = RxD_Reg3.q; 
RxShifter4.(clock, enable, load) = (RX_Clk, RxWordConv, GND); 
RxShifter4.shiftin = RxD_Reg4.q; 
-- When CtReceiv.q[1..0]==3, the bits od a DWord are arranged : 
--                           RxShifter4  RxShifter3  RxShifter2  RxShifter1 
--          RxShifter* .q2   [  11          10           9           8    ]
--          RxShifter* .q1   [  15          14          13          12    ]
--          RxShifter* .q0   [   3           2           1           0    ]
--          RxD_Reg[4..1].q  [   7           6           5           4    ]

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- CHECK-UP of the DestAddr :  
-- for BROADCAST frame :    DestAddr must be = 1111 1111 FF FF FF
-- for MULTICAST frame :    DestAddr must be = nnnn nn01 NN NN NN => the 1st & 2nd bits SENT =01 !
-- for UNICAST frame :      DestAddr must be = nnnn nn00 NN NN NN => the 1st & 2nd bits SENT =00 !

ChkDaddr.clk  = RX_CLK;
--ChkDaddr.ena  =  connected below in the CASE statement
ChkDaddr.ena = ChkDaddr_ena;
ChkDaddr.clrn = !RxWaitSFD;     -- reset to =0 at the beg-g of Frame

-- Compare the received DestAddr' Bytes with the correspondent Bytes of ThisDevAddr :
-- If at least ONCE  the incoming_Byte NOTequal to Saddr[] then ChkDaddr will be =0 at the end 
IF  RxDestAddr  Then   
    CASE  CtReceiv.q[3..0]  IS
        WHEN  1 =>  ChkDaddr.d = 
            ((RxD_Reg[4..1].q, RxShifter[4..1].q0) == Saddr[48..41]) 
          OR((RxD_Reg[4..1].q, RxShifter[4..1].q0) == H"FF") ;
            --ChkDaddr.ena = VCC;
            ChkDaddr_ena = VCC;
        WHEN  3 =>  ChkDaddr.d =
          ( ((RxD_Reg[4..1].q, RxShifter[4..1].q0) == Saddr[40..33]) 
          OR((RxD_Reg[4..1].q, RxShifter[4..1].q0) == H"FF")) AND ChkDaddr;
            --ChkDaddr.ena = VCC;
            ChkDaddr_ena = VCC;
        WHEN  5 =>  ChkDaddr.d =
          ( ((RxD_Reg[4..1].q, RxShifter[4..1].q0) == Saddr[32..25]) 
          OR((RxD_Reg[4..1].q, RxShifter[4..1].q0) == H"FF")) AND ChkDaddr;
            --ChkDaddr.ena = VCC;
            ChkDaddr_ena = VCC;
        WHEN  7 =>  ChkDaddr.d =
          ( ((RxD_Reg[4..1].q, RxShifter[4..1].q0) == Saddr[24..17]) 
          OR((RxD_Reg[4..1].q, RxShifter[4..1].q0) == H"FF")) AND ChkDaddr;
            --ChkDaddr.ena = VCC;
            ChkDaddr_ena = VCC;
        WHEN  9 =>  ChkDaddr.d =
          ( ((RxD_Reg[4..1].q, RxShifter[4..1].q0) == Saddr[16.. 9]) 
          OR((RxD_Reg[4..1].q, RxShifter[4..1].q0) == H"FF")) AND ChkDaddr;
            --ChkDaddr.ena = VCC;
            ChkDaddr_ena = VCC;
        WHEN 11 =>  ChkDaddr.d =
          ( ((RxD_Reg[4..1].q, RxShifter[4..1].q0) == Saddr[ 8.. 1]) 
          OR((RxD_Reg[4..1].q, RxShifter[4..1].q0) == H"FF")) AND ChkDaddr;
            --ChkDaddr.ena = VCC;
            ChkDaddr_ena = VCC;
    End CASE;
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- IF the received (DestinationAddr==This_Device' addr) <=> ChkDaddr=1, then ..
-- .. restore 48-bit SourceAddr and latch it, 
-- .. so that to use it as DestinationAddr at the reply packet :  
Daddr[48.. 1].clk = RX_CLK ; 

Daddr[44..41].d = RxShifter[4..1].q2;   --\ interconnections 
Daddr[48..45].d = RxShifter[4..1].q1;   -- \for restoring 
Daddr[36..33].d = RxShifter[4..1].q0;   -- /of the 1st(MSByte) and 2nd Bytes 
Daddr[40..37].d = RxD_Reg[4..1].q;      --/ of the DestinationAddr
Daddr[48..33].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 3);

Daddr[28..25].d = RxShifter[4..1].q2;   --\ interconnections 
Daddr[32..29].d = RxShifter[4..1].q1;   -- \for restoring 
Daddr[20..17].d = RxShifter[4..1].q0;   -- /of the 3rd and 4th Bytes 
Daddr[24..21].d = RxD_Reg[4..1].q;      --/ of the DestinationAddr
Daddr[32..17].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] == 7);

Daddr[12.. 9].d = RxShifter[4..1].q2;   --\ interconnections 
Daddr[16..13].d = RxShifter[4..1].q1;   -- \for restoring 
Daddr[ 4.. 1].d = RxShifter[4..1].q0;   -- /of the 5th and 6th(LSByte) Bytes 
Daddr[ 8.. 5].d = RxD_Reg[4..1].q;      --/ of the DestinationAddr
Daddr[16.. 1].ena = ChkDaddr & RxSourAddr & (CtReceiv.q[3..0] ==11);

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- Restore 16-bit word of PacketLength/Type and latch it for further use :
RxLenTyp[16.. 1].clk= RX_CLK ; 
RxLenTyp[16.. 1].ena= ChkDaddr & RxPkLenTyp & (CtReceiv.q[3..0] == 3);
RxLenTyp[12.. 9].d  = RxShifter[4..1].q2;   --\ interconnections 
RxLenTyp[16..13].d  = RxShifter[4..1].q1;   -- \for restoring 
RxLenTyp[ 4.. 1].d  = RxShifter[4..1].q0;   -- /of the 1st(MSByte) and 2nd Bytes 
RxLenTyp[ 8.. 5].d  = RxD_Reg[4..1].q;      --/ of the "PkLength/Type"

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************ LENGTH/TYPE  RECOGNITION :  *************************************
--IF (RxLenTyp[] >= 1536) Then 
    --CASE RxLenTyp[] IS 
    --    WHEN  H"CDCC" =>    CMD3-type
    --    WHEN  H"????" =>    UDP    -- Length is to be defined according to the Type
    --    WHEN  H"0800" =>    IP     -- Length is to be defined according to the Type
    --End CASE;
IF  (RxLenTyp[] == H"CDCC") Then        -- IF  CMD3-type, ..
    RxLength[].d = H"040";              -- .. length = 64Bytes
ELSIF (RxLenTyp[] <= 1500)  Then        -- IF  this is LENGTH, ..
    RxLength[].d = RxLenTyp[12..1];     -- .. length => Reg, MSbit always =0 !
ELSE                                    -- IF  an incorrect value, ..
    RxLength[].d = H"040";              -- .. set length == 64Bytes
    IF  RxDataBlck 
      Then  R_Err    = VCC;             -- set ERROR flag 
    End IF;
End IF;
RxLength[].clk  = RX_Clk; 
RxLength[].clrn = !RxEndFrame;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
-- Delivering the DataWords to the MainProject : 
--     restoring of a DWord is synchronized with the Main Clock. 
RxWord  = RxWordConv AND (CtReceiv.q[1..0]==3);  -- 
RxWord1 = DFF(.D=RxWord,  .clk=Clock); -- aligned to MainProjects' Clock
RxWord2 = DFF(.D=RxWord1, .clk=Clock); -- aligned to MainProjects' Clock
RxWord_en = RxWord1 & !RxWord2 ;        -- enabled for 1clk, to load 1 DWord 

-- Reg_RxWord catches each 16-bit DWord and holds it while the next 4 half-Bytes..
-- ..are being received.  This DWord must be read out during this time. 
Reg_RxWord.data[15..0] = (RxShifter4.q1,RxShifter3.q1,RxShifter2.q1,RxShifter1.q1, 
                          RxShifter4.q2,RxShifter3.q2,RxShifter2.q2,RxShifter1.q2, 
                          RxD_Reg[4],   RxD_Reg[3],   RxD_Reg[2],   RxD_Reg[1], 
                          RxShifter4.q0,RxShifter3.q0,RxShifter2.q0,RxShifter1.q0);
Reg_RxWord.(clock, enable, load) = (Clock, RxWord_en, VCC); 
Reg_RxWord.(aclr, sclr)         = (Reset, RxEndFrame );

DataBus_out[15..0] = Reg_RxWord.q[15..0];   -- Data received => user project

R_Error.(D, clk, reset) = (((RxEndFrame & !R_ReceivOK) OR R_Err), Clock, Reset);--PulseShaper 
RxError = R_Error.q;

--==============================================================================
--********  ETHERNET' TRANSMITTER  *********************************************
--==============================================================================
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  TRANSMIT Cycle proceeding control  *********************************

TXD[3..0]       = TxD_Reg[4..1];       -- registered Data   -> Eth_controller
--TxD_Reg[].d     = defined in the "TxCycle' State Handling" sub-section
TxD_Reg[].clk   = TX_CLK;

TX_EN_FF.d      = enTransmit & !TxEndFrame;	
TX_EN_FF.clk    = TX_CLK;
TX_EN   = TX_EN_FF.q;   -- TX_EN signal -> Output
    
-- CONDUCTING the TRANSMIT OF A PACKET 
-- enTransmit flips to =1 by 1st _/ clock after StTransmit has flipped to =1
enTransmit = SRFF(.S=(StTransmit & !enTransmit),-- flip to =1 by StTransmit
                .R=(TxEndFrame &  enTransmit),  -- flip to =0 by End of Transmit
                .clk=TX_CLK, .clrn=!Reset);

-- Triggers which represent the state of the Transmit_Cycle :
( TxLineIdle, TxPreamble, TxStFrmDel,
  TxDestAddr, TxSourAddr, TxPkLenTyp, TxDataBlck,
  TxFrameCRC, TxEndFrame).clk = TX_CLK; 

TxLineIdle.D    = !enTransmit;  -- TxLineIdle.D is also asserted in "TxCycle' State Handling"

--TxEndFrame.D    =   connected in "TxCycle' State Handling", 
TxEndFrame.clk  = TX_CLK;       --\_1-clk pulse by the End_of_Transmit
TxEndFrame.clrn = enTransmit;   --/ 
	
-- Main TxCycle_Counter : 
CtTransm.data[] = 0; 
CtTransm.(clock,clk_en) = (TX_CLK, VCC);
CtTransm.cnt_en = enTransmit;
CtTransm.sclr   = CtTransm_sclr;        -- defined in "TxCycle proceeding control" 
--CtTransm.aclr   = !enTransmit;          -- counts only while enTransmit = 1
TxCount[]       = CtTransm.q[];

-- This register latches and holds the DataPacket Length (in Bytes) 
TxPkLng_Reg.data[11..0]  = TxLenTyp[12..1];
TxPkLng_Reg.(clock, enable, load) = (TX_CLK, TxLng_ld, VCC); -- loads by the beg-g of "TxPkLenTyp" transmitting
--    = TxPkLng_Reg.q[11.1];            -- connected in "TxCycle' State Handling" section

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  TxCycle' State Handling  *******************************************
IF  TxLineIdle  Then    -- INITIAL STATE :  CtTransm= 0,  TXD_FF=H"0"
    CtTransm_sclr   = VCC;      -- CtTransm is kept =00
    TxCRC.clk_en    = GND;
    --IF  (StTransmit & !enTransmit) Then
    IF  (StTransmit & !TxPreamble) Then
        TxPreamble.d= VCC;      -- TxPreamble will flip to =1 by the next _/TX_CLK
    End IF;
End IF;

IF  TxPreamble  Then    -- "Preamble" (7 Bytes) is being transmitted 
    -- TxPreamble=1;  CtTransm=00,  TXD_FF.d=H"5",          TXD_FF=H"0"
    -- TxPreamble=1;  CtTransm=01,  TXD_FF.d=H"5",          TXD_FF=H"5"
    -- TxPreamble=1;     .  .  .  .  .  .  .  .  .  .  .  .  .
    -- TxPreamble=1;  CtTransm=14,  TXD_FF.d=H"5",          TXD_FF=H"5"
    TxD_Reg[].d     = 5;        -- 7 * ( 1010 1010 ) is transmitted
    TxCRC.clk_en    = GND;
    IF  (CtTransm.q[3..0]== 14) Then
        TxPreamble.d= GND;      --\_.. Then  jump (by next _/TX_CLK) ..
        TxStFrmDel.d= VCC;      --/ .. to transmit the "StartFrameDelimiter"
    ELSE        -- TxPreamble.D=1, TxStFrmDel.D=0 until CtTransm=14
        TxPreamble.d= VCC;      --\_.. Then  continue ..
        TxStFrmDel.d= GND;      --/ .. to transmit the Preamble
    End IF;
End IF;

IF  TxStFrmDel  Then    -- "StartFrameDelimiter" (1/2 Byte = 1010 ) is being transmitted 
    -- TxStFrmDel=1;  sm_t[]=2, CtTransm=15,  TxD_Reg.D=H"D",         TxD_Reg=H"5"
    -- the  "TxStFrmDel=1" state is just 1clock long !
    TxD_Reg[4..1].d = 13;   -- TxD_Reg[] will flip to 13=H"D" by the next _/TX_CLK
    TxCRC.clk_en    = VCC;  -- !! \_Here the reset of CRC .. 
    TxCRC.sclr      = VCC;  -- !! / .. does occur !
    IF  (CtTransm.q[3..0] == 15) Then
        TxStFrmDel.d= GND;      --\_.. Then  jump (by next _/TX_CLK) ..
        TxDestAddr.d= VCC;      --/ .. to transmit the "DestinationAddr"
        CtTransm_sclr = VCC;    -- CtTransm will flip to =00 by next _/TX_CLK
        Daddr_ld    = VCC;      -- Daddr_Reg-s will load by next _/TX_CLK
    ELSE        -- normally, this state does NOT occur !
        TxStFrmDel.d= VCC;  -- 
        TxDestAddr.d= GND;  --
    End IF;
End IF;

IF  TxDestAddr  Then    -- "DestinationAddr" (6 Bytes) is being transmitted 
    -- DestAddr (received before at "SourAddr" field) is to be transferred :
    -- TxDestAddr=1;  CtTransm=00,  TXD_FF.d=Daddr[43..40], TXD_FF=H"D"
    -- TxDestAddr=1;  CtTransm=01,  TXD_FF.d=Daddr[47..44], TXD_FF=Daddr[43..40]
    -- TxDestAddr=1;  CtTransm=02,  TXD_FF.d=Daddr[35..32], TXD_FF=Daddr[47..44]
    -- TxDestAddr=1;  CtTransm=03,  TXD_FF.d=Daddr[39..36], TXD_FF=Daddr[39..36]
    -- TxDestAddr=1;     .  .  .  .  .  .  .  .  .  .  .  .  .
    -- TxDestAddr=1;  CtTransm=10,  TXD_FF.d=Daddr[ 3.. 0], TXD_FF=Daddr[11.. 8]
    -- TxDestAddr=1;  CtTransm=11,  TXD_FF.d=Daddr[ 7.. 4], TXD_FF=Daddr[ 3.. 0]
    TxD_Reg[4..1].d = (Daddr_Reg[4..1].q11);
    TxCRC.d[3..0]   = (Daddr_Reg[4..1].q11);
    TxCRC.clk_en    = VCC;
    IF  (CtTransm.q[3..0]== 11) Then
        TxDestAddr.d= GND;      --\_.. Then  jump (by next _/TX_CLK) ..
        TxSourAddr.d= VCC;      --/ .. to transmit the "SourceAddr"
        CtTransm_sclr = VCC;    -- CtTransm will flip to =00 by next _/TX_CLK
        Saddr_ld    = VCC;      -- Saddr_Reg-s will load by next _/TX_CLK
    ELSE        -- DestAddr=1, SourAddr=0 until CtTransm=11
        TxDestAddr.d= VCC;      --\_.. Then  continue ..
        TxSourAddr.d= GND;      --/ .. to transmit the "DestinationAddr"
    END IF;
End IF;

IF  TxSourAddr  Then    -- "SourceAddr" (6 Bytes) is being transmitted 
    -- SourAddr (ThisDevice' address, represented by Saddr[]) is to be transferred :
    -- TxSourAddr=1;  CtTransm=00,  TXD_FF.d=Saddr[43..40], TXD_FF=Saddr[ 7.. 4]
    -- TxSourAddr=1;  CtTransm=01,  TXD_FF.d=Saddr[47..44], TXD_FF=Daddr[43..40]
    -- TxSourAddr=1;  CtTransm=02,  TXD_FF.d=Saddr[35..32], TXD_FF=Daddr[47..44]
    -- TxSourAddr=1;  CtTransm=03,  TXD_FF.d=Saddr[39..36], TXD_FF=Daddr[39..36]
    -- TxSourAddr=1;     .  .  .  .  .  .  .  .  .  .  .  .  .
    -- TxSourAddr=1;  CtTransm=10,  TXD_FF.d=Saddr[ 3.. 0], TXD_FF=Daddr[11.. 8]
    -- TxSourAddr=1;  CtTransm=11,  TXD_FF.d=Saddr[ 7.. 4], TXD_FF=Daddr[ 3.. 0]
    TxD_Reg[4..1].d = (Saddr_Reg[4..1].q11);
    TxCRC.d[3..0]   = (Saddr_Reg[4..1].q11);
    TxCRC.clk_en    = VCC;
    IF  (CtTransm.q[3..0] == 11) Then
        TxSourAddr.d= GND;      --\_.. Then  jump (by next _/TX_CLK) ..
        TxPkLenTyp.d= VCC;      --/ .. to transmit the "PlLength/Type"
        CtTransm_sclr = VCC;    -- CtTransm will flip to =00 by next _/TX_CLK
        TxLng_ld    = VCC;      -- TxLng_Reg-s will load by next _/TX_CLK
    ELSE        -- SourAddr=1, TxPkLength=0 until CtTransm=11
        TxSourAddr.d= VCC;      --\_.. Then  continue ..
        TxPkLenTyp.d= GND;      --/ .. to transmit the "DestinationAddr"
    End IF;
End IF;
		        
IF  TxPkLenTyp  Then    -- "PacketLength/Type" (2 Bytes) is being transmitted 
    -- TxPkLength=1;  CtTransm=00,  TXD_FF.d=TxLength[11.. 8], TXD_FF=Daddr[ 7.. 4]
    -- TxPkLength=1;  CtTransm=01,  TXD_FF.d=TxLength[15..12], TXD_FF=TxLength[11.. 8]
    -- TxPkLength=1;  CtTransm=02,  TXD_FF.d=TxLength[ 3.. 0], TXD_FF=TxLength[15..12]
    -- TxPkLength=1;  CtTransm=03,  TXD_FF.d=TxLength[ 7.. 4], TXD_FF=TxLength[ 3.. 0]
    TxD_Reg[4..1].d = (TxLng_Reg[4..1].q3);
    TxCRC.d[3..0]   = (TxLng_Reg[4..1].q3);
    TxCRC.clk_en    = VCC;
    IF  (CtTransm.q[1..0] == 3) Then
        TxPkLenTyp.d= GND;      --\_.. Then  jump (by next _/TX_CLK) ..
        TxDataBlck.d= VCC;      --/ .. to transmit the Data Block
        CtTransm_sclr = VCC;    -- CtTransm will flip to =00 by next _/TX_CLK
    ELSE        -- PackLeng=1, DataFld =0 until couTransmit=3
        TxDataBlck.d= GND;      --\_.. Then continue ..
        TxPkLenTyp.d= VCC;      --/ .. to transmit the "PkLength/Type"
    End IF;
End IF;

IF  TxDataBlck  Then    -- "Data" ( LL="Length" Bytes ) is being transmitted 
    -- TxDataBlck=1;  CtTransm=00,     TXD_FF.d=DByte01[3..0], TXD_FF=TxLength[7..4]
    -- TxDataBlck=1;  CtTransm=01,     TXD_FF.d=DByte01[7..4], TXD_FF=DByte01[3..0]
    -- TxDataBlck=1;  CtTransm=02,     TXD_FF.d=DByte02[3..0], TXD_FF=DByte01[7..4]
    -- TxDataBlck=1;  CtTransm=03,     TXD_FF.d=DByte02[7..4], TXD_FF=DByte02[3..0]
    -- TxDataBlck=1;     .  .  .  .  .  .  .  .  .  .  .  .  .
    -- TxDataBlck=1;  CtTransm=(2*N-2),TXD_FF.d=DByteLL[3..0]
    -- TxDataBlck=1;  CtTransm=(2*N-1),TXD_FF.d=DByteLL[7..4], TXD_FF=DByteLL[3..0]
    TxD_Reg[4..1].d = TxShifter[4..1].q3;
    TxCRC.d[3..0]   = TxShifter[4..1].q3;
    TxCRC.clk_en    = VCC;
    IF (CtTransm.q[] == ((TxLength[11..1],GND) - 1)) Then
        TxDataBlck.d= GND;      --\_.. Then  jump (by next _/TX_CLK) ..
        TxFrameCRC.d= VCC;      --/ .. to transmit the "FrameCheckSequence"
        CtTransm_sclr = VCC;    -- CtTransm will flip to =00 by next _/TX_CLK
    ELSE
        TxDataBlck.d= VCC;      --\_.. Then continue ..
        TxFrameCRC.d= GND;      --/ .. to transmit the Data Block
    End IF;
End IF;

IF  TxFrameCRC  Then    -- "FrameCRC" (4 Bytes) is being transmitted 
    -- CRC-module must be =stopped=, and just-calculated CRC value is to be transferred :
    -- TxFrameCRC=1;  CtTransm=00,  TXD_FF.d=TxCRC.q[3..0], TXD_FF="ByteLL"[7..4]
    -- TxFrameCRC=1;  CtTransm=01,  TXD_FF.d=TxCRC.q[7..4], TXD_FF=CRC[ 3.. 0]
    -- TxFrameCRC=1;     .  .  .  .  .  .  .  .  .  .  .  .  .
    TxD_Reg[4..1].d = TxCRC_Reg[4..1].q7;
    TxCRC.clk_en= GND;
    IF  (CtTransm.q[2..0] == 7) Then
        TxFrameCRC.d= GND;  -- TxFrameCRC will flip to =0 by the next _/TX_CLK
        TxEndFrame.d= VCC;  -- TxEndFrame will flip to =1 by the next _/TX_CLK
    ELSE        -- TxFrameCRC=1,      until CtTransm=7
        TxFrameCRC.d= VCC;      -- continue to transmit "FrameCheckSequence"
    End IF;
End IF;

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--************  CRC module connections  ************
TxCRC.clk   = TX_CLK;
--TxCRC.clk_en= defined above in "TxCycle' State Handling" section
--TxCRC.sclr  = defined above in "TxCycle' State Handling" section
--            = TxCRC.q[31..0] -- connected in "Conversion of 32-bit FrameCRC.." section
--            = TxCRC.CRC_ok;  -- NOT used in Transmitter

----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
--********  CONVERSION of Data_Words into half-Bytes  **************************
-- ATTENTION !!  
-- от каждого поля (напр., 6-байтный DestAddr) или слова (напр., 2-байтный PacketLength) 
-- байты передаются начиная со Старшего и кончая Младшим.  
-- Контроллер всасывает сначала Младший полу-байт, потом Старший полу-байт от каждого Байта, 
-- и передаёт биты начиная с LSB и заканчивая MSB. 

--************  Conversion of 48-bit DestAddr into 12 half-Bytes  ************
-- DestAddr is sent in the following order :    Daddr[41..44],[45..48]
--                                              Daddr[33..36],[37..40]
--                                               .  .  .  .  .  .  . 
--                                              Daddr[ 1.. 4],[ 5.. 8]
Daddr_Reg[4..1].data11 = Daddr[44..41];
Daddr_Reg[4..1].data10 = Daddr[48..45];
Daddr_Reg[4..1].data9  = Daddr[36..33];
Daddr_Reg[4..1].data8  = Daddr[40..37];
Daddr_Reg[4..1].data7  = Daddr[28..25];
Daddr_Reg[4..1].data6  = Daddr[32..29];
Daddr_Reg[4..1].data5  = Daddr[20..17];
Daddr_Reg[4..1].data4  = Daddr[24..21];
Daddr_Reg[4..1].data3  = Daddr[12.. 9];
Daddr_Reg[4..1].data2  = Daddr[16..13];
Daddr_Reg[4..1].data1  = Daddr[ 4.. 1];
Daddr_Reg[4..1].data0  = Daddr[ 8.. 5];
--Daddr_Reg is loaded immediately before sending of the 1st half-Byte of Daddr 
Daddr_Reg[4..1].(clock, enable, load) = (TX_CLK, enTransmit, Daddr_ld);

--************  Conversion of 48-bit SourAddr into 12 half-Bytes  ************
-- SourAddr is sent in the following order :    Saddr[41..44],[45..48]
--                                              Saddr[33..36],[37..40]
--                                               .  .  .  .  .  .  . 
--                                              Saddr[ 1.. 4],[ 5.. 8]
Saddr_Reg[4..1].data11 = Saddr[44..41];
Saddr_Reg[4..1].data10 = Saddr[48..45];
Saddr_Reg[4..1].data9  = Saddr[36..33];
Saddr_Reg[4..1].data8  = Saddr[40..37];
Saddr_Reg[4..1].data7  = Saddr[28..25];
Saddr_Reg[4..1].data6  = Saddr[32..29];
Saddr_Reg[4..1].data5  = Saddr[20..17];
Saddr_Reg[4..1].data4  = Saddr[24..21];
Saddr_Reg[4..1].data3  = Saddr[12.. 9];
Saddr_Reg[4..1].data2  = Saddr[16..13];
Saddr_Reg[4..1].data1  = Saddr[ 4.. 1];
Saddr_Reg[4..1].data0  = Saddr[ 8.. 5];
--Saddr_Reg is loaded immediately before sending of the 1st half-Byte of Saddr 
Saddr_Reg[4..1].(clock, enable, load) = (TX_CLK, enTransmit, Saddr_ld);

--************  Conversion of 16-bit PkLenTyp into 4 half-Bytes  ***************
TxLenTyp[]  = RxLenTyp[]; -- For the moment, TxLenTyp is the same as RxLenTyp

-- PkLenTyp is sent in the following order :    PkLenTyp[ 9..12],[13..16]
--                                              PkLenTyp[ 1.. 4],[ 5.. 8]
TxLng_Reg[4..1].data3  = TxLenTyp[12.. 9];
TxLng_Reg[4..1].data2  = TxLenTyp[16..13];
TxLng_Reg[4..1].data1  = TxLenTyp[ 4.. 1];
TxLng_Reg[4..1].data0  = TxLenTyp[ 8.. 5];
TxLng_Reg[4..1].(clock, enable, load) = (TX_CLK, enTransmit, TxLng_ld);

--************  Conversion of 16-bit Data Word into 4 half-Bytes :  *************
-- The 1st DataWord to be sent must be read from the MainProject =before= 
-- the transmission of the Data Block has begun ! 
-- The 1st IORq is to be set while "PacketLength" is being transmitted. 
TxWord  = (TxPkLenTyp # TxDataBlck) & (CtTransm.q[1..0]==0);  -- 
TxWord1 = DFF(.D=TxWord,  .clk=Clock); -- aligned to MainProjects' Clock
TxWord2 = DFF(.D=TxWord1, .clk=Clock); -- aligned to MainProjects' Clock
TxWord_rq = TxWord1 & !TxWord2 ;        -- enabled for 1clk 

-- Reg_TxWord loads each 16-bit DataWord and holds it (at least) until it is loaded 
-- into the TxShifters.  After that moment the IORq is set.  The next DWord must be 
-- supplied (by the MainProject) =before= the next loading of the TxShifters. 
Reg_TxWord.data[]  = DataBus_in[]; -- подключение буферного параллельного регистра Tx к интерфейсу пользователя
Reg_TxWord.(clock, enable, load) = (Clock, 
        (TxWord_ld           -- load data at "Write" operation
      OR TxWord_rq), VCC);   -- clear after latching DataWord into TxShifters
Reg_TxWord.(sclr, aclr) = (TxWord_rq, TxEndFrame);

TxWord_ld   = Select AND DataStrobe AND RdWr_in;-- load data at "Write" operation when DataStrobe comes

TxShift_ld  = (TxPkLenTyp # TxDataBlck) & (CtTransm.q[1..0]==3); -- 1clk pulse
-- TxShifters: load a DataWord to be transmitted and shift it,
--            thus transforming a parallel DataWord into 4 consecutive half-Bytes
-- The bits are arranged :   TxShifter4  TxShifter3  TxShifter2  TxShifter1 
--       TxShifter* .data3   [  11          10           9           8   ] -> TxData[]
--       TxShifter* .data2   [  15          14          13          12   ]
--       TxShifter* .data1   [   3           2           1           0   ]
--       TxShifter* .data0   [   7           6           5           4   ]
TxShifter[4..1].data3 = Reg_TxWord.q[11.. 8]; 
TxShifter[4..1].data2 = Reg_TxWord.q[15..12]; 
TxShifter[4..1].data1 = Reg_TxWord.q[ 3.. 0]; 
TxShifter[4..1].data0 = Reg_TxWord.q[ 7.. 4]; 
TxShifter[4..1].shiftin = GND;  -- for making a ZERO-word when the next word has not been loadd in time
TxShifter1.(clock, enable, load) = (TX_Clk, (TxPkLenTyp # TxDataBlck), TxShift_ld); 
TxShifter2.(clock, enable, load) = (TX_Clk, (TxPkLenTyp # TxDataBlck), TxShift_ld); 
TxShifter3.(clock, enable, load) = (TX_Clk, (TxPkLenTyp # TxDataBlck), TxShift_ld); 
TxShifter4.(clock, enable, load) = (TX_Clk, (TxPkLenTyp # TxDataBlck), TxShift_ld); 
--        = TxShifter[4..1].q3;   -- MSbits of TxShifters -> TxD_Reg[4..1]

--************  Conversion of 32-bit FrameCRC into 4 half-Bytes  ***************
-- FrameCRC is sent in the following order :    FrameCRC[25..28],[29..32]
--                                              FrameCRC[16..20],[21..24]
--                                               .  .  .  .  .  .  .  .
--                                              FrameCRC[ 1.. 4],[ 5.. 8]
-- A VALID value of FrameCRC is asserted simultaneously with TxFrameCRC flipping to =1 =>
-- => this value must be latched AFTER the TxFrameCRC has flipped to =1  => 
-- => this value can only be latched by 1st \_TX_CLK after TxFrameCRC flipped to =1.
--TxCRC_Reg[4..1].data7  = TxCRC.q[27..24];
--TxCRC_Reg[4..1].data6  = TxCRC.q[31..28];
--TxCRC_Reg[4..1].data5  = TxCRC.q[19..16];
--TxCRC_Reg[4..1].data4  = TxCRC.q[23..20];
--TxCRC_Reg[4..1].data3  = TxCRC.q[11.. 8];
--TxCRC_Reg[4..1].data2  = TxCRC.q[15..12];
--TxCRC_Reg[4..1].data1  = TxCRC.q[ 3.. 0];
--TxCRC_Reg[4..1].data0  = TxCRC.q[ 7.. 4];
TxCRC_Reg[4..1].data7  = TxCRC.q[ 3.. 0];
TxCRC_Reg[4..1].data6  = TxCRC.q[ 7.. 4];
TxCRC_Reg[4..1].data5  = TxCRC.q[11.. 8];
TxCRC_Reg[4..1].data4  = TxCRC.q[15..12];
TxCRC_Reg[4..1].data3  = TxCRC.q[19..16];
TxCRC_Reg[4..1].data2  = TxCRC.q[23..20];
TxCRC_Reg[4..1].data1  = TxCRC.q[27..24];
TxCRC_Reg[4..1].data0  = TxCRC.q[31..28];
TxCRC_Reg[4..1].(clock, enable, load) = (!TX_CLK, TxFrameCRC, TxCRC_ld);
TxCRC_ld    = TxFrameCRC & (CtTransm.q[3..0]==0); -- 1clk pulse

--============================================================================
--**************** Section "User Interface Control" :         ****************
-- С-л TxWord_rq устанавливает запрос на чтение из MainProject-а в Reg_TxWord.
-- Запрос сбрасывается по окончании чтения (если оно произошло) или в конце 
-- допустимого времени ожидания (за 1 Ethernet-ный такт до момента, когда 
-- запрошенное слово будет переписывается в TxShifters. 
--   Следующий запрос на чтение возникает одновременно с перезагрузкой 
-- в TxShifter уже готового слова данных, прочитанного по первому запросу.
-- С-л RxWord_en устанавливает запрос на запись из Reg_RxWord в MainProject.
-- Запрос сбрасывается по окончании чтения (если оно произошло) или в конце 
-- допустимого времени ожидания (за 1 Ethernet-ный такт до момента, когда 
-- в Reg_RxWord будет переписываться следующее принятое слово из RxShifters. 

IORq_r  = RxWordConv &(CtReceiv.q[1..0]==2);--\ to reset IORq just before..
IORq_r1 = DFF(.D=IORq_r,  .clk=Clock);      -- >.. the next request, ..
IORq_r2 = DFF(.D=IORq_r1, .clk=Clock);      --/ .. if this IORq has not been executed

-- Req.for "Write": user should read data / Req.for "Read": user MUST supply data
IORq_set= RxWord_en OR TxWord_rq ;          --   1clk _/^\_ 
IORq_rst= (IORq_r1 & !IORq_r2)              -- \_1clk _/^\_ just before a new request
            OR (TxWord_ld # TxShift_ld1);   -- / 

IORq    =SRFF(.S=IORq_set, .clk=Clock,      -- Request for "Write" or "Read"
            .R=((Select & DataStrobe)       -- Reset when data transfer done ..
            OR IORq_rst),                   -- .. OR just before a new request
            .clrn=!(TxEndFrame # RxEndFrame # Reset)) ;

RdWr_out=SRFF(.S=RxWord_en,                 --"Write": Link -> user project
            .R=((Select & DataStrobe)       -- Reset when data transfer done
            OR IORq_rst),                   -- .. OR just before a new request
            .clk=Clock,
            .clrn=!(TxEndFrame # RxEndFrame # Reset)) ;

-- IF a DataWord has NOT been supplied by the MainProject in time :
TxShift_ld1 = DFF(.D=TxShift_ld, .clk=Clock); -- strobe at the =last moment= before loading the TxShifters 
IF  ((IORq & !RdWr_out) & !TxWord_ld AND TxShift_ld1) 
    Then  TxWord_Error = VCC; 
    Else  TxWord_Error = GND;
End IF;

-- When RdWr_out=1: (Link => UserProj ("Write")) requested, =>     \
--    => UserProj should "read" data from Link => RdWr_in must be =0\ Must be:
-- When RdWr_out=0: (Link <= UserProj ("Read")) requested, =>       /RdWr_in != RdWr_out
--    => UserProj must "write" data to Link => RdWr_in must be =1  /
IF ( ((IORq & Select) == VCC) AND (RdWr_in == RdWr_out) ) 
    Then  RdWr_Error = VCC; 
    Else  RdWr_Error = GND;
End IF;

--Error = TxWord_Error # RdWr_Error;

--============================================================================
Test1 = enTransmit;     --RX_DV_FF;       --enTransmit;
Test2 = CtTransm_sclr;  --RxChkPream;     --Daddr_ld;     
Test3 = Daddr_ld;       --CtReceiv_sclr;  --Saddr_ld;
Test4 = Saddr_ld;       --ChkDaddr_ena;   --TxLng_ld;
Test5 = TxLng_ld;       --ChkDaddr.q;     --TxWord_ld;
Test6 = TxWord_ld;      --RxWordConv;     --TxShift_ld;
Test7 = TxShift_ld;     --RxWord_en;      --TxCRC_ld;
Test8 = TxCRC_ld;       --R_Error.q;      --TxEndFrame.q;

END;